<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Algorithmus UI – Grid rechts</title>

<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: white;
    height: 100vh;
    display: flex;
    justify-content: flex-end; /* alles nach rechts */
    align-items: flex-start;       /* vertikal zentriert */
    padding-top: 10px;
  }

  .right-grid {
    width: 55vw;                 /* breiter */
    max-width: 580px;            /* größere Maximalbreite */
    height: calc(100vh - 20px);  /* bis fast an unteren Bildschirmrand */
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-auto-rows: 1fr;
    gap: 10px;
    padding-right: 10px;
    padding-bottom: 15px;
  }

  /* Jedes einzelne Rechteck */
  .cell {
    background: #E6E6E6;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .hand-cell {
    position: relative;
  }

  .hand-content {
    position: absolute;
    top: 5%;
    left: 5%;
    right: 5%;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
    height: 100%;
  }

  .hand-title {
    font-size: calc(3vw + 3vh);
    font-weight: 700;
    color: #5f5e5e;
    word-break: break-word;
  }

  .hand-icon {
    position: absolute;
    bottom: 10%;
    left: 50%;
    width: calc(15vw + 15vh);
    height: calc(15vw + 15vh);
    max-width: 90%;
    max-height: 50%;
    transform: translateX(-50%) rotate(180deg);
    stroke-width: 2.5;
    color: #5f5e5e;
    visibility: hidden;
  }

  .icon-right svg {
    transform: rotate(180deg) scaleX(-1);
  }

  .icon-left svg {
    transform: rotate(180deg);
  }

  .icon-random svg {
    transform: none;
  }

  .hand-icon.right-hand svg {
    transform: rotate(180deg) scaleX(-1);
  }

  .hand-icon.left-hand svg {
    transform: rotate(180deg);
  }

  .hand-icon.random-mode svg {
    transform: none;
  }

  .lage-cell {
    position: relative;
  }

  .lage-content {
    position: absolute;
    top: 5%;
    left: 5%;
    right: 5%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
  }

  .lage-letter {
    font-size: calc(15vw + 15vh);
    font-weight: 700;
    color: #5f5e5e;
    line-height: 1;
    width: 100%;
    word-break: break-word;
    text-align: center;
  }

  .lage-word {
    margin-top: 10px;
    font-weight: 600;
    color: #5f5e5e;
    font-size: calc(1.5vw + 1.5vh);
    max-width: 100%;
    text-transform: uppercase;
  }

  .gespielt-cell {
    position: relative;
  }

  .gespielt-content {
    position: absolute;
    top: 5%;
    left: 5%;
    right: 5%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .gespielt-letter {
    font-size: calc(15vw + 15vh);
    font-weight: 700;
    color: #5f5e5e;
    line-height: 1;
    width: 100%;
    text-align: center;
    word-break: break-word;
  }

  .rabbit-cell {
    position: relative;
  }

  .rabbit-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    width: calc(15vw + 15vh);
    height: calc(15vw + 15vh);
    max-width: 90%;
    max-height: 90%;
    transform: translate(-50%, -50%);
    stroke-width: 2.5;
    color: #5f5e5e;
  }


  /* Texte im Rechteck — rotiert wie im Original */
  .label {
    transform: rotate(-90deg);   /* exakt wie SVG */
    font-size: 26px;
    font-weight: bold;
    color: #5f5e5e;
    pointer-events: none;
    user-select: none;
  }

  #left-area {
    position: absolute;
    top: 0;
    left: 0;
    width: calc(100vw - 55vw - 10px);
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  #stave-canvas {
    max-width: 90%;
    max-height: 90%;
  }

  .hand-cell { cursor: pointer; }
  .lage-cell { cursor: pointer; }
</style>
</head>

<body>

  <div id="left-area">
    <div id="notation"></div>
  </div>

  <div class="right-grid">
    <div class="cell hand-cell">
      <div class="hand-content">
        <div class="hand-title">Rechte Hand</div>
        <i data-lucide="hand-helping" class="hand-icon icon-right" style="visibility: visible;"></i>
        <i data-lucide="hand-helping" class="hand-icon icon-left" style="visibility: hidden;"></i>
        <i data-lucide="dices" class="hand-icon icon-random" style="visibility: hidden;"></i>
        <i data-lucide="flask-conical" class="hand-icon icon-expert" style="visibility: hidden;"></i>
      </div>
    </div>
    <div class="cell lage-cell">
      <div class="lage-content">
        <div class="lage-letter">C</div>
        <div class="lage-word">Lage</div>
      </div>
    </div>
    <div class="cell gespielt-cell">
      <div class="gespielt-content">
        <div class="gespielt-letter">A</div>
    </div>
    </div>
    <div class="cell rabbit-cell">
      <i data-lucide="rabbit" class="rabbit-icon"></i>
    </div>
  </div>

<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>

<script>
  lucide.createIcons();

  let upperSeries = [];
  let lowerSeries = [];
  let upperCounter = 0;
  let lowerCounter = 0;
  let playUpper = true;

  let handModes = ["Rechte Hand", "Linke Hand", "Zufall", "Experte"];
  let handIndex = 0;

let lageList = ["C", "D", "E", "F", "G", "A", "B"];
let lageIndex = 0;

  const handTitle = document.querySelector(".hand-title");
  let handIcon = document.querySelector(".hand-icon");
  const lageLetter = document.querySelector(".lage-letter");

  // --------- CLICK HAND ----------
  document.querySelector(".hand-cell").addEventListener("click", () => {
    handIndex = (handIndex + 1) % handModes.length;

    const mode = handModes[handIndex];

    // Update text
    handTitle.textContent = mode;

    let iconName = "hand-helping";

    // Hide all icons
    document.querySelector(".icon-right").style.visibility = "hidden";
    document.querySelector(".icon-left").style.visibility = "hidden";
    document.querySelector(".icon-random").style.visibility = "hidden";
    document.querySelector(".icon-expert").style.visibility = "hidden";

    // Show correct icon
    if (mode === "Rechte Hand") {
      document.querySelector(".icon-right").style.visibility = "visible";
    }
    else if (mode === "Linke Hand") {
      document.querySelector(".icon-left").style.visibility = "visible";
    }
    else if (mode === "Experte") {
      document.querySelector(".icon-expert").style.visibility = "visible";
    }
    else {
      document.querySelector(".icon-random").style.visibility = "visible";
    }

    generateSeries();
  });

  // --------- CLICK LAGE ----------
  document.querySelector(".lage-cell").addEventListener("click", () => {
    lageIndex = (lageIndex + 1) % lageList.length;
    lageLetter.textContent = lageList[lageIndex];
    generateSeries();
  });

  // --------- MIDI SETUP ----------
  let midiAccess = null;
  let lastNote = null;

  function onMIDIMessage(event) {
    const [command, note, velocity] = event.data;

    if (command === 144 && velocity > 0) {
      const played = midiToNote(note);
      document.querySelector(".gespielt-letter").textContent = played;

      // --- Speed Icon Logic ---
      const now = performance.now();
      if (!window._lastSpeedTime) window._lastSpeedTime = now;
      const delta = now - window._lastSpeedTime;
      window._lastSpeedTime = now;

      let speedIcon = "turtle";
      if (delta < 400) speedIcon = "rocket";
      else if (delta < 900) speedIcon = "rabbit";

      const speedElm = document.querySelector(".rabbit-icon");
      if (speedElm) {
        speedElm.setAttribute("data-lucide", speedIcon);
        lucide.createIcons();
      }

      const playedUpper = played.toUpperCase();

      let upperExpected = upperSeries[upperCounter];
      let lowerExpected = lowerSeries[lowerCounter];

      let upperMatch = false;
      let lowerMatch = false;

      if (upperExpected) {
        const expU = upperExpected.note.replace("#","♯").toUpperCase();
        if (playedUpper === expU) upperMatch = true;
      }

      if (lowerExpected) {
        const expL = lowerExpected.note.replace("#","♯").toUpperCase();
        if (playedUpper === expL) lowerMatch = true;
      }

      if (handModes[handIndex] === "Rechte Hand") {
        if (upperMatch) {
          upperExpected.color = "green";
          upperCounter++;
        } else {
          upperExpected.color = "red";
        }
      }

      else if (handModes[handIndex] === "Linke Hand") {
        if (lowerMatch) {
          lowerExpected.color = "green";
          lowerCounter++;
        } else {
          lowerExpected.color = "red";
        }
      }

      else if (handModes[handIndex] === "Zufall") {
        if (playUpper) {
          let expected = upperSeries[upperCounter];
          if (upperMatch) {
            expected.color = "green";
            upperCounter++;
          } else {
            expected.color = "red";
          }
        } else {
          let expected = lowerSeries[lowerCounter];
          if (lowerMatch) {
            expected.color = "green";
            lowerCounter++;
          } else {
            expected.color = "red";
          }
        }
        playUpper = !playUpper;
      }

      else if (handModes[handIndex] === "Experte") {
        if (playUpper) {
          let expected = upperSeries[upperCounter];
          if (upperMatch) {
            expected.color = "green";
            upperCounter++;
            playUpper = false;
          } else {
            expected.color = "red";
          }
        } else {
          let expected = lowerSeries[lowerCounter];
          if (lowerMatch) {
            expected.color = "green";
            lowerCounter++;
            playUpper = true;
          } else {
            expected.color = "red";
          }
        }
      }

      drawSeries();

      if (upperCounter >= 3 && lowerCounter >= 3) {
        setTimeout(() => generateSeries(), 400);
      }
    }
  }

  function midiToNote(num) {
    const notes = ["C", "C#", "D", "D#", "E","F","F#","G","G#","A","A#","B"];
    return notes[num % 12];
  }

  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess().then((access) => {
      midiAccess = access;
      for (let input of midiAccess.inputs.values()) {
        input.onmidimessage = handleMIDIMessageWeb;
      }
    });
  }

  const lageNotes = {
    "C": ["c", "d", "e", "f", "g"],
    "D": ["d", "e", "f#", "g", "a"],
    "E": ["e", "f#", "g#", "a", "b"],
    "F": ["f", "g", "a", "b", "c"],
    "G": ["g", "a", "b", "c", "d"],
    "A": ["a", "b", "c", "d", "e"],
    "B": ["b", "c#", "d", "e", "f#"]
  };

  function generateSeries() {
    upperSeries = [];
    lowerSeries = [];
    upperCounter = 0;
    lowerCounter = 0;

    // Always 6 notes total, alternating: U, L, U, L, U, L
    seriesLength = 6;

    const lage = lageList[lageIndex];
    const possibleNotes = lageNotes[lage];

    for (let i = 0; i < 3; i++) {
      // Upper
      let r1 = Math.floor(Math.random() * possibleNotes.length);
      upperSeries.push({
        note: possibleNotes[r1],
        octave: 4,
        clef: "treble",
        color: "black"
      });

      // Lower (paired)
      let r2 = Math.floor(Math.random() * possibleNotes.length);
      lowerSeries.push({
        note: possibleNotes[r2],
        octave: 2,
        clef: "bass",
        color: "black"
      });
    }

    playUpper = true; // alternating start
    drawSeries();
  }

  // --------- VEXFLOW RENDER ----------
  function drawSeries() {
    var notationDiv = document.getElementById("notation");
    notationDiv.innerHTML = "";

    var totalWidth = 80 * seriesLength + 30;
    var totalHeight = 320;

    var renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
    renderer.resize(totalWidth, totalHeight);
    var context = renderer.getContext();

    function renderStave(yOffset, series) {
      var stave = new Vex.Flow.Stave(10, yOffset, totalWidth - 20);
      if (series.length > 0) {
        stave.addClef(series[0].clef);
      }
      stave.setContext(context).draw();

      var staveNotes = series.map(function(item) {
        const key = item.note + "/" + item.octave;
        const note = new Vex.Flow.StaveNote({
          clef: item.clef,
          keys: [key],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color });

        if (item.note.includes("#")) {
          note.addModifier(0, new Vex.Flow.Accidental("#"));
        }
        return note;
      });

      var voice = new Vex.Flow.Voice({ num_beats: series.length, beat_value: 4 });
      staveNotes.forEach(n => voice.addTickable(n));
      new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
      voice.draw(context, stave);
    }

    renderStave(40, upperSeries);
    renderStave(180, lowerSeries);
  }

  generateSeries();

  function handleMIDIMessageWeb(event) {
    const [status, data1, data2] = event.data;
    window.handleMIDIMessage(status, data1, data2);
  }

  // --- Swift MIDI Bridge (iOS WebView -> JS) ---
  window.handleSwiftMIDI = function(status, data1, data2) {
    return window.handleMIDIMessage(status, data1, data2);
  };
</script>

</body>
</html>
