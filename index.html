<!DOCTYPE html>
<html>
<head>
  <!-- Standard-Meta-Tags -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  
  <!-- GitHub Dateien laden -->
  <link rel="manifest" href="https://raw.githubusercontent.com/JP0024/piano.github.io/main/manifest.json">
  <link rel="stylesheet" href="/piano.github.io/main/CSS/style.css">

  <!-- Externe Skripte laden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

  <!-- Schriften laden -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  
  <!-- Standardeinstellungen -->
  <meta name="theme-color" content="#000000">
  
  <!-- SCRIPT BEREICH -->

  <script>
      
      let twoHandMode = false;
      let seriesCounterLeft = 0;
      let seriesCounterRight = 0;
      let currentSeriesLeft = [];
      let currentSeriesRight = [];
      let articulationMode = null; // null, "staccato" oder "legato"

        // Initialize global homeworkData from storage
        window.homeworkData = JSON.parse(localStorage.getItem("homeworkData") || "null");
        // ‚Ä¶ der restliche bisherige Script-Code ‚Ä¶
      
      let homeworkData = JSON.parse(localStorage.getItem("homeworkData") || "null");
      
      
      // (hwToggle click event listener will be added later in DOMContentLoaded after settingsPanel.appendChild(hwToggle))

      // Camera-based QR scanning
      async function openCameraScan() {
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        } catch (err) {
          alert("Kamerazugriff fehlgeschlagen: " + err.message);
          return null;
        }
        // Create modal overlay
        const scanOverlay = document.createElement("div");
        scanOverlay.id = "scanOverlay";
        Object.assign(scanOverlay.style, {
          position: "fixed", top:0, left:0, width:"100%", height:"100%",
          background:"rgba(0,0,0,0.8)", display:"flex", alignItems:"center", justifyContent:"center", zIndex:"2000"
        });
        const video = document.createElement("video");
        video.style.maxWidth = "90%";
        video.style.maxHeight = "80%";
        video.autoplay = true;
        video.srcObject = stream;
        scanOverlay.appendChild(video);
        const captureBtn = document.createElement("button");
        captureBtn.textContent = "Scannen";
        Object.assign(captureBtn.style, { position:"absolute", bottom:"20px", fontSize:"1.2em", padding:"10px" });
        scanOverlay.appendChild(captureBtn);
        document.body.appendChild(scanOverlay);
        return new Promise(resolve => {
          captureBtn.addEventListener("click", () => {
            const canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext("2d").drawImage(video, 0, 0);
            const code = jsQR(canvas.getContext("2d").getImageData(0,0,canvas.width,canvas.height).data, canvas.width, canvas.height);
            stream.getTracks().forEach(t => t.stop());
            document.body.removeChild(scanOverlay);
            resolve(code);
          });
        });
      }
      
    // Disable any scrolling
    window.addEventListener('scroll', function(e) {
      e.preventDefault();
      window.scrollTo(0, 0);
    }, { passive: false });
  
  // Oben im Skript
  let customModeSettings = null;
  const octaveDefinitions = {
    grosse:   { notes: ["c","d","e","f","g","a","b"], baseOctave: 3 },
    kleine:   { notes: ["c","d","e","f","g","a","b"], baseOctave: 4 },
    eingestr: { notes: ["c","d","e","f","g","a","b"], baseOctave: 5 },
    zweigestr:{ notes: ["c","d","e","f","g","a","b"], baseOctave: 6 },
  };
  
let wizardMode = true;
   let correctionActive = false;
   let availableNotes = [];
   let selectedNoteIndex = 0;
   let expectedNote = "";
   
   
      
// === Touch‚Äêbased positioning for the notation crosshair ===
document.addEventListener('DOMContentLoaded', () => {
  const notation = document.getElementById('notation');
  if (!notation) return;

  // Load or set default transform
  let saved = localStorage.getItem('notationTransform');
  if (!saved) {
    saved = 'translate(-50%, -50%)';
    localStorage.setItem('notationTransform', saved);
  }
  notation.style.transform = saved;

  // Prepare variables for touch dragging
  let startX = 0, startY = 0;
  let initX = 0, initY = 0;
  let dragging = false;

  notation.addEventListener('touchstart', e => {
    // Only allow dragging if the Geodreieck-Button ("geometryToggle") is active
    const toggle = document.getElementById('geometryToggle');
    const isActive = toggle && (toggle.classList.contains('active') || toggle.dataset.active === 'true');
    if (!isActive) return;
    e.preventDefault();
    dragging = true;
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
    const style = window.getComputedStyle(notation);
    const matrix = new DOMMatrix(style.transform);
    initX = matrix.m41;
    initY = matrix.m42;
  }, { passive: false });

  notation.addEventListener('touchmove', e => {
    if (!dragging) return;
    e.preventDefault();
    const touch = e.touches[0];
    const dx = touch.clientX - startX;
    const dy = touch.clientY - startY;
    const newX = initX + dx;
    const newY = initY + dy;
    // Calculate the position of the center of notation in viewport
    // The transform is relative to (left:50%, top:50%)
    const newLeft = newX + window.innerWidth / 2;
    const newTop = newY + window.innerHeight / 2;
    if (
      newLeft > 0 &&
      newLeft < window.innerWidth &&
      newTop > 0 &&
      newTop < window.innerHeight
    ) {
      notation.style.transform = `translate(${newX}px, ${newY}px)`;
    }
  }, { passive: false });

  notation.addEventListener('touchend', () => {
    if (!dragging) return;
    dragging = false;
    localStorage.setItem('notationTransform', notation.style.transform);
  });
});
    
      
      document.addEventListener("DOMContentLoaded", () => {
        const timerElem = document.getElementById("timerContainer");
        // Beispiel: Direkt eine Info setzen
        timerElem.textContent = `${sessionCounter} Noten, vsl. 00:00 min`;
        // Oder den Timer sofort updaten, falls du eine Funktion hast:
        updateTimer();
      // Entfernt: Doppele Aufruf von startTutorialSequence() wurde entfernt,
      // da das Tutorial nun ausschlie√ülich √ºber die MIDI-Pr√ºfung gestartet wird.
      });
      let elapsedTimer = 0;
      let cachedUserRank = null;
      let kidsMode = false;
      
      function updateUserPlacement(valueElem, data) {
        const sorted = data.sort((a, b) => {
          const qA = parseInt(a.quote || 0), qB = parseInt(b.quote || 0);
          const sA = parseInt(a.speed || 9999), sB = parseInt(b.speed || 9999);
          if (qB !== qA) return qB - qA;
          return sA - sB;
        });
        const rank = sorted.findIndex((e) => e.user === userID) + 1;
        const text = rank > 0 ? `Platz ${rank}` : "Nicht gefunden";
        cachedUserRank = text;
        valueElem.textContent = text;
      }
      
      function showMotivation(message) {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = message;
          overlay.style.opacity = "1";
          overlay.classList.add("animate-motivation");
          setTimeout(() => {
               overlay.style.opacity = "0";
               overlay.classList.remove("animate-motivation");
          }, 2000);
      }

      function clearMotivation() {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = "";
      }
      
    /************** Funktionen, die vor der Verwendung deklariert sein m√ºssen **************/
    // Eigene Prompt-Funktion, die in Swift-Umgebungen den Message-Handler nutzt
      function customPrompt(message) {
    if (typeof prompt === 'function') {
          return prompt(message);
    } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt) {
          // Sende die Nachricht an Swift; Swift muss dann eine Antwort zur√ºckliefern,
          // z. B. indem es window.customPromptResponse setzt.
          window.webkit.messageHandlers.customPrompt.postMessage(message);
          // Hier nehmen wir an, dass Swift synchron oder zeitnah eine Antwort liefert und
          // diese in window.customPromptResponse speichert. (Alternativ muss hier asynchron vorgegangen werden.)
          return window.customPromptResponse || "";
        } else {
          console.log("Kein Prompt verf√ºgbar.");
          return "";
        }
      }
      
    // Metronom-Variablen und Funktionen
      let metronomeOn =false;
      let metronomeBPM = 0;
      let metronomeInterval = 0;
      let metronomeTimer = null;
      let lastTickTime = 0;
      let metronomeTolerance = 100; // ms Toleranz f√ºr MIDI-√úbertragung
      // Tick-Sound (bitte ggf. die URL anpassen)
      const tickSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/tick.mp3");
    
      function startMetronome() {
        lastTickTime = Date.now();
        tickSound.currentTime = 0;
        tickSound.play();
        metronomeTimer = setInterval(() => {
          tickSound.currentTime = 0;
          tickSound.play();
          lastTickTime = Date.now();
        }, metronomeInterval);
      }
    
      function stopMetronome() {
        clearInterval(metronomeTimer);
      }

      function showPauseScreen() {
        sessionPaused = true;
        document.getElementById("mainContent").style.display = "none";
        document.getElementById("timerContainer").style.display = "none";
        document.getElementById("settingsPanel").style.display = "none";
        document.getElementById("pauseOverlay").style.display = "flex";
      }
      
    // Neue Funktion, die einen gr√ºnen Farbtupfer erzeugt
    function saveButtonEffect() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      
      // Hole die Position des Men√ºs (settingsPanel)
      const settingsPanel = document.getElementById("settingsPanel");
      let x, y;
      if (settingsPanel) {
        const rect = settingsPanel.getBoundingClientRect();
        // Tupfer soll in der Mitte des Men√ºs erscheinen
        x = rect.left + rect.width / 2;
        y = rect.top + rect.height / 2;
      } else {
        // Fallback: Mitte des Canvas
        x = canvas.width / 2;
        y = canvas.height / 2;
      }
      
      // Definiere Parameter f√ºr den Tupfer
      const radius = Math.random() * 200 + 200; // Gr√∂√üe anpassen
      const creationTime = Date.now();
      const duration = 1500; // Dauer in Millisekunden
      
      // Erzeuge den Tupfer (Farbtupfer wird zur globalen circles-Array hinzugef√ºgt)
      circles.push({ x, y, radius, color: "green", creationTime, duration });
    }
      
    function updateStreak() {
      // Hole den bisherigen Streak (falls vorhanden)
      let streak = Number(localStorage.getItem("streak")) || 0;
      // Hole das Datum der letzten Lernsession, falls vorhanden
      let lastDateStr = localStorage.getItem("lastLearnDate");
      // Bestimme heute (ohne Uhrzeit)
      let today = new Date();
      today.setHours(0,0,0,0);
      
      if (lastDateStr) {
        let lastDate = new Date(lastDateStr);
        lastDate.setHours(0,0,0,0);
        // Berechne den Unterschied in Tagen
        let diffDays = (today - lastDate) / (1000 * 60 * 60 * 24);
        if (diffDays === 1) {
          // Konsekutiver Tag: Erh√∂he den Streak
          streak++;
        } else if (diffDays > 1) {
          // Mehr als ein Tag Pause: Streak zur√ºcksetzen
          streak = 1;
        }
        // Falls diffDays === 0: wir sind noch am gleichen Tag; der Streak bleibt unver√§ndert
      } else {
        streak = 1;
      }
      
      // Speichere das heutige Datum und den aktuellen Streak
      localStorage.setItem("lastLearnDate", today.toISOString());
      localStorage.setItem("streak", streak);
      
      return streak;
    }
      
      document.addEventListener("DOMContentLoaded", () => {
        // Aktualisiere und zeige den Streak an:
        const currentStreak = updateStreak();
        const streakDisplay = document.getElementById("streakDisplay");
        streakDisplay.textContent = "üî• " + currentStreak;
        streakDisplay.style.cursor = "pointer";
        streakDisplay.addEventListener("click", () => {
          sessionCounter = 0;
          updateTimer();
          startPauseCountdown();
        });

        // ... restlicher Initialisierungscode
      });
      
    function logSessionStart() {
      const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
      sessionTimes.push(new Date().toISOString());
      localStorage.setItem("sessionTimes", JSON.stringify(sessionTimes));
    }
      
    // Speichert die relevanten Statistiken im localStorage
    function saveStatistics() {
      const stats = {
        totalAttempts: totalAttempts,
        correctAnswers: correctAnswers,
        correctNoteCount: correctNoteCount,
        responseTimes: responseTimes,
        sessionCount: sessionCount,
        hearts: hearts,
        errorNotes: errorNotes,
        // Du kannst hier auch weitere Variablen eintragen, z.B. openTimes, appStartTime etc.
        appStartTime: appStartTime
      };
      localStorage.setItem("appStatistics", JSON.stringify(stats));
      // Ensure all leaderboard values (accuracy, duration, mode) are sent for proper leaderboard updates
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
        window.webkit.messageHandlers.gameCenter.postMessage({
          type: "highscore",
          value: {
            accuracy: Math.round((correctAnswers / totalAttempts) * 100),
            duration: Math.floor((Date.now() - appStartTime) / 1000),
            mode: randomMode ? "random" : selectedMode
          }
        });
      }
    }

    // L√§dt die Statistiken aus dem localStorage und weist sie den globalen Variablen zu
    function loadStatistics() {
      const statsStr = localStorage.getItem("appStatistics");
      if (statsStr) {
        const stats = JSON.parse(statsStr);
        totalAttempts = stats.totalAttempts || 0;
        correctAnswers = stats.correctAnswers || 0;
        correctNoteCount = stats.correctNoteCount || 0;
        responseTimes = stats.responseTimes || [];
        sessionCount = stats.sessionCount || 0;
        hearts = stats.hearts || (unlimitedLives ? Infinity : 4);
        errorNotes = stats.errorNotes || [];
        appStartTime = stats.appStartTime || Date.now();
      }
    }

    // Optional: Speichern der Statistiken, wenn die Seite geschlossen wird
    window.addEventListener("beforeunload", saveStatistics);

    // Beim Laden der Seite die Statistiken laden
    document.addEventListener("DOMContentLoaded", loadStatistics);
    
    function proceedToMainScreen() {
      const audio = document.getElementById("backgroundSound");
      if (audio) { audio.pause(); }
      appStartTime = Date.now();
      const welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.opacity = "0";
      setTimeout(() => {
        welcomeOverlay.classList.add("hidden");
        const mainContent = document.getElementById("mainContent");
        mainContent.style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        setTimeout(() => { mainContent.style.opacity = "1"; }, 10);
      }, 500);
    }
    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      const settingsPanel = document.getElementById("settingsPanel");
      const pauseButton = document.createElement("span");
      pauseButton.id = "pauseButton";
      pauseButton.textContent = "üéπ";
      settingsPanel.appendChild(pauseButton);

      pauseButton.addEventListener("click", () => {
        const notationElem = document.getElementById("notation");
        const vk = document.getElementById("virtualKeyboard");
        if (vk) {
          const isHidden = vk.style.visibility === "hidden";
          vk.style.visibility = isHidden ? "visible" : "hidden";
          // Neu: Klasse setzen/removen
          if (isHidden) {
            document.body.classList.add("vk-active");
          } else {
            document.body.classList.remove("vk-active");
          }
          if (notationElem) {
            if (isHidden) {
              // Keyboard wird aktiviert: Notation etwas h√∂her positionieren
              notationElem.style.top = "55%";
            } else {
              // Keyboard wird deaktiviert: gespeicherte Position wiederherstellen
              const saved = localStorage.getItem("notationTransform");
              if (saved) notationElem.style.transform = saved;
              // Entferne inline-top, damit CSS-Default (85%) greift
              notationElem.style.top = "";
            }
          }
        }
      });

      // ---- Virtual Keyboard below notation ----
      // Find the button container
      const bc = document.getElementById("buttonContainer");
      if (bc) {
        // Create a virtual keyboard element
        const vk = document.createElement("div");
        vk.id = "virtualKeyboard";
        vk.textContent = "Virtuelles Keyboard";
        // Keyboard initially hidden
        vk.style.visibility = "hidden";
        vk.style.position = "fixed";
        vk.style.top = "10%";
        vk.style.transform = "translateY(210%) scale(0.7, 1.5)"; // Uniform Zoom: both axes the same scale
        vk.style.zIndex = "100";
        vk.style.background = "#eee";
        vk.style.padding = "100px";
        // Initially place it just above the button container
        // We'll update its position on window resize and DOMContentLoaded
        function positionVK() {
          const bcRect = bc.getBoundingClientRect();
          const vkHeight = vk.offsetHeight || 200;
          // Place it above the button container, but not out of screen
          let top = bcRect.top - vkHeight - 5;
          if (top < 0) top = 0;
          vk.style.top = `${top}px`;
        }
        // Append first so offsetHeight is available
        document.body.appendChild(vk);
        // --- Override key dimensions after rendering ---
        setTimeout(() => {
          const whiteKeys = vk.querySelectorAll('.white-key, .white');
          whiteKeys.forEach(key => {
            key.style.width = '23px';
            key.style.height = '260px';
          });
          const blackKeys = vk.querySelectorAll('.black-key, .black');
          blackKeys.forEach(key => {
            key.style.width = '14px';
            key.style.height = '80px';
            key.style.marginLeft = '-7px';
            key.style.marginRight = '-7px';
          });
        }, 100);
        // Position after appending
        positionVK();
        // Update position on window resize and orientation change
        window.addEventListener("resize", positionVK);
        window.addEventListener("orientationchange", positionVK);
        // The virtual keyboard layout and input is now handled only by QwertyHancock or other dedicated code.
        // No manual <button> elements are created here.
      }
    });
      
    /************** Globale Variablen & Konstanten **************/
    // Handoptionen
    const handOptions = [
      { mode: "left", symbol: "‚úã" },
      { mode: "right", symbol: "‚úã", flip: true }
    ];
    let currentHandIndex = 0;
    let selectedMode = handOptions[currentHandIndex].mode;
    let randomMode = false;
    
    // Verf√ºgbare Lagen
    const rangeArray = ["C", "D", "F", "G", "MC"];
    const alternatingRanges = ["C", "D", "MC"]; // Vordefinierte Lagen, die im Hasenmodus alternieren sollen
    let currentRangeIndex = 0;
    let currentRange = rangeArray[currentRangeIndex];
    
    // Wichtig: Definition der rangeNotes ‚Äì Zuordnung von Lage zu Noten
    const rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    let currentSeriesSingle = [];
    let seriesCounter = 1000;
    const seriesLength = 5;
    let totalAttempts = 0;
    let correctAnswers = 0;
    let correctNoteCount = 0;
    let nextMotivationThreshold = getRandomThreshold();
    let errorNotes = [];
    let responseTimes = [];
    let lastNoteTimestamp = Date.now();
    let appStartTime = Date.now();
    let sessionCounter = Number(localStorage.getItem("sessionCounter")) || 5; // 5 korrekte Noten erforderlich
    let sessionPaused = false;
    let scoreRecorded = false;
    let sessionCount = 0;
    let unlimitedLives = true;
    let hearts = unlimitedLives ? Infinity : 4;
    let inactivityTimeout = null;
    
    // Beim Laden der Seite oder zu Beginn eines Trainings:
    const saveOpenTime = () => {
      const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
      openTimes.push(new Date().toISOString());
      localStorage.setItem("openTimes", JSON.stringify(openTimes));
    };

    document.addEventListener("DOMContentLoaded", saveOpenTime);
    
    const updateHeartsDisplay = () => {
      const heartsElem = document.getElementById("heartsContainer");
      heartsElem.textContent = unlimitedLives ? "" : "‚ù§Ô∏è".repeat(hearts);
    };
      const updateTimer = () => {
        const timerElem = document.getElementById("timerContainer");
        
        // Berechne den durchschnittlichen Bearbeitungszeit (in ms), Standard: 1000 ms falls noch keine Werte vorhanden
        let avgResponse = responseTimes.length > 0
          ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
          : 1000;
        
        // Berechne die Fehlerquote: Anteil der Fehlversuche
        let errorRate = totalAttempts > 0
          ? (totalAttempts - correctAnswers) / totalAttempts
          : 0;
        
        // Voraussichtliche Zeit (in Sekunden) = Anzahl verbleibender Noten * (durchschnittliche Bearbeitungszeit in s) * (1 + Fehlerquote)
        let predictedTimeSec = sessionCounter * (avgResponse / 1000) * (1 + errorRate);
        
        // Formatiere in mm:ss
        let minutes = Math.floor(predictedTimeSec / 60);
        let seconds = Math.floor(predictedTimeSec % 60);
        let timeStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
        
        timerElem.textContent = `${sessionCounter} Noten, vsl. ${timeStr} min`;
      };
      
      function updatePauseTiles() {
        const container = document.getElementById("pauseTiles");
        if (!container) return;

        // Berechne App‚ÄëZeit
        const totalTimeSec = Math.floor((Date.now() - appStartTime) / 1000);
        const h = Math.floor(totalTimeSec / 3600);
        const m = Math.floor((totalTimeSec % 3600) / 60);
        const s = totalTimeSec % 60;
        const appTime = (h > 0 ? (h + "h ") : "") + m + "m " + s + "s";

        // Berechne Prozent richtiger Noten
        const correctPercent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;

        // Durchschnittliche Bearbeitungszeit (in Sekunden)
        const avgTimeSec = responseTimes.length
          ? (responseTimes.reduce((acc, t) => acc + t, 0) / responseTimes.length / 1000).toFixed(2)
          : "N/A";

        container.innerHTML = `
          <div class="tile">
            <div class="tileIcon">‚è∞</div>
            <div class="tileTitle">App‚ÄëZeit</div>
            <div class="tileValue">${appTime}</div>
          </div>
          <div class="tile">
            <div class="tileIcon">‚úÖ</div>
            <div class="tileTitle">Richtige Noten</div>
            <div class="tileValue">${correctPercent}%</div>
          </div>
          <div class="tile">
            <div class="tileTitle">Wann √ºbst du am meisten?</div>
            <div class="barChart">
               ${generateBarChartHTML()}
            </div>
          </div>
          ${ generateLearningQualityGraphTile() }
          <div class="tile">
            <div class="tileTitle">Session</div>
            <div class="tileValue">${sessionCount}</div>
          </div>
          ${generateTrophyTile()}
        `;
      }
      
      function getLastThreeSessions() {
        // Beispiel: Session-Daten als Array von Objekten mit responseTimes (ms), errorCount, totalAttempts und sessionTime (in sec)
        const sessions = JSON.parse(localStorage.getItem("sessionData") || "[]");
        return sessions.slice(-3);
      }

      function calculateQuality(session) {
        // Durchschnittliche Antwortzeit in Sekunden (niedriger ist besser)
        const avgResponse = session.responseTimes.length
          ? session.responseTimes.reduce((a, b) => a + b, 0) / session.responseTimes.length / 1000
          : 0;
        // Fehlerquote (niedriger ist besser)
        const errorRate = session.totalAttempts ? (session.errorCount / session.totalAttempts) : 0;
        // Die Session-Dauer in Sekunden ‚Äì l√§ngere Sessions k√∂nnen auf mehr Engagement hinweisen
        const learningTime = session.sessionTime || 0;
        // Beispielhafte Gewichtung: Wir wollen, dass niedrigere Antwortzeiten und Fehlerquoten zu h√∂heren Qualit√§tswerten f√ºhren.
        // Hier eine einfache Rechnung, die in den meisten F√§llen einen Wert zwischen 0 und 100 liefert.
        let quality = 100 - (avgResponse * 10) - (errorRate * 100) + (learningTime / 60);
        return Math.max(0, Math.min(quality, 100));
      }
      
      function drawLearningQualityGraph(canvas, sessions) {
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // Berechne die Qualit√§tswerte
        const qualities = sessions.map(calculateQuality);

        // Wir erwarten Werte zwischen 0 und 100, also skalieren wir den y-Wert entsprechend.
        ctx.beginPath();
        for (let i = 0; i < qualities.length; i++) {
          const x = (i / (qualities.length - 1)) * width;
          // H√∂here Qualit√§t => niedrigere y-Koordinate (oben ist 0)
          const y = height - (qualities[i] / 100 * height);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          // Optional: Zeichne einen kleinen Kreis als Punkt
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fillStyle = "#007aff";
          ctx.fill();
          ctx.beginPath(); // Beginne neuen Pfad f√ºr die Linie
          if(i === 0) {
            ctx.moveTo(x,y);
          }
        }
        ctx.strokeStyle = "#007aff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      

      function generateTrophyTile() {
        const tile = document.createElement("div");
        tile.className = "tile span-2";
        tile.style.display = "flex";
        tile.style.flexDirection = "row";
        tile.style.alignItems = "center";
        tile.style.justifyContent = "space-between";
        const title = document.createElement("div");
        title.className = "tileTitle";
        title.style.flex = "1";
        title.style.display = "flex";
        title.style.flexDirection = "column";
        title.style.justifyContent = "center";
        title.style.alignItems = "center";
        title.innerHTML = "üèÜ Troph√§en                 <span id='resetTrophiesBtn' style='cursor:pointer;' title='Reset'>üóëÔ∏è</span>";
        tile.appendChild(title);

        const trophyGrid = document.createElement("div");
        const wrapper = document.createElement("div");
        wrapper.style.display = "flex";
        wrapper.style.flexDirection = "column";
        wrapper.style.alignItems = "flex-start";
        wrapper.style.flex = "2";
        trophyGrid.style.display = "grid";
        trophyGrid.style.gridTemplateColumns = "repeat(10, 1fr)";
        trophyGrid.style.gridGap = "5px";
        trophyGrid.style.fontSize = "2em";
    trophyGrid.style.marginTop = "10px";
    
    const descriptionBox = document.createElement("div");
    descriptionBox.id = "trophyDescriptionBox";
    descriptionBox.style.marginTop = "10px";
    descriptionBox.style.fontSize = "1em";
    descriptionBox.style.color = "#333";
    descriptionBox.style.minHeight = "2em";
    descriptionBox.style.marginLeft = "20px";
    descriptionBox.style.textAlign = "left";
    descriptionBox.style.maxWidth = "200px";

        const allTrophies = [
          "üê¢", "üêå", "üö∂‚Äç‚ôÇÔ∏è", "üèÉ", "‚ö°",     // Speed
          "üéº", "üéπ", "üé∫", "ü™ï", "ü™ó",     // Clef Accuracy
          "üå±", "üåø", "üåª", "üå≤", "üéÑ", "üî•", "üöÄ", "ü™ê", "üåû", "üëë", // Streak
          "üîÄ", "üåÄ", "üîÅ", "‚è©", "‚öôÔ∏è",     // Mode switching
          "üìè", "üìê", "üß≠", "üéØ", "üèÅ"      // Metronome precision
        ];

        const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
        const justUnlocked = [];

        allTrophies.forEach((emoji, index) => {
          const span = document.createElement("span");
          span.textContent = emoji;
          span.title = getTrophyDescription(index);
          span.style.cursor = "pointer";
          span.addEventListener("click", () => {
            descriptionBox.textContent = getTrophyDescription(index);
          });
          if (unlockedTrophies.includes(index)) {
            span.style.opacity = "1";
          } else {
            const shouldUnlock = checkTrophyCondition(index);
            if (shouldUnlock) {
              unlockedTrophies.push(index);
              justUnlocked.push(span);
              span.style.opacity = "0";
              setTimeout(() => {
                span.style.transition = "opacity 1s";
                span.style.opacity = "1";
                confetti({ particleCount: 50, spread: 50, origin: { x: 0.5, y: 0.5 } });
              }, 100);
            } else {
              span.style.opacity = "0.5";
            }
          }
          trophyGrid.appendChild(span);
        });

        localStorage.setItem("unlockedTrophies", JSON.stringify(unlockedTrophies));
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
          unlockedTrophies.forEach(id => {
            window.webkit.messageHandlers.gameCenter.postMessage({
              type: "achievement",
              value: "trophy_" + id
            });
          });
        }
        wrapper.appendChild(trophyGrid);
        wrapper.appendChild(descriptionBox);
        tile.appendChild(wrapper);
        setTimeout(() => {
          const resetBtn = document.getElementById("resetTrophiesBtn");
          if (resetBtn) {
            resetBtn.addEventListener("click", () => {
              localStorage.removeItem("unlockedTrophies");
              updatePauseTiles();
            });
          }
        }, 0);
        return tile.outerHTML;
      }

      function checkTrophyCondition(index) {
        const avg = responseTimes.length ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
        if (index === 0) return avg < 1500;
        if (index === 1) return avg < 1000;
        if (index === 2) return avg < 900;
        if (index === 3) return avg < 800;
        if (index === 4) return avg < 400;

        if (index >= 5 && index <= 9) {
          const ranges = ["C", "D", "F", "G", "MC"];
          const range = ranges[index - 5];
          return rangeNotes[range].every(note => !errorNotes.some(e => e.note === note));
        }

        const streak = Number(localStorage.getItem("streak") || 0);
        const thresholds = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
        if (index >= 10 && index <= 19) return streak >= thresholds[index - 10];

        if (index >= 20 && index <= 24) {
          const avgSwitch = responseTimes.length > 10 ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
          return avgSwitch < (1500 - (index - 20) * 200);
        }

        if (index >= 25 && index <= 29) {
          if (!metronomeOn) return false;
          const maxDev = Math.max(...responseTimes.map(t => Math.abs(t - metronomeInterval)));
          const devPercent = maxDev / metronomeInterval;
          const limits = [0.3, 0.2, 0.15, 0.1, 0.05];
          return devPercent < limits[index - 25];
        }

        return false;
      }
function getTrophyDescription(index) {
  const descriptions = [
    "Durchschnittliche Reaktionszeit unter 1,5 Sekunden",
    "Durchschnittliche Reaktionszeit unter 1 Sekunde",
    "Durchschnittliche Reaktionszeit unter 0,9 Sekunden",
    "Durchschnittliche Reaktionszeit unter 0,8 Sekunden",
    "Durchschnittliche Reaktionszeit unter 0,4 Sekunden",
    "Fehlerfrei in der C-Lage",
    "Fehlerfrei in der D-Lage",
    "Fehlerfrei in der F-Lage",
    "Fehlerfrei in der G-Lage",
    "Fehlerfrei in der MC-Lage",
    "Streak von mindestens 2 Tagen",
    "Streak von mindestens 3 Tagen",
    "Streak von mindestens 5 Tagen",
    "Streak von mindestens 8 Tagen",
    "Streak von mindestens 13 Tagen",
    "Streak von mindestens 21 Tagen",
    "Streak von mindestens 34 Tagen",
    "Streak von mindestens 55 Tagen",
    "Streak von mindestens 89 Tagen",
    "Streak von mindestens 144 Tagen",
    "Schneller Lagenwechsel (Stufe 1)",
    "Schneller Lagenwechsel (Stufe 2)",
    "Schneller Lagenwechsel (Stufe 3)",
    "Schneller Lagenwechsel (Stufe 4)",
    "Schneller Lagenwechsel (Stufe 5)",
    "Taktgef√ºhl: Abweichung <30%",
    "Taktgef√ºhl: Abweichung <20%",
    "Taktgef√ºhl: Abweichung <15%",
    "Taktgef√ºhl: Abweichung <10%",
    "Taktgef√ºhl: Abweichung <5%"
  ];
  return descriptions[index] || "";
}
                                            
function generateBarChartHTML() {
  // Standardwerte: Jeder Tag wird initial auf 0 gesetzt.
  const dayCounts = { Mo: 0, Di: 0, Mi: 0, Do: 0, Fr: 0, Sa: 0, So: 0 };
  
  // Z√§hle √ñffnungszeiten
  const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
  openTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  // Z√§hle Session-Zeitpunkte
  const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
  sessionTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  const days = ["Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"];
  const maxVal = Math.max(...Object.values(dayCounts), 1);
  
  // Erstelle Container als Flex-Layout f√ºr das Balkendiagramm
  const container = document.createElement("div");
  container.className = "bar-chart-container";
  
  days.forEach(day => {
    const val = dayCounts[day] || 0;
    const barItem = document.createElement("div");
    barItem.className = "bar-item";
    
    const bar = document.createElement("div");
    bar.className = "bar";
    const height = Math.round((val / maxVal) * 100);
    bar.style.height = `${height}px`;
    
    const label = document.createElement("div");
    label.className = "bar-label";
    label.textContent = day;
    
    barItem.appendChild(bar);
    barItem.appendChild(label);
    container.appendChild(barItem);
  });
  
  return container.outerHTML;
}
      
      


function calculateAdaptiveBreakTime(responseTimes, hitRate) {
  // Berechne die durchschnittliche Antwortzeit in Millisekunden
  let avgResponse = responseTimes.length > 0
    ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
    : 1000;
  // Verwende hitRate (Erfolgsquote), um die Pausendauer anzupassen:
  // Eine niedrigere Erfolgsquote (mehr Fehler) f√ºhrt zu l√§ngeren Pausen.
  return avgResponse * (1 + (1 - hitRate));
}
      
    const startPauseCountdown = () => {
  logSessionStart(); // Neuen Session-Zeitstempel speichern
  if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
    window.webkit.messageHandlers.gameCenter.postMessage({
      type: "highscore",
      value: {
        accuracy: Math.round((correctAnswers / totalAttempts) * 100),
        duration: Math.floor((Date.now() - appStartTime) / 1000),
        mode: randomMode ? "random" : selectedMode
      }
    });
  }
  const quote = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
  const speed = responseTimes.length > 0
    ? Math.round(responseTimes.reduce((a, b) => a + b) / responseTimes.length)
    : 0;
  if (!userID) {
    console.error("Keine userID gesetzt! Abbruch.");
    return;
  }
  const timerElem = document.getElementById("timerContainer");
  const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  if (
    isiOS &&
    timerElem &&
    window.webkit &&
    window.webkit.messageHandlers &&
    window.webkit.messageHandlers.gameCenter
  ) {
    timerElem.textContent = "Speichere Daten in GameCenter...";
    setTimeout(() => {
      startRealPauseCountdown(); // Startet den eigentlichen Countdown
    }, 2000);
    return;
  }
  
      stopMetronome();
      sessionPaused = true;
      sessionCount++;
      const hitRate = totalAttempts > 0 ? (correctAnswers / totalAttempts) : 1;
      pauseRemaining = Math.floor(calculateAdaptiveBreakTime(responseTimes, hitRate) * 2 + 300);
      pauseDuration = pauseRemaining;

      const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
      const previousTrophies = JSON.parse(sessionStorage.getItem("previousUnlockedTrophies") || "[]");
      
      const justUnlocked = unlockedTrophies.filter(index => !previousTrophies.includes(index));
      const justLost = previousTrophies.filter(index => !unlockedTrophies.includes(index));
      
      sessionStorage.setItem("justUnlockedTrophies", JSON.stringify(justUnlocked));
      sessionStorage.setItem("justLostTrophies", JSON.stringify(justLost));
      sessionStorage.setItem("previousUnlockedTrophies", JSON.stringify(unlockedTrophies));
      
      const pauseOverlay = document.getElementById("pauseOverlay");
      pauseOverlay.innerHTML = `
          <div id="pauseInfo">
            <div id="pauseHeader">SESSION PAUSIERT</div>
            <div id="pauseProgressContainer">
              <div id="pauseProgress"></div>
              <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
            </div>
          </div>
          <div id="pauseTiles"></div>
        `;
      document.getElementById("mainContent").style.display = "none";
      document.getElementById("timerContainer").style.display = "none";
      document.getElementById("settingsPanel").style.display = "none";
      pauseOverlay.style.display = "flex";
      confetti({
        particleCount: 150,
        spread: 70,
        origin: { x: 0.5, y: 0.5 }
      });
      updatePauseProgress();
      updatePauseTiles();
      const msgInterval = setInterval(() => { updatePauseTiles(); }, 3000);
      pauseInterval = setInterval(() => {
        pauseRemaining--;
        updatePauseProgress();
        if (pauseRemaining <= 0) {
          clearInterval(pauseInterval);
          clearInterval(msgInterval);
          endPause();
        }
      }, 1000);
    };
      
      // Erstelle ein Audio-Objekt f√ºr den Gong
      const gongSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/gong-2-232435.mp3");
      
      // In deiner Funktion, die das Pausenfenster beendet, rufe den Sound ab:
      const endPause = () => {
        document.getElementById("pauseOverlay").style.display = "none";
        document.getElementById("mainContent").style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        sessionPaused = false;
        // Setze den Sound zur√ºck und spiele ihn ab
        gongSound.currentTime = 0;
        gongSound.play();
        resetGame();
      };
    let gameOver = false;
    const endGame = () => {
      gameOver = true;
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      gameOverOverlay.textContent = "Game Over!";
      gameOverOverlay.style.display = "block";
      if (!scoreRecorded) recordScore();
      setTimeout(resetGame, 5000);
    };
    const recordScore = () => {
      if (totalAttempts <= 0) return;
      const durationMs = Date.now() - appStartTime;
      const secondsTotal = Math.floor(durationMs / 1000);
      const minutes = Math.floor(secondsTotal / 60);
      const seconds = secondsTotal % 60;
      const durationStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
      const accuracy = Math.round((correctAnswers / totalAttempts) * 100);
      const now = new Date();
      let dd = now.getDate();
      let mm = now.getMonth() + 1;
      dd = dd < 10 ? "0" + dd : dd;
      mm = mm < 10 ? "0" + mm : mm;
      const dateStr = dd + "." + mm;
      const scoreObj = { date: dateStr, accuracy: accuracy, duration: durationStr, seconds: secondsTotal, mode: randomMode ? "random" : selectedMode };
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      highScores.push(scoreObj);
      highScores.sort((a, b) => (b.accuracy !== a.accuracy ? b.accuracy - a.accuracy : a.seconds - b.seconds));
      highScores = highScores.slice(0, 5);
      localStorage.setItem("highScores", JSON.stringify(highScores));
      scoreRecorded = true;
    };
    const updateScoreboard = () => {
      const allScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const filtered = allScores.filter(score => score.mode === (randomMode ? "random" : selectedMode));
      let html = "HIGHSCORES (" + (randomMode ? "random" : selectedMode) + ")\n";
      filtered.forEach((score, index) => {
        html += (index + 1) + ". " + score.date + " \t " + score.accuracy + "% " + score.duration + "\n";
      });
      document.getElementById("scoreboardOverlay").textContent = html;
    };
    const toggleScoreboard = () => {
      const overlay = document.getElementById("scoreboardOverlay");
      overlay.classList.toggle("hidden");
      if (!overlay.classList.contains("hidden")) updateScoreboard();
    };
    const autoSelectMode = () => {
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const leftScores = highScores.filter(score => score.mode === "left");
      const rightScores = highScores.filter(score => score.mode === "right");
      const bestLeft = leftScores.length ? Math.max(...leftScores.map(s => s.accuracy)) : 0;
      const bestRight = rightScores.length ? Math.max(...rightScores.map(s => s.accuracy)) : 0;
      if (bestLeft < bestRight) {
        selectedMode = "left";
        currentHandIndex = 0;
      } else {
        selectedMode = "left";
        currentHandIndex = 0;
      }
      const handToggle = document.getElementById("handToggle");
      if (handToggle) {
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      }
    };
    const cycleRange = () => {
      window.customModeSettings = null;
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
      updateHeartsDisplay();
    };
    const toggleDarkMode = () => {
      document.body.classList.toggle("dark-mode");
    };
    // Passive Listener f√ºr Touch-Events in setupFadeOnHover
    const setupFadeOnHover = (element) => {
      element.addEventListener("mouseenter", () => element.classList.remove("faded"));
      element.addEventListener("mouseleave", () => element.classList.add("faded"));
      element.addEventListener("touchstart", () => element.classList.remove("faded"), {passive: true});
      element.addEventListener("touchend", () => element.classList.add("faded"), {passive: true});
    };
    let redrawQueued = false;
    const queueRedraw = () => {
      if (!redrawQueued) {
        redrawQueued = true;
        requestAnimationFrame(() => {
          drawSeries();
          redrawQueued = false;
        });
      }
    };
    /* Animation (Hintergrund-Kreise) */
    let blobsEnabled = true;
    let circles = [];
    const gradients = {
      "green": ["rgba(0,255,0,1)", "rgba(0,255,0,0.3)", "rgba(255,255,255,0)"],
      "blue": ["rgba(0,0,255,1)", "rgba(0,0,255,0.3)", "rgba(255,255,255,0)"],
      "pink": ["rgba(255,105,180,1)", "rgba(255,105,180,0.3)", "rgba(255,255,255,0)"],
      "yellow": ["rgba(255,255,0,1)", "rgba(255,255,0,0.3)", "rgba(255,255,255,0)"],
      "red": ["rgba(255,0,0,1)", "rgba(255,0,0,0.3)", "rgba(255,255,255,0)"],
      "violet": ["rgba(238,130,238,1)", "rgba(238,130,238,0.3)", "rgba(255,255,255,0)"],
      "gray": ["rgba(128,128,128,1)", "rgba(128,128,128,0.3)", "rgba(255,255,255,0)"],
      "black": ["rgba(0,0,0,1)", "rgba(0,0,0,0.3)", "rgba(255,255,255,0)"]
    };
    const positiveColors = ["green", "blue", "pink", "yellow"];
    const negativeColors = ["orange", "violet", "crimson"];
    function addCircle(type) {
      if (!blobsEnabled) return;
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = type === "positive" ? positiveColors : negativeColors;
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
    }
    /* Intro-Animation */
    function spawnIntroBlobs() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const positions = [
        { x: cw - 500, y: 100 },
        { x: cw - 30, y: ch - 30 },
        { x: 50, y: ch / 2 }
      ];
      const colors = ["yellow", "pink", "blue"];
      positions.forEach((pos, index) => {
        const targetRadius = Math.random() * 1000 + 1000;
        const duration = 5000;
        circles.push({
          x: pos.x,
          y: pos.y,
          initialRadius: targetRadius,
          radius: targetRadius,
          color: colors[index % colors.length],
          creationTime: Date.now(),
          duration: duration
        });
      });
    }
    function animateCircles() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const now = Date.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      circles = circles.filter(circle => {
        const t = now - circle.creationTime;
        if (t >= circle.duration) return false;
        let opacity = 0;
        if (t < 500) { opacity = t / 500; }
        else if (t < 1500) { opacity = 1; }
        else { opacity = (circle.duration - t) / 500; }
        let currentRadius = circle.radius;
        const gradColors = gradients[circle.color] || [circle.color, circle.color, "rgba(255,255,255,0)"];
        const grad = ctx.createRadialGradient(circle.x, circle.y, 0, circle.x, circle.y, currentRadius);
        grad.addColorStop(0, gradColors[0]);
        grad.addColorStop(0.7, gradColors[1]);
        grad.addColorStop(1, gradColors[2]);
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, currentRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 1;
        return true;
      });
      requestAnimationFrame(animateCircles);
    }
    function resetInactivityTimer() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(spawnInactivityBlob, 180000);
    }
    function spawnInactivityBlob() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = ["green", "blue", "pink", "yellow"];
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
      resetInactivityTimer();
    }
    document.addEventListener("DOMContentLoaded", () => {
      let canvas = document.getElementById("animationCanvas");
      // --- Apply saved notation position from localStorage ---
      const savedTransform = localStorage.getItem("notationTransform");
      if (savedTransform) {
        const notation = document.getElementById("notation");
        if (notation) {
          notation.style.position = "fixed";
          notation.style.top = "50%";
          notation.style.left = "50%";
          notation.style.transform = savedTransform;
        }
      }
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = "animationCanvas";
        document.body.appendChild(canvas);
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      animateCircles();
      resetInactivityTimer();
      const storedName = localStorage.getItem("userName");
      const welcomeMessage = document.getElementById("welcomeMessage");
      const hour = new Date().getHours();
      let greeting;
      if (hour >= 6 && hour < 12) {
        greeting = "Guten Morgen";
      } else if (hour >= 12 && hour < 17) {
        greeting = "Guten Tag";
      } else {
        greeting = "Guten Abend";
      }

      if (storedName !== null) {
        welcomeMessage.innerHTML = `${greeting}, ${storedName || ""}<br> Willkommen zur√ºck.<br>`;
        welcomeMessage.style.cursor = "pointer";
        welcomeMessage.addEventListener("click", () => {
          const storedName = localStorage.getItem("userName");
          if (storedName !== null) {
            const nameOverlay = document.createElement("div");
            nameOverlay.id = "nameOverlay";
            nameOverlay.style.position = "fixed";
            nameOverlay.style.top = "0";
            nameOverlay.style.left = "0";
            nameOverlay.style.width = "100%";
            nameOverlay.style.height = "100%";
            nameOverlay.style.backgroundColor = "rgba(255,255,255,0.95)";
            nameOverlay.style.display = "flex";
            nameOverlay.style.justifyContent = "center";
            nameOverlay.style.alignItems = "center";
            nameOverlay.style.zIndex = "9999";
            nameOverlay.style.pointerEvents = "auto";

            const modal = document.createElement("div");
            modal.style.background = "#fff";
            modal.style.padding = "20px";
            modal.style.border = "2px solid #000";
            modal.style.borderRadius = "10px";
            modal.style.textAlign = "center";

            const label = document.createElement("label");
            label.textContent = "Wie hei√üt du?";
            label.style.fontSize = "1.5em";

            const input = document.createElement("input");
            input.type = "text";
            input.value = storedName;
            input.style.display = "block";
            input.style.margin = "15px auto";
            input.style.fontSize = "1.2em";
            input.style.padding = "5px";
            input.style.pointerEvents = "auto";
            input.tabIndex = 0;
            // Prevent typing in name input from affecting the game
            input.addEventListener('keydown', e => e.stopPropagation());
            input.addEventListener('keyup',   e => e.stopPropagation());
            input.addEventListener('keypress',e => e.stopPropagation());
            input.addEventListener('input',   e => e.stopPropagation());

            const button = document.createElement("button");
            button.textContent = "Speichern";
            button.style.padding = "10px 20px";
            button.style.border = "2px solid #000";
            button.style.borderRadius = "5px";
            button.style.backgroundColor = "#fff";
            button.style.color = "#000";
            button.style.cursor = "pointer";

            const skip = document.createElement("button");
            skip.textContent = "Keinen Namen anzeigen";
            skip.style.padding = "10px 20px";
            skip.style.border = "2px solid #000";
            skip.style.borderRadius = "5px";
            skip.style.backgroundColor = "#fff";
            skip.style.color = "#000";
            skip.style.cursor = "pointer";

            button.addEventListener("click", () => {
              localStorage.setItem("userName", input.value.trim());
              document.body.removeChild(nameOverlay);
              location.reload();
            });

            skip.addEventListener("click", () => {
              localStorage.setItem("userName", "");
              document.body.removeChild(nameOverlay);
              location.reload();
            });

            modal.appendChild(label);
            modal.appendChild(input);
            modal.appendChild(button);
            modal.appendChild(skip);
            nameOverlay.appendChild(modal);
            document.body.appendChild(nameOverlay);
          }
        });
        welcomeMessage.style.fontSize = "2em";
        setTimeout(proceedToMainScreen, 5000);
      } else {
        document.getElementById("mainContent").style.opacity = "0";
        document.getElementById("timerContainer").style.opacity = "0";
        document.getElementById("settingsPanel").style.opacity = "0";

        const nameOverlay = document.createElement("div");
        nameOverlay.id = "nameOverlay";
        nameOverlay.style.position = "fixed";
        nameOverlay.style.top = "0";
        nameOverlay.style.left = "0";
        nameOverlay.style.width = "100%";
        nameOverlay.style.height = "100%";
        nameOverlay.style.backgroundColor = "rgba(255,255,255,0.95)";
        nameOverlay.style.display = "flex";
        nameOverlay.style.justifyContent = "center";
        nameOverlay.style.alignItems = "center";
        nameOverlay.style.zIndex = "9999";
        nameOverlay.style.pointerEvents = "auto";

        const modal = document.createElement("div");
        modal.style.background = "#fff";
        modal.style.padding = "20px";
        modal.style.border = "2px solid #000";
        modal.style.borderRadius = "10px";
        modal.style.textAlign = "center";

        const label = document.createElement("label");
        label.textContent = "Wie hei√üt du?";
        label.style.fontSize = "1.5em";

        const input = document.createElement("input");
        input.type = "text";
        input.style.display = "block";
        input.style.margin = "15px auto";
        input.style.fontSize = "1.2em";
        input.style.padding = "5px";
        input.style.pointerEvents = "auto";
        input.tabIndex = 0;
        // Prevent typing in name input from affecting the game
        input.addEventListener('keydown', e => e.stopPropagation());
        input.addEventListener('keyup',   e => e.stopPropagation());
        input.addEventListener('keypress',e => e.stopPropagation());
        input.addEventListener('input',   e => e.stopPropagation());

        const button = document.createElement("button");
        button.textContent = "Weiter";
        button.style.fontSize = "1em";
        button.style.marginRight = "10px";
        button.style.padding = "10px 20px";
        button.style.border = "none";
        button.style.borderRadius = "5px";
        button.style.backgroundColor = "#fff";
        button.style.color = "#000";
        button.style.border = "2px solid #000";
        button.disabled = true;
        button.style.opacity = "0.8";
        
        input.addEventListener("input", () => {
          const hasText = input.value.trim().length > 0;
          button.disabled = !hasText;
          button.style.opacity = hasText ? "1" : "0.8";
        });

        const skip = document.createElement("button");
        skip.textContent = "Keinen Namen angeben";
        skip.style.fontSize = "1em";
        skip.style.padding = "10px 20px";
        skip.style.border = "none";
        skip.style.borderRadius = "5px";
        skip.style.backgroundColor = "#fff";
        skip.style.color = "#000";
        skip.style.border = "2px solid #000";

        button.addEventListener("click", () => {
          localStorage.setItem("userName", input.value.trim());
          document.body.removeChild(nameOverlay);
          proceedToMainScreen();
          document.getElementById("mainContent").style.opacity = "1";
          document.getElementById("timerContainer").style.opacity = "1";
          document.getElementById("settingsPanel").style.opacity = "1";
        });

        skip.addEventListener("click", () => {
          localStorage.setItem("userName", "");
          document.body.removeChild(nameOverlay);
          proceedToMainScreen();
          document.getElementById("mainContent").style.opacity = "1";
          document.getElementById("timerContainer").style.opacity = "1";
          document.getElementById("settingsPanel").style.opacity = "1";
        });

        modal.appendChild(label);
        modal.appendChild(input);
        modal.appendChild(button);
        modal.appendChild(skip);
        nameOverlay.appendChild(modal);
        document.body.appendChild(nameOverlay);
      }
      
      const settingsPanel = document.getElementById("settingsPanel");
      // Handtoggle
      const handToggle = document.createElement("span");
      handToggle.id = "handToggle";
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      settingsPanel.appendChild(handToggle);
      handToggle.addEventListener("click", () => {
        if (!randomMode) {
          currentHandIndex = (currentHandIndex + 1) % handOptions.length;
          selectedMode = handOptions[currentHandIndex].mode;
          handToggle.textContent = handOptions[currentHandIndex].symbol;
          handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
          window.customModeSettings = null;
          generateSeries();
        }
      });
      // Randomtoggle
      const randomToggle = document.createElement("span");
      randomToggle.id = "randomToggle";
      randomToggle.textContent = "üêá";
      settingsPanel.appendChild(randomToggle);
      randomToggle.addEventListener("click", () => {
        randomMode = !randomMode;
        randomToggle.style.opacity = randomMode ? "1" : "0.5";
        generateSeries();
      });
      

      
      function showHomework() {
        let modal = document.getElementById("homeworkModal");
        if (!modal) {
          modal = document.createElement("div");
          modal.id = "homeworkModal";
          Object.assign(modal.style, {
            position: "fixed", top:"35%", right:"90px", width:"300px",
            background:"white", border:"2px solid black", borderRadius:"10px",
            padding:"20px", zIndex:"150"
          });
          document.body.appendChild(modal);
        }
        // Dynamisch Titel/Beschreibung w√§hlen
        // Automatischer Scan bei leerer Hausaufgabe
        if (!homeworkData) {
          openCameraScan().then(code => {
            if (code && code.data) {
              try {
                homeworkData = JSON.parse(code.data);
                localStorage.setItem("homeworkData", JSON.stringify(homeworkData));
              } catch {
                alert("Ung√ºltiger QR-Code");
              }
            }
            showHomework();
          }).catch(() => {
            // Scan abgebrochen oder Fehler ‚Äì trotzdem das Modal anzeigen
            showHomework();
          });
          return;
        }
        const title = homeworkData?.HA || "Keine HA";
        const desc  = homeworkData?.Beschreibung || "";
        modal.innerHTML = `
          <h2>Hausaufgabe</h2>
          <p><strong>Titel:</strong> ${title}</p>
          <p><strong>Beschreibung:</strong> ${desc}</p>
          <button id="hwReceive">HA erhalten</button>
          <button id="hwSend">HA senden</button>
        `;
        // Button-Listener
        document.getElementById("hwReceive").addEventListener("click", () => {
          openCameraScan().then(code => {
            if (code && code.data) {
              try {
                homeworkData = JSON.parse(code.data);
                localStorage.setItem("homeworkData", JSON.stringify(homeworkData));
              } catch {
                alert("Ung√ºltiger QR-Code");
              }
            }
            showHomework();
          });
        });
      // Overlay Camera Scan: openCameraScan implementation
      function openCameraScan() {
        return new Promise((resolve, reject) => {
          // Create overlay
          let scanOverlay = document.createElement("div");
          Object.assign(scanOverlay.style, {
            position: "fixed", top:"20%", left:"10%", width:"80%", height:"60%",
            background:"rgba(0,0,0,0.8)", display:"flex", alignItems:"center", justifyContent:"center", zIndex:"2000"
          });
          scanOverlay.id = "scanOverlay";
          // Create video element
          let video = document.createElement("video");
          video.setAttribute("autoplay", true);
          video.setAttribute("playsinline", true);
          video.style.width = "100%";
          video.style.height = "100%";
          video.style.objectFit = "cover";
          // Add close button
          let closeBtn = document.createElement("button");
          closeBtn.textContent = "Abbrechen";
          closeBtn.style.position = "absolute";
          closeBtn.style.top = "10px";
          closeBtn.style.right = "10px";
          closeBtn.style.zIndex = "2100";
          closeBtn.style.padding = "8px 16px";
          closeBtn.style.background = "white";
          closeBtn.style.border = "1px solid #000";
          closeBtn.style.borderRadius = "6px";
          closeBtn.style.cursor = "pointer";
          closeBtn.addEventListener("click", () => {
            if (video.srcObject) {
              video.srcObject.getTracks().forEach(track => track.stop());
            }
            document.body.removeChild(scanOverlay);
            reject(new Error("Scan cancelled"));
          });
          scanOverlay.appendChild(video);
          scanOverlay.appendChild(closeBtn);
          document.body.appendChild(scanOverlay);
          // Access camera
          navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(stream => {
            video.srcObject = stream;
            // Use a QR scanner library or implement simple scanning
            // For now, simulate scan after 3 seconds
            // In real code, integrate a QR code library such as jsQR or html5-qrcode
            setTimeout(() => {
              // Stop camera
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(scanOverlay);
              // Simulate a QR result object
              resolve({ data: '{"HA":"Beispiel","Beschreibung":"Test"}' });
            }, 3000);
          }).catch(err => {
            document.body.removeChild(scanOverlay);
            alert("Kamera konnte nicht ge√∂ffnet werden: " + err);
            reject(err);
          });
        });
      }
        document.getElementById("hwSend").addEventListener("click", () => {
          modal.innerHTML = `
            <h2>Hausaufgabe erstellen</h2>
            <label>Titel:<br><input id="newHA" value="${homeworkData?.HA||""}"></label><br>
            <label>Beschreibung:<br><textarea id="newDesc">${homeworkData?.Beschreibung||""}</textarea></label><br>
            <button id="generateQR">QR-Code erstellen</button>
          `;
          // Prevent HA input from affecting the notation/game
          const haInput = document.getElementById("newHA");
          const descInput = document.getElementById("newDesc");
          [haInput, descInput].forEach(el => {
            el.addEventListener('keydown', e => e.stopPropagation());
            el.addEventListener('keyup',   e => e.stopPropagation());
            el.addEventListener('keypress',e => e.stopPropagation());
            el.addEventListener('input',   e => e.stopPropagation());
          });
          document.getElementById("generateQR").addEventListener("click", () => {
            const obj = { HA: document.getElementById("newHA").value, Beschreibung: document.getElementById("newDesc").value };
            modal.innerHTML = `<div id="qrContainer"></div>`;
            new QRCode(document.getElementById("qrContainer"), { text: JSON.stringify(obj), width:200, height:200 });
            localStorage.setItem("homeworkData", JSON.stringify(obj));
          });
        });
      }

      // Called by Swift after scanning QR code
      function handleIncomingHomework() {
        console.log("üè† Received homeworkData from Swift:", window.homeworkData);
        // Speichere es noch einmal ab ‚Äì so verh√§lt sich auch der Fallback-Mechanismus
        localStorage.setItem("homeworkData", JSON.stringify(window.homeworkData));
        // √ñffne oder aktualisiere das Modal
        showHomework();
      }

      // üßôüèº Wizard-Modus Toggle im Karussell
      const wizardToggle = document.createElement("span");
      wizardToggle.id = "wizardToggle";
      wizardToggle.textContent = "üßôüèº";
      wizardToggle.style.cursor = "pointer";
      wizardToggle.style.opacity = "1";
      settingsPanel.appendChild(wizardToggle);
      let wizardMode = true;
      // --- resetArticulationMode helper ---
      function resetArticulationMode() {
        articulationMode = null;
        const clefTitle = document.getElementById("clefTitle");
        if (clefTitle) clefTitle.textContent = currentRange + "-Lage";
        const notation = document.getElementById("notation");
        if (notation) notation.style.display = "block";
      }
      wizardToggle.addEventListener("click", () => {
        resetArticulationMode();
        wizardMode = !wizardMode;
        wizardToggle.style.opacity = wizardMode ? "1" : "0.5";
      });
      
      const staccatoToggle = document.createElement("span");
      staccatoToggle.id = "staccatoToggle";
      staccatoToggle.textContent = "ü•Å";
      staccatoToggle.style.cursor = "pointer";
      staccatoToggle.style.opacity = "0.5";
      settingsPanel.appendChild(staccatoToggle);

      let staccatoModeActive = false;

      staccatoToggle.addEventListener("click", () => {
        staccatoModeActive = !staccatoModeActive;
        articulationMode = staccatoModeActive ? "staccato" : null;
        staccatoToggle.style.opacity = staccatoModeActive ? "1" : "0.5";
        const clefTitle = document.getElementById("clefTitle");
        if (clefTitle) clefTitle.textContent = currentRange + "-Lage";
        const notation = document.getElementById("notation");
        if (notation) notation.style.display = staccatoModeActive ? "none" : "block";
      });
      
      const blobToggle = document.createElement("span");
      blobToggle.id = "blobToggle";
      blobToggle.textContent = "üîÜ";
      blobToggle.style.cursor = "pointer";
      settingsPanel.appendChild(blobToggle);

      blobToggle.addEventListener("click", () => {
        resetArticulationMode();
        blobsEnabled = !blobsEnabled;
        blobToggle.textContent = blobsEnabled ? "üîÜ" : "üîÖ";
      });
      
      // Pausen-Button
      function blinkGreenBackground() {
        // Urspr√ºngliche Hintergrundfarbe speichern (falls gesetzt, sonst Standardwert)
        const originalBg = document.body.style.backgroundColor || "";
        // Setze den Hintergrund auf den bekannten Gr√ºnton
        document.body.style.backgroundColor = "LightBlue"; // hier den gew√ºnschten Gr√ºnton anpassen
        // Nach 300 Millisekunden wieder zur√ºcksetzen
        setTimeout(function() {
          document.body.style.backgroundColor = originalBg;
        }, 300);
      }
      
      pauseButton.addEventListener("click", () => {
        if (!sessionPaused) {
          saveStatistics();
          saveButtonEffect();
          console.log("Statistiken gespeichert und gr√ºner Farbtupfer ausgel√∂st.");
        }
      });
      
      
      
      // Metronom-Ton (tick.mp3)
      const metronomeSound = new Audio('tick.mp3');
      // Metronom-Toggle
      // Metronom-Setup: Zustandsvariablen und Steuerfunktionen
      let metronomeOn = false;
      let metronomeInterval = 60000;         // Millisekunden pro Schlag, wird bei BPM-√Ñnderung angepasst
      let lastTickTime = Date.now();         // Zeitstempel des letzten Metronom-Schlags
      let metronomeTimer;                    // Intervall-Timer f√ºr Metronom
      let metronomeTolerance = 0;            // Fehlertoleranz (wird noch gesetzt)

      // Startet das Metronom: aktualisiert lastTickTime bei jedem Schlag und spielt Ton ab
      function startMetronome() {
        if (metronomeTimer) clearInterval(metronomeTimer);
        metronomeOn = true;
        lastTickTime = Date.now();
        metronomeTimer = setInterval(() => {
          // Metronom-Ton abspielen
          metronomeSound.currentTime = 0;
          metronomeSound.play();
          lastTickTime = Date.now();
        }, metronomeInterval);
      }

      // Stoppt das Metronom
      function stopMetronome() {
        metronomeOn = false;
        if (metronomeTimer) {
          clearInterval(metronomeTimer);
          metronomeTimer = null;
        }
      }

      // Metronom-Container mit Emoji und BPM-Anzeige
      const metronomeContainer = document.createElement("div");
      metronomeContainer.style.display = "inline-block";
      metronomeContainer.style.textAlign = "center";
      settingsPanel.appendChild(metronomeContainer);

      const metronomeToggle = document.createElement("span");
      metronomeToggle.id = "metronomeToggle";
      metronomeToggle.textContent = "‚è≤Ô∏è";
      metronomeToggle.style.opacity = "0.5";
      metronomeContainer.appendChild(metronomeToggle);

      const bpmDisplay = document.createElement("span");
      bpmDisplay.id = "bpmDisplay";
      bpmDisplay.style.display = "block";
      // const emojiWidth = metronomeToggle.getBoundingClientRect().width;
      bpmDisplay.style.fontSize = "14px"; // feste Schriftgr√∂√üe, frei anpassbar
      bpmDisplay.style.fontWeight = "bold";
      bpmDisplay.textContent = metronomeBPM > 0 ? metronomeBPM + " BPM" : "";
      metronomeContainer.appendChild(bpmDisplay);
      bpmDisplay.addEventListener("click", () => {
        let existingInput = document.getElementById("bpmInput");