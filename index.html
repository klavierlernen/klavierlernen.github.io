<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<title>Algorithmus UI – Grid rechts</title>

<style>
  :root {
    --real-vh: 100vh;
  }
  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: rgb(33,33,33);
    height: var(--real-vh);
    display: flex;
    justify-content: flex-end; /* alles nach rechts */
    align-items: flex-start;       /* vertikal zentriert */
    padding-top: 10px;
  }

  .right-grid {
    width: 55vw;                 /* breiter */
    max-width: 580px;            /* größere Maximalbreite */
    height: calc(var(--real-vh) - 20px);  /* bis fast an unteren Bildschirmrand */
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-auto-rows: 1fr;
    gap: 10px;
    padding-right: 10px;
    padding-bottom: 15px;
  }

  /* Jedes einzelne Rechteck */
  .cell {
    background: rgb(50,50,50);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .hand-cell {
    position: relative;
  }

  .hand-content {
    position: absolute;
    top: 5%;
    left: 5%;
    right: 5%;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    justify-content: flex-start;
    height: 100%;
  }

  .hand-title {
    font-size: calc(3vw + 3vh);
    font-weight: 700;
    color: white;
    word-break: break-word;
  }

  .hand-icon {
    position: absolute;
    bottom: 10%;
    left: 50%;
    width: calc(15vw + 15vh);
    height: calc(15vw + 15vh);
    max-width: 90%;
    max-height: 50%;
    transform: translateX(-50%) rotate(180deg);
    stroke-width: 2.5;
    color: white;
    visibility: hidden;
  }

  .icon-right svg {
    transform: rotate(180deg) scaleX(-1);
  }

  .icon-left svg {
    transform: rotate(180deg);
  }

  .icon-random svg {
    transform: none;
  }

  .hand-icon.right-hand svg {
    transform: rotate(180deg) scaleX(-1);
  }

  .hand-icon.left-hand svg {
    transform: rotate(180deg);
  }

  .hand-icon.random-mode svg {
    transform: none;
  }

  .lage-cell {
    position: relative;
  }

  .lage-content {
    position: absolute;
    top: 5%;
    left: 5%;
    right: 5%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
  }

  .lage-letter {
    font-size: calc(15vw + 15vh);
    font-weight: 700;
    color: white;
    line-height: 1;
    width: 100%;
    word-break: break-word;
    text-align: center;
  }

  .lage-word {
    margin-top: 10px;
    font-weight: 600;
    color: white;
    font-size: calc(1.5vw + 1.5vh);
    max-width: 100%;
    text-transform: uppercase;
  }

  .gespielt-cell {
    position: relative;
  }

  .gespielt-content {
    position: absolute;
    top: 5%;
    left: 5%;
    right: 5%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .gespielt-letter {
    font-size: calc(15vw + 15vh);
    font-weight: 700;
    color: white;
    line-height: 1;
    width: 100%;
    text-align: center;
    word-break: break-word;
  }

  .rabbit-cell {
    position: relative;
  }

  .rabbit-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    width: calc(15vw + 15vh);
    height: calc(15vw + 15vh);
    max-width: 90%;
    max-height: 90%;
    transform: translate(-50%, -50%);
    stroke-width: 2.5;
    color: white;
  }


  /* Texte im Rechteck — rotiert wie im Original */
  .label {
    transform: rotate(-90deg);   /* exakt wie SVG */
    font-size: 26px;
    font-weight: bold;
    color: white;
    pointer-events: none;
    user-select: none;
  }

  #left-area {
    position: absolute;
    top: 0;
    left: 0;
    width: calc(100vw - 55vw - 10px);
    height: var(--real-vh);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  #stave-canvas {
    max-width: 90%;
    max-height: 90%;
  }

  .hand-cell { cursor: pointer; }
  .lage-cell { cursor: pointer; }
  /* Force VexFlow clefs to be white (all paths, glyphs, groups) */
  svg .vf-clef *,
  svg .vf-clef path,
  svg .vf-clef g,
  svg .vf-clef .vf-glyph {
    stroke: white !important;
    fill: white !important;
  }
</style>
</style>
</head>

<body>

  <div id="left-area">
    <div id="notation"></div>
  </div>

  <div class="right-grid">
    <div class="cell hand-cell">
      <div class="hand-content">
        <div class="hand-title">Rechte Hand</div>
        <i data-lucide="hand-helping" class="hand-icon icon-right" style="visibility: visible;"></i>
        <i data-lucide="hand-helping" class="hand-icon icon-left" style="visibility: hidden;"></i>
        <i data-lucide="dices" class="hand-icon icon-random" style="visibility: hidden;"></i>
        <i data-lucide="flask-conical" class="hand-icon icon-expert" style="visibility: hidden;"></i>
        <div id="range-notation" style="position:absolute; bottom:5%; left:50%; transform:translateX(-50%); width:90%; height:40%;">
        </div>
      </div>
    </div>
    <div class="cell lage-cell">
      <div class="lage-content">
        <div class="lage-letter">C</div>
        <div class="lage-word">Lage</div>
      </div>
    </div>
    <div class="cell gespielt-cell">
      <div class="gespielt-content">
        <div class="gespielt-letter">A</div>
    </div>
    </div>
    <div class="cell rabbit-cell">
      <i data-lucide="rabbit" class="rabbit-icon"></i>
    </div>
  </div>

<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
<script>
  function fixVH() {
    document.documentElement.style.setProperty(
      "--real-vh",
      window.innerHeight + "px"
    );
  }
  fixVH();
  window.addEventListener("resize", fixVH);
</script>

<script>
  lucide.createIcons();

  let upperSeries = [];
  let lowerSeries = [];
  let upperCounter = 0;
  let lowerCounter = 0;
  let playUpper = true;

  let handModes = ["Rechte Hand", "Linke Hand", "Zufall", "Experte", "Bereich beüben"];
  let handIndex = 0;

let lageList = ["C", "D", "E", "F", "G", "A", "B"];
let lageIndex = 0;

  const handTitle = document.querySelector(".hand-title");
  let handIcon = document.querySelector(".hand-icon");
  const lageLetter = document.querySelector(".lage-letter");

  // --------- CLICK HAND ----------
  document.querySelector(".hand-cell").addEventListener("click", () => {
    handIndex = (handIndex + 1) % handModes.length;

    const mode = handModes[handIndex];

    // Update text
    handTitle.textContent = mode;

    let iconName = "hand-helping";

    // Hide all icons
    document.querySelector(".icon-right").style.visibility = "hidden";
    document.querySelector(".icon-left").style.visibility = "hidden";
    document.querySelector(".icon-random").style.visibility = "hidden";
    document.querySelector(".icon-expert").style.visibility = "hidden";

    // Show correct icon
    if (mode === "Rechte Hand") {
      document.querySelector(".icon-right").style.visibility = "visible";
    }
    else if (mode === "Linke Hand") {
      document.querySelector(".icon-left").style.visibility = "visible";
    }
    else if (mode === "Experte") {
      document.querySelector(".icon-expert").style.visibility = "visible";
    }
    else if (mode === "Bereich beüben") {
      // no icon displayed
    }
    else {
      document.querySelector(".icon-random").style.visibility = "visible";
    }

    generateSeries();
  });

  // --------- CLICK LAGE ----------
  document.querySelector(".lage-cell").addEventListener("click", () => {
    lageIndex = (lageIndex + 1) % lageList.length;
    lageLetter.textContent = lageList[lageIndex];
    generateSeries();
  });

  // --------- MIDI SETUP ----------
  let midiAccess = null;
  let lastNote = null;

  // SWIFT → JS bridge so Swift can call MIDI handler
  window.handleMIDIMessage = function(status, data1, data2) {
    const event = { data: [status, data1, data2] };
    onMIDIMessage(event);
  };

  function onMIDIMessage(event) {
    const [command, note, velocity] = event.data;

    if (command === 144 && velocity > 0) {
      const played = midiToNote(note);
      document.querySelector(".gespielt-letter").textContent = played;

      // Helper function for normalization
      function normalize(note) {
        return note.replace("♯", "#").toUpperCase();
      }

      // --- Speed Icon Logic ---
      const now = performance.now();
      if (!window._lastSpeedTime) window._lastSpeedTime = now;
      const delta = now - window._lastSpeedTime;
      window._lastSpeedTime = now;

      let speedIcon = "turtle";
      if (delta < 400) speedIcon = "rocket";
      else if (delta < 900) speedIcon = "rabbit";

      const speedElm = document.querySelector(".rabbit-icon");
      if (speedElm) {
        speedElm.setAttribute("data-lucide", speedIcon);
        lucide.createIcons();
      }

      const playedUpper = normalize(played);

      let upperExpected = upperSeries[upperCounter];
      let lowerExpected = lowerSeries[lowerCounter];

      let upperMatch = false;
      let lowerMatch = false;

      if (upperExpected) {
        const expU = normalize(upperExpected.note);
        if (playedUpper === expU) upperMatch = true;
      }

      if (lowerExpected) {
        const expL = normalize(lowerExpected.note);
        if (playedUpper === expL) lowerMatch = true;
      }

      if (handModes[handIndex] === "Rechte Hand") {
        if (upperMatch) {
          upperExpected.color = "rgb(47,75,48)";
          upperCounter++;
        } else {
          upperExpected.color = "rgb(58,39,40)";
        }
      }

      else if (handModes[handIndex] === "Linke Hand") {
        if (lowerMatch) {
          lowerExpected.color = "rgb(47,75,48)";
          lowerCounter++;
        } else {
          lowerExpected.color = "rgb(58,39,40)";
        }
      }

      else if (handModes[handIndex] === "Zufall") {
        if (playUpper) {
          if (upperMatch) {
            upperExpected.color = "rgb(47,75,48)";
            upperCounter++;
          } else {
            upperExpected.color = "rgb(58,39,40)";
          }
        } else {
          if (lowerMatch) {
            lowerExpected.color = "rgb(47,75,48)";
            lowerCounter++;
          } else {
            lowerExpected.color = "rgb(58,39,40)";
          }
        }
        playUpper = !playUpper;
      }

      else if (handModes[handIndex] === "Experte") {
        if (upperMatch) {
          upperExpected.color = "rgb(47,75,48)";
          upperCounter++;
        }
        if (lowerMatch) {
          lowerExpected.color = "rgb(47,75,48)";
          lowerCounter++;
        }
        if (!upperMatch && !lowerMatch) {
          if (upperExpected) upperExpected.color = "rgb(58,39,40)";
          if (lowerExpected) lowerExpected.color = "rgb(58,39,40)";
        }
      }

      // Set .gespielt-letter color according to correctness
      const gespieltElm = document.querySelector(".gespielt-letter");
      gespieltElm.style.color = upperMatch || lowerMatch ? "rgb(47,75,48)" : "rgb(58,39,40)";

      drawSeries();

      let upperDone = (upperCounter >= upperSeries.length);
      let lowerDone = (lowerCounter >= lowerSeries.length);

      if (handModes[handIndex] === "Rechte Hand" && upperDone) {
        setTimeout(() => generateSeries(), 400);
      }
      else if (handModes[handIndex] === "Linke Hand" && lowerDone) {
        setTimeout(() => generateSeries(), 400);
      }
      else if ((handModes[handIndex] === "Zufall") && upperDone && lowerDone) {
        setTimeout(() => generateSeries(), 400);
      }
      else if ((handModes[handIndex] === "Experte") && upperDone && lowerDone) {
        setTimeout(() => generateSeries(), 400);
      }
    }
  }

  function midiToNote(num) {
    const notes = ["C", "C#", "D", "D#", "E","F","F#","G","G#","A","A#","B"];
    return notes[num % 12];
  }

  if (navigator.requestMIDIAccess) {
    navigator.requestMIDIAccess().then((access) => {
      midiAccess = access;
      for (let input of midiAccess.inputs.values()) {
        input.onmidimessage = onMIDIMessage;
      }
    });
  }

  const lageNotes = {
    "C": ["c", "d", "e", "f", "g"],
    "D": ["d", "e", "f#", "g", "a"],
    "E": ["e", "f#", "g#", "a", "b"],
    "F": ["f", "g", "a", "b", "c"],
    "G": ["g", "a", "b", "c", "d"],
    "A": ["a", "b", "c", "d", "e"],
    "B": ["b", "c#", "d", "e", "f#"]
  };

// Global range note keys for range selector
let rangeNoteKeys = ["c/4", "d/4"];

  function generateSeries() {
    if (handModes[handIndex] === "Bereich beüben") {
      document.getElementById("range-notation").style.display = "block";
      upperSeries = [
        { note: "c", octave: 4, clef: "treble", color: "white" },
        { note: "d", octave: 4, clef: "treble", color: "white" }
      ];
      lowerSeries = [];
      upperCounter = 0;
      lowerCounter = 0;
      playUpper = true;
      drawRangeSelector();
      drawSeries();
      return;
    } else {
      document.getElementById("range-notation").style.display = "none";
    }
    lowerSeries = [];
    upperSeries = [];
    upperCounter = 0;
    lowerCounter = 0;
    playUpper = true;
    seriesLength = 5;

    const lage = lageList[lageIndex];
    const possibleNotes = lageNotes[lage];

    for (let i = 0; i < seriesLength; i++) {
      let r = Math.floor(Math.random() * possibleNotes.length);

      let clef = "treble";
      let octave = 4;

      if (handModes[handIndex] === "Linke Hand") {
        clef = "bass";
        octave = 2;
      }

      if (handModes[handIndex] === "Zufall") {
        clef = Math.random() < 0.5 ? "treble" : "bass";
        octave = clef === "treble" ? 4 : 2;
      }

      upperSeries.push({
        note: possibleNotes[r],
        octave: octave,
        clef: clef,
        color: "white"
      });
    }

    if (handModes[handIndex] === "Zufall" || handModes[handIndex] === "Experte") {
      lowerSeries = [];
      for (let i = 0; i < seriesLength; i++) {
        let r = Math.floor(Math.random() * possibleNotes.length);
        lowerSeries.push({
          note: possibleNotes[r],
          octave: 2,
          clef: "bass",
          color: "white"
        });
      }
    }

    drawSeries();
  }

  function drawRangeSelector() {
    const div = document.getElementById("range-notation");
    div.innerHTML = "";
    const renderer = new Vex.Flow.Renderer(div, Vex.Flow.Renderer.Backends.SVG);
    renderer.resize(div.clientWidth, div.clientHeight);
    const context = renderer.getContext();
    const stave = new Vex.Flow.Stave(10, 10, div.clientWidth - 20);
    stave.addClef("treble").setContext(context).draw();

    function createDraggableNote(key) {
      return new Vex.Flow.StaveNote({
        clef: "treble",
        keys: [key],
        duration: "q"
      });
    }

    let notes = [
      createDraggableNote(rangeNoteKeys[0]),
      createDraggableNote(rangeNoteKeys[1])
    ];

    // Add drag handlers on the SVG elements after rendering
    setTimeout(() => {
      const svg = div.querySelector("svg");
      const noteheads = svg.querySelectorAll(".vf-notehead");

      noteheads.forEach((head, index) => {
        head.style.cursor = "grab";

        let dragging = false;
        let lastY = 0;

        function startDrag(ev) {
          dragging = true;
          lastY = ev.touches ? ev.touches[0].clientY : ev.clientY;
          head.style.cursor = "grabbing";
        }

        function moveDrag(ev) {
          if (!dragging) return;
          let y = ev.touches ? ev.touches[0].clientY : ev.clientY;
          let deltaY = y - lastY;
          if (Math.abs(deltaY) < 4) return;
          lastY = y;

          let currentKey = rangeNoteKeys[index];
          let [base, oct] = currentKey.split("/");
          oct = parseInt(oct);

          // chromatic note list
          const steps = ["c","c#","d","d#","e","f","f#","g","g#","a","a#","b"];

          // find current index
          let stepIndex = steps.indexOf(base.toLowerCase());
          if (stepIndex === -1) return;

          // move one staff step
          if (deltaY < 0) {
            stepIndex++;
            if (stepIndex >= steps.length) {
              stepIndex = 0;
              oct++;
            }
          } else {
            stepIndex--;
            if (stepIndex < 0) {
              stepIndex = steps.length - 1;
              oct--;
            }
          }

          let newBase = steps[stepIndex];
          rangeNoteKeys[index] = newBase + "/" + oct;

          drawRangeSelector();
        }

        function endDrag() {
          if (dragging) {
            dragging = false;
            head.style.cursor = "grab";
            generateSeries();
          }
        }

        head.addEventListener("mousedown", startDrag);
        head.addEventListener("touchstart", startDrag, { passive: true });

        window.addEventListener("mousemove", moveDrag);
        window.addEventListener("touchmove", moveDrag, { passive: true });

        window.addEventListener("mouseup", endDrag);
        window.addEventListener("touchend", endDrag);
      });
    }, 50);

    const voice = new Vex.Flow.Voice({ num_beats: 2, beat_value:4 });
    notes.forEach(n=>voice.addTickable(n));
    new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth()-20);
    voice.draw(context, stave);
  }

  // --------- VEXFLOW RENDER ----------
  function drawSeries() {
    var notationDiv = document.getElementById("notation");
    notationDiv.innerHTML = "";

    var totalWidth = 80 * seriesLength + 30;
    var totalHeight = (handModes[handIndex] === "Zufall" || handModes[handIndex] === "Experte") ? 320 : 200;

    var renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
    renderer.resize(totalWidth, totalHeight);
    var context = renderer.getContext();

    function renderStave(yOffset, series) {
      var stave = new Vex.Flow.Stave(10, yOffset, totalWidth - 20);
      if (series.length > 0) {
        stave.addClef(series[0].clef);
      }
      stave.setContext(context).draw();

      var staveNotes = series.map(function(item) {
        const key = item.note + "/" + item.octave;
        const note = new Vex.Flow.StaveNote({
          clef: item.clef,
          keys: [key],
          duration: "q"
        }).setStyle({ fillStyle: item.color, strokeStyle: item.color });

        if (item.note.includes("#")) {
          note.addModifier(new Vex.Flow.Accidental("#"), 0);
        }
        return note;
      });

      var voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
      staveNotes.forEach(n => voice.addTickable(n));
      new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
      voice.draw(context, stave);
    }

    renderStave(40, upperSeries);

    if (handModes[handIndex] === "Zufall" || handModes[handIndex] === "Experte") {
      renderStave(180, lowerSeries);
    }
  }

  generateSeries();
</script>

</body>
</html>
