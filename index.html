<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Klavier</title>
<!-- VexFlow laden -->
<link rel="manifest" href="https://raw.githubusercontent.com/JP0024/piano.github.io/main/manifest.json">
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" href="icon-192.png">
<script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
<!-- canvas-confetti laden -->
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  
<style>
/* Grundlayout */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  background-color: #F8F8FF;
  font-family: "Inter", sans-serif;
  text-align: center;
  transition: background-color 0.3s, color 0.3s;
  overflow: hidden;
  position: fixed;
  width: 100%;
  height: 100%;
}

body.dark-mode {
  background-color: #0A0A0A;
  color: #e0e0e0;
}
/* Vollbild-Canvas f√ºr Animation (Hintergrund) */
#animationCanvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 5; /* niedriger als Men√ºs */
  filter: blur(20px);
  opacity: 0.2;
  pointer-events: none;
}
/* Einhand-Notation (normaler Modus) */
/* Absolute Mitte mit minimalen R√§ndern */
  #notation {
    display: none;              /* bleibt durch JS gesteuert */
    position: fixed;
    top: 85%;
    left: 65%;
    transform: translate(-50%, -50%);
    transform-origin: center center;
    width: auto;
    max-width: calc(100% - 10px); /* 5 px Rand links/rechts */
    padding: 0;
    margin: 0;
    box-sizing: border-box;
    z-index: 1;
  }

  @media screen and (max-width: 600px) {
    #notation {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 90%;   /* 5 % Rand mobil */
      padding: 0;
    }
  }
#notation svg {
  width: 100%;
  height: auto;
  shape-rendering: crispEdges;
  display: block;
  margin: 0 auto;
}
#notation svg * {
  vector-effect: non-scaling-stroke;
}
body.dark-mode #notation svg * {
  stroke: #fff;
  fill: #fff;
}
/* Motivationsfenster */
#motivationOverlay {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 15;
  pointer-events: none;
  opacity: 0;
  font-size: 2em;
  color: #000;
  text-shadow: none;
}
@keyframes floatFade {
  0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
  20% { opacity: 1; }
  80% { opacity: 1; }
  100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
}
.animate-motivation {
  animation: floatFade 2.5s ease-out forwards;
}
/* Pause-Overlay */
#pauseOverlay {
  position: fixed;
  top: 15px;
  left: 0;
  width: 100%;
  height: 100%;
  background: #fff;
  z-index: 1000;
  display: none;
  flex-direction: column;
}
/* Obere Info-Leiste im Pausenmodus */
#pauseInfo {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  width: 100%;
  box-sizing: border-box;
}
#pauseHeader {
  font-size: 2em;
  font-weight: bold;
  color: #000;
  white-space: nowrap;
}
/* Fortschrittsbalken */
#pauseProgressContainer {
  flex-grow: 1;
  height: 20px;
  border: 3px solid #000;
  border-radius: 20px;
  position: relative;
  background: #fff;
}
#pauseProgress {
  height: 100%;
  width: 0%;
  background: red;
  border-radius: 20px;
  transition: width 1s linear;
}
/* Verbleibende Zeit im Format mm:ss */
#pauseTime {
  font-size: 14px;
  color: #000;
  white-space: nowrap;
  margin-left: 10px;
  font-weight: bold;
}
/* Kachelwand im Pausenmodus ‚Äì F√ºllt den restlichen Raum wie eine Tapete */
#pauseTiles {
  flex-grow: 1;
  width: 100%;
  padding: 10px;
  box-sizing: border-box;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  grid-auto-rows: 230px;
  gap: 12px;
  overflow-y: auto;
}
/* Variierende Kacheln (Mauerstein-Effekt) */
.tile:nth-child(3n) {
  grid-row: span 2;
}
.tile:nth-child(4n) {
  grid-column: span 2;
}
.tile {
  background: #fff;
  border: 3px solid #000;
  border-radius: 20px;
  padding: 15px;
  font-size: 14px;
  color: #000;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}
.tileIcon {
  font-size: 5em;
  margin-bottom: 8px;
}
.tileTitle {
  font-size: 3em;
  font-weight: bold;
  margin-bottom: 4px;
}
.tileValue {
  font-size: 2.5em;
  font-weight: normal;
}
.barChart {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  width: 100%;
  margin-top: 5px;
  gap: 5px;
}
.bar {
  width: 10%;
  background-color: #007aff;
  border-radius: 4px 4px 0 0;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  color: #fff;
  font-size: 0.8em;
}
/* Game Over Overlay */
#gameOverOverlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 20;
  background: rgba(0,0,0,0.8);
  color: #fff;
  padding: 30px;
  border-radius: 15px;
  font-size: 2em;
  white-space: pre-line;
  display: none;
}
body.dark-mode #gameOverOverlay {
  border: 3px solid #fff;
}
.hidden {
  display: none !important;
}
/* Timer Container */
/* Timer Container */
    #timerContainer {
        font-weight: bold;
      position: fixed;
      right: 10px;
      bottom: 48px;
      font-size: 1.5em;
      z-index: 100;
      display: flex; /* Versteckt, bis der Intro-Modus beendet ist */
      align-items: center;
      justify-content: center;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 5px;
    }
/* Hauptinhalt */
#mainContent {
  display: none;
  position: relative;
  z-index: 10;
  opacity: 0;
  transition: opacity 0.5s ease-in;
  padding-bottom: 50px;
}
/* Einstellungen-Men√º */
#settingsPanel {
  position: fixed;
  top: 150%;
  right: 20px;
  transform: translateY(-15%);
  display: none;
  flex-direction: column;
  align-items: center;
  z-index: 10;
  border-radius: 20px;
  width: 60px;
  background: #fff;
  border: 3px solid #000;
  padding: 10px 20px;
  font-size: 1.2em;
  text-align: center;
  color: #000;
  box-sizing: border-box;
  transition: transform 0.2s, box-shadow 0.2s, opacity 0.5s ease;
  max-height: 90vh;        /* auf 90 % der Bildschirmh√∂he begrenzt */
  overflow-y: auto;        /* erlaubt vertikales Scrollen */
  box-sizing: border-box;  /* padding wird bei H√∂he mitgerechnet */
  padding: 1rem;
  pointer-events: auto;
  -webkit-overflow-scrolling: touch;
}

/* ================================= */
/* 3D-Stil f√ºr das Lagen-Rechteck    */
/* ================================= */
#clefTitle, #lageButton, #toneButton {
    text-transform: uppercase;
    font-weight: bold;
  background: white;
  border: 2.5px solid black;
  border-radius: 8px;
  
  padding: 16px 24px;
  margin: 8px;
  font-size: 1.2em;
  text-align: center;
  color: #333;
  cursor: pointer;
}

body.dark-mode #settingsPanel {
  background: #000;
  border-color: #fff;
}
#settingsPanel span {
    border: 3px solid #000;
  display: block;
  cursor: pointer;
  font-size: 1.8em;
  margin: 8px 0;
  padding: 2px;
  text-align: center;
  background: none;
  border: none;
}
#settingsPanel span:hover {
  background: rgba(0, 0, 0, 0.1);
}
@keyframes float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
  100% { transform: translateY(0); }
}

/* Lagewechsel-Button */
#clefTitle {
  display: inline-block;
  background: #fff;
  border: 3px solid #000;
  border-radius: 20px;
  padding: 10px 20px;
  font-size: 1.5em;
  color: #000;
  cursor: pointer;
  transition: all 0.5s ease;
  animation: float 3s ease-in-out infinite;
}
body.dark-mode #clefTitle {
  background: #000;
  border-color: #fff;
  color: #fff;
}
/* Neuer Pausen-Button im Men√º */
#pauseButton {
  display: inline-block;
  background: #fff;
  border: 3px solid #000;
  border-radius: 20px;
  padding: 10px 20px;
  font-size: 1.5em;
  color: #000;
  cursor: pointer;
  transition: all 0.5s ease;
  margin-top: 10px;
}
body.dark-mode #pauseButton {
  background: #000;
  border-color: #fff;
  color: #fff;
}
/* Container f√ºr Button & Herzen */
#buttonContainer {
  position: fixed;
  left: 50%;
  bottom: 30px;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  z-index: 50;
}
#heartsContainer {
  display: inline-block;
  margin-left: 10px;
  vertical-align: middle;
  font-size: 1.5em;
}
/* Notenname-Anzeige (normaler Modus) */
#noteNameDisplay {
  margin-top: 10px;
  font-size: 24px;
  color: #000;
  text-transform: uppercase;
}
body.dark-mode #noteNameDisplay { color: #e0e0e0; }
/* Welcome Overlay */
#welcomeOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  transition: opacity 0.5s ease-out;
  background-color: transparent;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-image: url("https://raw.githubusercontent.com/jp0024/piano.github.io/main/greenWallpaper.svg");
  background-size: cover;
  background-position: center;
}
#welcomeMessage {
  font-size: 2.5em;
  color: black;
  margin-bottom: 20px;
  font-weight: bold;
}
body.dark-mode #welcomeMessage { color: #e0e0e0; }

.bar-chart-container {
  display: flex;
  justify-content: space-between;
  gap: 4px;
  width: 100%;
  padding: 10px;
  height: 120px; /* Gesamth√∂he inkl. Label */
}

.bar-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

.bar {
  width: 100%;
  background: linear-gradient(to top, black, grey);
  border-radius: 4px 4px 0 0;
  transition: height 0.5s ease-in-out;
}

.bar-label {
  margin-top: 4px;
  font-size: 0.9em;
  text-align: center;
  color: #000;
}
  
  /* Beispiel: Klasse f√ºr eine breite, aber nur 1 Zeile hohe Kachel */
  .tile.span-2 {
    grid-column: span 2;
    /* Falls eine andere Regel (nth-child(3n)) sie hochskalieren w√ºrde, √ºberschreiben wir das: */
    grid-row: span 1 !important;
  }
  
  body.dark-mode #pauseOverlay {
    background: #121212; /* dunkler Hintergrund */
  }

  body.dark-mode #pauseHeader,
  body.dark-mode #pauseTime {
    color: white; /* helle Schrift */
  }

  body.dark-mode #pauseProgressContainer {
    background: black; /* evtl. noch dunklerer Hintergrund f√ºr den Fortschrittsbalken */
    border-color: white;
  }
  
  .tile.span-2 {
    grid-column: span 2;
    grid-row: span 1 !important;
  }
  
  #streakDisplay {
    position: fixed;
    left: 20px;
    bottom: 30px;
    font-size: 1.5em;
    z-index: 50;
    visibility: hidden;
  }
  
@media screen and (max-width: 600px) {

/* Notensystem k√ºrzen: Notation-Container anpassen */
#notation {
top: 60%;
max-width: 90%;
padding: 5px;
}

/* Passe die Notenanzeige an (falls n√∂tig) */
#noteNameDisplay {
font-size: 3em;
bottom: 80px; /* leicht nach oben verschieben, wenn n√∂tig */
}

/* Optional: Passe den Button-Container an, falls er zu gro√ü ist */
#buttonContainer {
flex-direction: column;
bottom: 20px;
}

#settingsPanel {
  max-height: 80vh !important;
  top: 10% !important;
  bottom: 10% !important;
  height: auto !important;
  overflow-y: auto !important;
  -webkit-overflow-scrolling: touch;
  pointer-events: auto;
}
}

 
 /* Custom Mode Modal Styles */
 #customModeModal {
     position: fixed;
     left: 20%;
     transform: translateY(-50%);
     top: 0;
     width: 400px;
     background: white;
     border: 2px solid black;
     border-radius: 10px;
     padding: 20px;
     z-index: 150;
 }
 #customModeModal h2 {
     margin-top: 0;
     text-align: center;
 }
 .custom-mode-row {
     display: flex;
     justify-content: space-around;
     margin-bottom: 15px;
     flex-wrap: wrap;
 }
 .custom-mode-clef-container, .custom-mode-range-container, .custom-mode-note-set {
     display: flex;
     gap: 5px;
 }
.custom-mode-clef-option, .custom-mode-range-option, .custom-mode-note-option {
padding: 5px 10px;
border: none;
background: none;
cursor: pointer;
opacity: 0.5;
transition: opacity 0.3s;
font-weight: bold;
}
 .custom-mode-clef-option.active, .custom-mode-range-option.active, .custom-mode-note-option.active {
     opacity: 1;
 }
 .custom-mode-hand-label {
     align-self: center;
     margin-right: 10px;
     font-weight: bold;
 }
 .custom-mode-save {
     text-align: center;
     margin-top: 20px;
 }
 
 .custom-mode-save button {
     background: white;
     border: 2px solid black;
     border-radius: 8px;
     padding: 10px 20px;
     font-weight: bold;
     cursor: pointer;
     font-size: 1em;
     color: #000;
     transition: transform 0.2s, box-shadow 0.2s;
 }
 
 .custom-mode-save button:active {
     transform: translateY(6px);
     box-shadow:
       0 0 0 #abc9ab,
       0 6px 6px rgba(0,0,0,0.2);
 }
 .hidden {
     display: none !important;
 }
/* Carousel Hint Speech Bubble */
.speech-bubble {
  position: fixed;
  width: 180px;
  padding: 10px;
  background: #fff;
  border: 2px solid #000;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  font-size: 0.9em;
  z-index: 1001;
}
.speech-bubble::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-width: 10px 10px 0;
  border-style: solid;
  border-color: #fff transparent;
}
.speech-bubble .close-btn {
  position: absolute;
  top: 2px;
  right: 5px;
  cursor: pointer;
  font-weight: bold;
}
/* Carousel container and track */
/* Carousel container und Track nun vertikal gestapelt */
#carouselContainer {
  position: relative;
  width: 100%;
  overflow-y: auto;      /* vertikales Scrollen erlauben */
  margin: 0 auto;
  display: flex;
  flex-direction: column; /* Items untereinander anordnen */
}

#carouselTrack {
  display: block;
  width: 100%;
}

.carouselItem {
  width: 100%;
  display: block;
  margin-bottom: 8px;     /* Abstand zwischen den Items */
}
  
  @keyframes flyOutRight {
    to { opacity: 0; transform: translateX(100%); }
  }
  @keyframes flyOutLeft {
    to { opacity: 0; transform: translateX(-100%); }
  }
  .fly-out-right {
    animation: flyOutRight 0.5s forwards;
  }
  .fly-out-left {
    animation: flyOutLeft 0.5s forwards;
    
  }
  
  #virtualKeyboard {
    position: fixed;
    top: 150%;
    left: 30px;
    right: 30px;
    width: auto;
    max-width: calc(100% - 60px);
    height: 100px;
    transform-origin: top center; /* F√ºr skalierte Darstellung */
  }

  /* Real Piano Key Sizes */
  #virtualKeyboard .white-key, #virtualKeyboard .white {
    width: 23px !important;
    height: 560px !important;
  }

  #virtualKeyboard .black-key, #virtualKeyboard .black {
    width: 14px !important;
    height: 80px !important;
    margin-left: -7px;
    margin-right: -7px;
  }

  /* Nur Touch-Interaktionen f√ºr die virtuelle Klaviatur erlauben */
  @media (pointer: fine) {
    #virtualKeyboard {
      pointer-events: none;
    }
  }
  @media (pointer: coarse) {
    #virtualKeyboard {
      pointer-events: auto;
      margin: 0 20px; /* Abstand zu den Bildschirmr√§ndern */
    }
  }
  
  /* Solange vk-active, behalten diese Elemente immer ihre Top-Position */
  body.vk-active #timerContainer,
  body.vk-active #streakDisplay,
  body.vk-active #buttonContainer {
    top: 30px !important;
    bottom: auto !important;
  }

  /* Fehler-/Korrektur-Overlay ebenfalls immer von oben einblenden */
  body.vk-active #pauseOverlay,
  body.vk-active .correction {
    top: 20px !important;
    bottom: auto !important;
  }
  
  #correctionBox {
    position: fixed;
    bottom: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: #fff;
    border: 3px solid #000;
    padding: 15px 30px;
    border-radius: 15px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  #correctionChoices {
    display: flex;
    gap: 10px;
    align-items: center;
    font-size: 2em;
  }

  #correctionChoices button,
  #confirmNoteBtn {
    font-size: 1.5em;
    padding: 5px 10px;
    cursor: pointer;
  }
  
  
    .correction-choice {
      opacity: 0.5;
      margin: 5px;
      cursor: pointer;
      display: inline-block;
      padding: 5px;
      border: 1px solid #000;
      border-radius: 4px;
    }
  
 
    #scaleSelector {
      position: absolute;
      top: 10px;
      right: 40px;
      z-index: 1000;
      display: flex;
      gap: 10px;
    }
    .clef-button {
      font-size: 2em;
      padding: 5px 10px;
      background: white;
      border: 2px solid black;
      border-radius: 10px;
      cursor: pointer;
    }
    
    .selectable-note {
      font-size: 1.5em;
      padding: 8px 10px;
      border: 2px solid black;
      border-radius: 6px;
      background: white;
      cursor: pointer;
    }
    .selectable-note.selected {
      background: lightgreen;
    }
  
  .vf-note.selected path {
    stroke: green !important;
    fill: green !important;
  }
  
  #scaleSelector {
    display: none;
    margin: 10px 0;
    gap: 8px;
  }
  #scaleSelector button {
    cursor: pointer;
    padding: 4px 8px;
  }
/* Metronome input: borderless, no spinner arrows */
#metronomeInput {
  border: none;
  background: transparent;
  outline: none;
  -moz-appearance: textfield;
  -webkit-appearance: none;
  appearance: none;
}
#metronomeInput::-webkit-outer-spin-button,
#metronomeInput::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
  
  /* 1) Settings-Panel beim Long-Press aufklappen */
  #settingsPanel.expanded {
    top: 160%      !important;
    bottom: 0   !important;
    height: auto!important;
    display: flex!important;
    flex-direction: column;
    justify-content: flex-start;
    overflow-y: auto;
  }

  /* 2) Draggable Emojis gestalten */
  .settings-emoji {
    font-size: 2em;
    margin: 8px 0;
    cursor: grab;
    user-select: none;
    transition: border 0.2s;
  }
  .settings-emoji.drag-over {
    border: 2px dashed #333;
  }
  
  /* ----------------------------------------
     Grid f√ºr alle Notennamen unter der Notation
     ---------------------------------------- */
  #noteChoiceGrid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    max-width: 300px;
    margin: 20px auto;       /* Zentriert unter dem Notensystem */
    text-align: center;
  }
  #noteChoiceGrid.hidden {
    display: none !important;
  }
  #noteChoiceGrid button {
    padding: 10px;
    font-size: 1.2em;
    border: 1px solid #000;
    border-radius: 4px;
    background-color: #fff;
    cursor: pointer;
  }
  /* Zust√§nde nach Klick (richtig/falsch) */
  #noteChoiceGrid button.correct {
    background-color: #c8e6c9;  /* Hellgr√ºn */
    border-color: #388e3c;
    color: #388e3c;
  }
  #noteChoiceGrid button.wrong {
    background-color: #ffcdd2;  /* Hellrot */
    border-color: #d32f2f;
    color: #d32f2f;
  }
  
  #lageProgressCircle {
    width: 60px;
    height: 60px;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 5px;
    border: 3px;
  }
  .lage-progress-svg {
    position: absolute;
    top: 0; left: 0;
  }
  .lage-progress-text {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.2em;
    font-weight: bold;
    color: #333;
    pointer-events: none;
    user-select: none;
    
  }
  
  #remainingNotesDisplay {
    position: absolute;
    right: 10px;
    top: 0;
    height: 100%;
    display: flex;
    align-items: center;
    font-size: 0.9em;
    font-weight: bold;
    color: #000;
  }
  
  /* Separator und Akkorde-Button */
  #scaleSelector .separator {
    width: 1px; background-color: #000;
    margin: 0 8px; align-self: center; height: 24px;
  }
  #scaleSelector #chordButton {
    font-size: 1.2em; padding: 4px 8px;
    border: 2px solid black; border-radius: 6px;
    background: white; cursor: pointer;
  }
  /* Modal f√ºr Akkordauswahl */
  #chordModal { position: fixed; top:50%; left:50%;
    transform: translate(-50%,-50%);
    width:90%; max-width:400px;
    background:#fff; border:3px solid #000;
    border-radius:10px; padding:20px; z-index:2000;
    display:none; flex-direction:column;
    align-items:center;
  }
  #chordModal.visible { display:flex !important; }
  #chordModal h2 { margin-bottom:10px; }
  #chordList { display:flex; flex-wrap:wrap; gap:10px; justify-content:center; width:100%; }
  .chord-item {
    padding:8px; border:2px solid black; border-radius:6px;
    cursor:pointer; user-select:none;
  }
  .chord-item.selected {
    background-color: lightgreen; border-color: green;
  }
  #chordModal .confirm-chords {
    font-size:2em; cursor:pointer; margin-top:15px;
  }
    
    #introOverlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: white;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      transition: transform 1s ease-in-out;
    }
    #introOverlay.hidden {
      transform: translateY(-100%);
    }
    #introOverlayText {
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      padding: 20px;
      color: black;
    }
  
</style>
<script>
  
  let twoHandMode = false;
  let seriesCounterLeft = 0;
  let seriesCounterRight = 0;
  let currentSeriesLeft = [];
  let currentSeriesRight = [];


  
// Disable any scrolling
window.addEventListener('scroll', function(e) {
  e.preventDefault();
  window.scrollTo(0, 0);
}, { passive: false });

// Oben im Skript
let customModeSettings = null;
const octaveDefinitions = {
grosse:   { notes: ["c","d","e","f","g","a","b"], baseOctave: 3 },
kleine:   { notes: ["c","d","e","f","g","a","b"], baseOctave: 4 },
eingestr: { notes: ["c","d","e","f","g","a","b"], baseOctave: 5 },
zweigestr:{ notes: ["c","d","e","f","g","a","b"], baseOctave: 6 },
};

let wizardMode = true;
let correctionActive = false;
let availableNotes = [];
let selectedNoteIndex = 0;
let expectedNote = "";

// === Touch‚Äêbased positioning for the notation crosshair ===
document.addEventListener('DOMContentLoaded', () => {
// Funktion, die unter dem Notensystem ein 4√ó4-Grid aller Notennamen anzeigt
function showNoteChoiceGrid() {
  const grid = document.getElementById("noteChoiceGrid");
  // Dynamically derive only the 5 active notes for the current Lage, using improved German naming logic
  const choices = rangeNotes[currentRange].map(raw => {
    const letter = raw.charAt(0).toUpperCase();
    if (raw.endsWith("#")) {
      // German sharp: 'Cis'
      return letter + "is";
    } else if (raw === "b") {
      // Natural B
      return "H";
    } else if (raw.endsWith("b")) {
      // German flat: 'Es', 'As', 'Des', etc.
      if (letter === "E" || letter === "A") {
        return letter + "s";
      }
      return letter + "es";
    }
    return letter;
  });
  // Leere eventuell vorhandene Buttons
  grid.innerHTML = "";

  // Hol die gerade gezeichnete Note (im Mobilmodus ist das immer nur eine Einzel-Note)
  const correctRaw = currentSeriesSingle[0].note;
  // Wandle sie um in deutsche Notenschreibweise (z.B. "c#" ‚Üí "Cis", "b" ‚Üí "H", "eb" ‚Üí "Es")
  let expected;
  if (correctRaw.endsWith("#")) {
    expected = correctRaw.charAt(0).toUpperCase() + "is";
  } else if (correctRaw === "b") {
    expected = "H";
  } else if (correctRaw.endsWith("b")) {
    const letter = correctRaw.charAt(0).toUpperCase();
    if (letter === "E" || letter === "A") {
      expected = letter + "s";
    } else {
      expected = letter + "es";
    }
  } else {
    expected = correctRaw.toUpperCase();
  }

  // Erstelle pro Eintrag in choices einen Button
  choices.forEach(name => {
    const btn = document.createElement("button");
    btn.textContent = name;
    btn.addEventListener("click", () => {
      if (name === expected) {
        btn.classList.add("correct");
      } else {
        btn.classList.add("wrong");
        // Markiere zus√§tzlich den korrekten Button (falls er noch sichtbar ist)
        const correctBtn = Array.from(grid.children)
          .find(el => el.textContent === expected);
        if (correctBtn) correctBtn.classList.add("correct");
      }
      // Nach 1 Sekunde: Grid wieder ausblenden, neue Note generieren und erneut anzeigen
      setTimeout(() => {
        grid.classList.add("hidden");
        generateSeries();       // neue Einzel-Note im Mobilmodus
        showNoteChoiceGrid();   // und wieder das Grid anzeigen
      }, 1000);
    });
    grid.appendChild(btn);
  });

  // Grid sichtbar machen
  grid.classList.remove("hidden");
}
// --- Correction overlay: after .correction-letter click, hide overlay and start next exercise after 1s ---
// (Insert this logic where the correction overlay is created and .correction-letter listeners are attached)
// (Find the section where you build the correction overlay and attach click listeners to .correction-letter)
// Example:
// choices.forEach(letter => {
//   html += `<span class="correction-letter" ...>${letter}</span>`;
// });
// Shortly after:
// document.querySelectorAll('.correction-letter').forEach(elem => {
//   elem.addEventListener('click', () => {
//     // existing correct/wrong logic...
//   });
// });
//
// Now, inside that addEventListener('click', ...) callback, after marking .wrong/.correct, insert:
// (This ensures, sowohl bei falscher als auch bei richtiger Antwort, nach 1¬†Sekunde das Overlay verschwindet und die n√§chste Note geladen wird.)
//
// Example patch:
// elem.addEventListener('click', () => {
//   // ...existing logic...
//   setTimeout(() => {
//     const box = document.getElementById("correctionBox");
//     if (box) box.style.display = "none";
//     correctionActive = false;
//     generateSeries();
//   }, 1000);
// });
const notation = document.getElementById('notation');
if (!notation) return;

// Load or set default transform
let saved = localStorage.getItem('notationTransform');
if (!saved) {
saved = 'translate(-50%, -50%)';
localStorage.setItem('notationTransform', saved);
}
notation.style.transform = saved;

// Prepare variables for touch dragging
let startX = 0, startY = 0;
let initX = 0, initY = 0;
let dragging = false;

notation.addEventListener('touchstart', e => {
// Only allow dragging if the Geodreieck-Button ("geometryToggle") is active
const toggle = document.getElementById('geometryToggle');
const isActive = toggle && (toggle.classList.contains('active') || toggle.dataset.active === 'true');
if (!isActive) return;
e.preventDefault();
dragging = true;
const touch = e.touches[0];
startX = touch.clientX;
startY = touch.clientY;
const style = window.getComputedStyle(notation);
const matrix = new DOMMatrix(style.transform);
initX = matrix.m41;
initY = matrix.m42;
}, { passive: false });

notation.addEventListener('touchmove', e => {
if (!dragging) return;
e.preventDefault();
const touch = e.touches[0];
const dx = touch.clientX - startX;
const dy = touch.clientY - startY;
const newX = initX + dx;
const newY = initY + dy;
// Calculate the position of the center of notation in viewport
// The transform is relative to (left:50%, top:50%)
const newLeft = newX + window.innerWidth / 2;
const newTop = newY + window.innerHeight / 2;
if (
  newLeft > 0 &&
  newLeft < window.innerWidth &&
  newTop > 0 &&
  newTop < window.innerHeight
) {
  notation.style.transform = `translate(${newX}px, ${newY}px)`;
}
}, { passive: false });

notation.addEventListener('touchend', () => {
if (!dragging) return;
dragging = false;
localStorage.setItem('notationTransform', notation.style.transform);
});
});

  
  // Moved updateTimer definition above DOMContentLoaded event listener to ensure it's defined before use
  const updateTimer = () => {
    const timerElem = document.getElementById("timerContainer");
    
    // Berechne den durchschnittlichen Bearbeitungszeit (in ms), Standard: 1000 ms falls noch keine Werte vorhanden
    let avgResponse = responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
      : 1000;
    
    // Berechne die Fehlerquote: Anteil der Fehlversuche
    let errorRate = totalAttempts > 0
      ? (totalAttempts - correctAnswers) / totalAttempts
      : 0;
    
    // Voraussichtliche Zeit (in Sekunden) = Anzahl verbleibender Noten * (durchschnittliche Bearbeitungszeit in s) * (1 + Fehlerquote)
    let predictedTimeSec = sessionCounter * (avgResponse / 1000) * (1 + errorRate);
    
    // Formatiere in mm:ss
    let minutes = Math.floor(predictedTimeSec / 60);
    let seconds = Math.floor(predictedTimeSec % 60);
    let timeStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
    
    timerElem.textContent = `vsl. ${timeStr} min`;
  };

  document.addEventListener("DOMContentLoaded", () => {
    const timerElem = document.getElementById("timerContainer");
    // Beispiel: Direkt eine Info setzen
    timerElem.textContent = `${sessionCounter}, vsl. 00:00 min`;
    // Oder den Timer sofort updaten, falls du eine Funktion hast:
    updateTimer();
  // Entfernt: Doppele Aufruf von startTutorialSequence() wurde entfernt,
  // da das Tutorial nun ausschlie√ülich √ºber die MIDI-Pr√ºfung gestartet wird.
  });
  let elapsedTimer = 0;
  let cachedUserRank = null;
  let kidsMode = false;
  
  function updateUserPlacement(valueElem, data) {
    const sorted = data.sort((a, b) => {
      const qA = parseInt(a.quote || 0), qB = parseInt(b.quote || 0);
      const sA = parseInt(a.speed || 9999), sB = parseInt(b.speed || 9999);
      if (qB !== qA) return qB - qA;
      return sA - sB;
    });
    const rank = sorted.findIndex((e) => e.user === userID) + 1;
    const text = rank > 0 ? `Platz ${rank}` : "Nicht gefunden";
    cachedUserRank = text;
    valueElem.textContent = text;
  }
  
  function showMotivation(message) {
      const overlay = document.getElementById("motivationOverlay");
      overlay.textContent = message;
      overlay.style.opacity = "1";
      overlay.classList.add("animate-motivation");
      setTimeout(() => {
           overlay.style.opacity = "0";
           overlay.classList.remove("animate-motivation");
      }, 2000);
  }

  function clearMotivation() {
      const overlay = document.getElementById("motivationOverlay");
      overlay.textContent = "";
  }
  
/************** Funktionen, die vor der Verwendung deklariert sein m√ºssen **************/
// Eigene Prompt-Funktion, die in Swift-Umgebungen den Message-Handler nutzt
  function customPrompt(message) {
if (typeof prompt === 'function') {
      return prompt(message);
} else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt) {
      // Sende die Nachricht an Swift; Swift muss dann eine Antwort zur√ºckliefern,
      // z. B. indem es window.customPromptResponse setzt.
      window.webkit.messageHandlers.customPrompt.postMessage(message);
      // Hier nehmen wir an, dass Swift synchron oder zeitnah eine Antwort liefert und
      // diese in window.customPromptResponse speichert. (Alternativ muss hier asynchron vorgegangen werden.)
      return window.customPromptResponse || "";
    } else {
      console.log("Kein Prompt verf√ºgbar.");
      return "";
    }
  }
  
// Metronom-Variablen und Funktionen
  let metronomeOn =false;
  let metronomeBPM = 0;
  let metronomeInterval = 0;
  let metronomeTimer = null;
  let lastTickTime = 0;
  let metronomeTolerance = 100; // ms Toleranz f√ºr MIDI-√úbertragung
  // Tick-Sound (bitte ggf. die URL anpassen)
  const tickSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/tick.mp3");

  function startMetronome() {
    lastTickTime = Date.now();
    tickSound.currentTime = 0;
    tickSound.play();
    metronomeTimer = setInterval(() => {
      tickSound.currentTime = 0;
      tickSound.play();
      lastTickTime = Date.now();
    }, metronomeInterval);
  }

  function stopMetronome() {
    clearInterval(metronomeTimer);
  }

  function showPauseScreen() {
    sessionPaused = true;
    document.getElementById("mainContent").style.display = "none";
    document.getElementById("timerContainer").style.display = "none";
    document.getElementById("settingsPanel").style.display = "none";
    // Animate notation scale up and back on pause
    const notationEl = document.getElementById("notation");
    if (notationEl) {
      notationEl.style.transition = "transform 0.2s ease-in-out";
      // Scale up from the default translation
      notationEl.style.transform = "translate(-50%, -50%) scale(1.2)";
      // After 200ms, revert to default position
      setTimeout(() => {
        notationEl.style.transform = "translate(-50%, -50%)";
      }, 200);
    }
    document.getElementById("pauseOverlay").style.display = "flex";
  }
  
// Neue Funktion, die einen gr√ºnen Farbtupfer erzeugt
function saveButtonEffect() {
  const canvas = document.getElementById("animationCanvas");
  if (!canvas) return;
  
  // Hole die Position des Men√ºs (settingsPanel)
  const settingsPanel = document.getElementById("settingsPanel");

  // --- Geometriemodus-Logik f√ºr Emoji-Anzeige ---
  // Suche nach dem Geometriemodus-Toggle (z.B. Button mit id "geometryToggle")
  const geometryToggle = document.getElementById("geometryToggle");
  if (geometryToggle) {
    geometryToggle.addEventListener("click", function () {
      setTimeout(() => {
        const isActive = geometryToggle.classList.contains("active") || geometryToggle.dataset.active === "true";
        const keepEmojis = ["üìê", "‚ûï", "‚ûñ"].map(e => e.trim());
        document.querySelectorAll('#settingsPanel span.settings-emoji').forEach(emoji => {
          const emojiChar = [...emoji.textContent.trim()][0];
          if (isActive) {
            // Nur üìê, ‚ûï, ‚ûñ behalten
            if (!keepEmojis.includes(emojiChar)) {
              emoji.classList.add("hidden-during-geometry");
              emoji.style.display = "none";
            }
          } else {
            // Alle wieder einblenden
            if (emoji.classList.contains("hidden-during-geometry")) {
              emoji.style.display = '';
              emoji.classList.remove("hidden-during-geometry");
            }
          }
        });
      }, 10);
    });
  }
  const emojiContainer = document.getElementById("settingsEmojiContainer");
  let x, y;
  if (settingsPanel) {
    const rect = settingsPanel.getBoundingClientRect();
    // Tupfer soll in der Mitte des Men√ºs erscheinen
    x = rect.left + rect.width / 2;
    y = rect.top + rect.height / 2;
  } else {
    // Fallback: Mitte des Canvas
    x = canvas.width / 2;
    y = canvas.height / 2;
  }
  
  // Definiere Parameter f√ºr den Tupfer
  const radius = Math.random() * 200 + 200; // Gr√∂√üe anpassen
  const creationTime = Date.now();
  const duration = 1500; // Dauer in Millisekunden
  
  // Erzeuge den Tupfer (Farbtupfer wird zur globalen circles-Array hinzugef√ºgt)
  circles.push({ x, y, radius, color: "green", creationTime, duration });
}
  
function updateStreak() {
  // Hole den bisherigen Streak (falls vorhanden)
  let streak = Number(localStorage.getItem("streak")) || 0;
  // Hole das Datum der letzten Lernsession, falls vorhanden
  let lastDateStr = localStorage.getItem("lastLearnDate");
  // Bestimme heute (ohne Uhrzeit)
  let today = new Date();
  today.setHours(0,0,0,0);
  
  if (lastDateStr) {
    let lastDate = new Date(lastDateStr);
    lastDate.setHours(0,0,0,0);
    // Berechne den Unterschied in Tagen
    let diffDays = (today - lastDate) / (1000 * 60 * 60 * 24);
    if (diffDays === 1) {
      // Konsekutiver Tag: Erh√∂he den Streak
      streak++;
    } else if (diffDays > 1) {
      // Mehr als ein Tag Pause: Streak zur√ºcksetzen
      streak = 1;
    }
    // Falls diffDays === 0: wir sind noch am gleichen Tag; der Streak bleibt unver√§ndert
  } else {
    streak = 1;
  }
  
  // Speichere das heutige Datum und den aktuellen Streak
  localStorage.setItem("lastLearnDate", today.toISOString());
  localStorage.setItem("streak", streak);
  
  return streak;
}
  
  document.addEventListener("DOMContentLoaded", () => {
    // Aktualisiere und zeige den Streak an:
    const currentStreak = updateStreak();
    const streakDisplay = document.getElementById("streakDisplay");
    streakDisplay.textContent = "üî• " + currentStreak;
    streakDisplay.style.cursor = "pointer";
    streakDisplay.addEventListener("click", () => {
      sessionCounter = 0;
      updateTimer();
      startPauseCountdown();
    });

    // ... restlicher Initialisierungscode
  });
  
function logSessionStart() {
  const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
  sessionTimes.push(new Date().toISOString());
  localStorage.setItem("sessionTimes", JSON.stringify(sessionTimes));
}
  
// Speichert die relevanten Statistiken im localStorage
function saveStatistics() {
  const stats = {
    totalAttempts: totalAttempts,
    correctAnswers: correctAnswers,
    correctNoteCount: correctNoteCount,
    responseTimes: responseTimes,
    sessionCount: sessionCount,
    hearts: hearts,
    errorNotes: errorNotes,
    // Du kannst hier auch weitere Variablen eintragen, z.B. openTimes, appStartTime etc.
    appStartTime: appStartTime
  };
  localStorage.setItem("appStatistics", JSON.stringify(stats));
  // Ensure all leaderboard values (accuracy, duration, mode) are sent for proper leaderboard updates
  if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
    window.webkit.messageHandlers.gameCenter.postMessage({
      type: "highscore",
      value: {
        accuracy: Math.round((correctAnswers / totalAttempts) * 100),
        duration: Math.floor((Date.now() - appStartTime) / 1000),
        mode: randomMode ? "random" : selectedMode
      }
    });
  }
}

// L√§dt die Statistiken aus dem localStorage und weist sie den globalen Variablen zu
function loadStatistics() {
  const statsStr = localStorage.getItem("appStatistics");
  if (statsStr) {
    const stats = JSON.parse(statsStr);
    totalAttempts = stats.totalAttempts || 0;
    correctAnswers = stats.correctAnswers || 0;
    correctNoteCount = stats.correctNoteCount || 0;
    responseTimes = stats.responseTimes || [];
    sessionCount = stats.sessionCount || 0;
    hearts = stats.hearts || (unlimitedLives ? Infinity : 4);
    errorNotes = stats.errorNotes || [];
    appStartTime = stats.appStartTime || Date.now();
  }
}

// Optional: Speichern der Statistiken, wenn die Seite geschlossen wird
window.addEventListener("beforeunload", saveStatistics);

// Beim Laden der Seite die Statistiken laden
document.addEventListener("DOMContentLoaded", loadStatistics);

function proceedToMainScreen() {
  const audio = document.getElementById("backgroundSound");
  if (audio) { audio.pause(); }
  appStartTime = Date.now();
  const welcomeOverlay = document.getElementById("welcomeOverlay");
  setTimeout(() => {
    welcomeOverlay.style.opacity = "0";
    setTimeout(() => {
      welcomeOverlay.classList.add("hidden");
      const mainContent = document.getElementById("mainContent");
      mainContent.style.display = "block";
      document.getElementById("timerContainer").style.display = "flex";
      document.getElementById("settingsPanel").style.display = "flex";
      setTimeout(() => { mainContent.style.opacity = "1"; }, 500);
    }, 1000);
  }, 5000);
}
function getRandomThreshold() {
  return Math.floor(Math.random() * 4) + 2;
}

document.addEventListener("DOMContentLoaded", () => {
  // MIDI-Quelle erkennen und loggen
  let midiSource = "MIDI (Unknown)";
  if (window.webkit?.messageHandlers?.customPrompt) {
    midiSource = "MIDI iOS (Swift Bridge)";
    console.log("üì± MIDI-Quelle:", midiSource);
    return;
  } else if (navigator.requestMIDIAccess) {
    midiSource = "MIDI Web (Browser)";
    console.log("üåê MIDI-Quelle:", midiSource);
  } else {
    midiSource = "MIDI (Nicht unterst√ºtzt)";
    console.warn("‚ùå MIDI-Quelle:", midiSource);
    return;
  }
  const settingsPanel = document.getElementById("settingsPanel");
  const pauseButton = document.createElement("span");
  pauseButton.id = "pauseButton";
  pauseButton.textContent = "üéπ";
  settingsPanel.appendChild(pauseButton);

  pauseButton.addEventListener("click", () => {
    const notationElem = document.getElementById("notation");
    const vk = document.getElementById("virtualKeyboard");
    if (vk) {
      const isHidden = vk.style.visibility === "hidden";
      vk.style.visibility = isHidden ? "visible" : "hidden";
      // Neu: Klasse setzen/removen
      if (isHidden) {
        document.body.classList.add("vk-active");
      } else {
        document.body.classList.remove("vk-active");
      }
      if (notationElem) {
        if (isHidden) {
          // Keyboard wird aktiviert: Notation etwas h√∂her positionieren
          notationElem.style.top = "55%";
        } else {
          // Keyboard wird deaktiviert: gespeicherte Position wiederherstellen
          const saved = localStorage.getItem("notationTransform");
          if (saved) notationElem.style.transform = saved;
          // Entferne inline-top, damit CSS-Default (85%) greift
          notationElem.style.top = "";
        }
      }
    }
  });

  // ---- Virtual Keyboard below notation ----
  // Find the button container
  const bc = document.getElementById("buttonContainer");
  if (bc) {
    // Create a virtual keyboard element
    const vk = document.createElement("div");
    vk.id = "virtualKeyboard";
    vk.textContent = "Virtuelles Keyboard";
    // Keyboard initially hidden
    vk.style.visibility = "hidden";
    vk.style.position = "fixed";
    vk.style.top = "10%";
    vk.style.transform = "translateY(210%) scale(0.7, 1.5)"; // Uniform Zoom: both axes the same scale
    vk.style.zIndex = "100";
    vk.style.background = "#eee";
    vk.style.padding = "100px";
    // Initially place it just above the button container
    // We'll update its position on window resize and DOMContentLoaded
    function positionVK() {
      const bcRect = bc.getBoundingClientRect();
      const vkHeight = vk.offsetHeight || 200;
      // Place it above the button container, but not out of screen
      let top = bcRect.top - vkHeight - 5;
      if (top < 0) top = 0;
      vk.style.top = `${top}px`;
    }
    // Append first so offsetHeight is available
    document.body.appendChild(vk);
    // --- Override key dimensions after rendering ---
    setTimeout(() => {
      const whiteKeys = vk.querySelectorAll('.white-key, .white');
      whiteKeys.forEach(key => {
        key.style.width = '23px';
        key.style.height = '260px';
      });
      const blackKeys = vk.querySelectorAll('.black-key, .black');
      blackKeys.forEach(key => {
        key.style.width = '14px';
        key.style.height = '80px';
        key.style.marginLeft = '-7px';
        key.style.marginRight = '-7px';
      });
    }, 100);
    // Position after appending
    positionVK();
    // Update position on window resize and orientation change
    window.addEventListener("resize", positionVK);
    window.addEventListener("orientationchange", positionVK);
    // The virtual keyboard layout and input is now handled only by QwertyHancock or other dedicated code.
    // No manual <button> elements are created here.
  }
});
  
/************** Globale Variablen & Konstanten **************/
// Handoptionen
const handOptions = [
  { mode: "left", symbol: "‚úã" },
  { mode: "right", symbol: "‚úã", flip: true }
];
let currentHandIndex = 0;
let selectedMode = handOptions[currentHandIndex].mode;
let randomMode = false;
// Akkord-Quiz Modus
let isChordMode = false;
let selectedChords = [];
const chords = [
  { name: 'C-Akkord', notes: ['c/4','e/4','g/4'] },
  { name: 'D-Akkord', notes: ['d/4','fis/4','a/4'] },
  { name: 'F-Akkord', notes: ['f/4','a/4','c/5'] },
  { name: 'G-Akkord', notes: ['g/4','h/4','d/5'] }
];
function renderChordList() {
  const list = document.getElementById('chordList');
  list.innerHTML = '';
  chords.forEach((ch, i) => {
    const el = document.createElement('div');
    el.className = 'chord-item';
    el.textContent = ch.name;
    el.dataset.index = i;
    el.addEventListener('click', () => el.classList.toggle('selected'));
    list.appendChild(el);
  });
}

// Verf√ºgbare Quintenzirkel-Tonarten
const rangeArray = [
  "C", "G", "D", "A", "E", "B", "F#", "C#", "Ab", "Eb", "Bb", "F"
];
const alternatingRanges = [
  "C", "G", "D", "A", "E", "B", "F#", "C#", "Ab", "Eb", "Bb", "F"
];
let currentRangeIndex = 0;
let currentRange = rangeArray[currentRangeIndex];

// Zuordnung von Tonart (Quintenzirkel) zu den ersten f√ºnf diatonischen Noten dieser Tonart
const rangeNotes = {
  "C":  ["c",  "d",  "e",  "f",  "g"],
  "G":  ["g", "a", "b", "c", "d"],
  "D":  ["d",  "e",  "f#", "g",  "a"],
  "A":  ["a",  "b",  "c#", "d",  "e"],
  "E":  ["e",  "f#", "g#", "a",  "b"],
  "B":  ["b",  "c#", "d#", "e",  "f#"],
  "F#": ["f#", "g#", "a#", "b",  "c#"],
  "C#": ["c#", "d#", "e#", "f#", "g#"],
  "Ab": ["ab", "bb", "c",  "db", "eb"],
  "Eb": ["eb", "f",  "g",  "ab", "bb"],
  "Bb": ["bb", "c",  "d",  "eb", "f"],
  "F":  ["f",  "g",  "a",  "bb", "c"]
};

let currentSeriesSingle = [];
let seriesCounter = 1000;
const seriesLength = 5;
let totalAttempts = 0;
let correctAnswers = 0;
let correctNoteCount = 0;
let nextMotivationThreshold = getRandomThreshold();
let errorNotes = [];
let responseTimes = [];
let lastNoteTimestamp = Date.now();
let appStartTime = Date.now();
let sessionCounter = Number(localStorage.getItem("sessionCounter")) || 5; // 5 korrekte Noten erforderlich
let sessionPaused = false;
let scoreRecorded = false;
let sessionCount = 0;
let unlimitedLives = true;
let hearts = unlimitedLives ? Infinity : 4;
let inactivityTimeout = null;

// Beim Laden der Seite oder zu Beginn eines Trainings:
const saveOpenTime = () => {
  const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
  openTimes.push(new Date().toISOString());
  localStorage.setItem("openTimes", JSON.stringify(openTimes));
};

document.addEventListener("DOMContentLoaded", saveOpenTime);
const chordButton = document.getElementById('chordButton');
const chordModal = document.getElementById('chordModal');
let confirmChords = null;

if (chordButton && chordModal) {
  confirmChords = chordModal.querySelector('.confirm-chords');

  chordButton.addEventListener('click', () => {
    renderChordList();
    chordModal.classList.add('visible');
  });

  if (confirmChords) {
    confirmChords.addEventListener('click', () => {
      selectedChords = Array.from(document.querySelectorAll('#chordList .chord-item.selected'))
        .map(el => chords[+el.dataset.index]);
      chordModal.classList.remove('visible');
      if (selectedChords.length) {
        isChordMode = true;
        generateSeries();
      }
    });
  }
}
const updateHeartsDisplay = () => {
  const heartsElem = document.getElementById("heartsContainer");
  heartsElem.textContent = unlimitedLives ? "" : "‚ù§Ô∏è".repeat(hearts);
};
  
  function updatePauseTiles() {
    const container = document.getElementById("pauseTiles");
    if (!container) return;

    // Berechne App‚ÄëZeit
    const totalTimeSec = Math.floor((Date.now() - appStartTime) / 1000);
    const h = Math.floor(totalTimeSec / 3600);
    const m = Math.floor((totalTimeSec % 3600) / 60);
    const s = totalTimeSec % 60;
    const appTime = (h > 0 ? (h + "h ") : "") + m + "m " + s + "s";

    // Berechne Prozent richtiger Noten
    const correctPercent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;

    // Durchschnittliche Bearbeitungszeit (in Sekunden)
    const avgTimeSec = responseTimes.length
      ? (responseTimes.reduce((acc, t) => acc + t, 0) / responseTimes.length / 1000).toFixed(2)
      : "N/A";

    container.innerHTML = `
      <div class="tile">
        <div class="tileIcon">‚è∞</div>
        <div class="tileTitle">App‚ÄëZeit</div>
        <div class="tileValue">${appTime}</div>
      </div>
      <div class="tile">
        <div class="tileIcon">‚úÖ</div>
        <div class="tileTitle">Richtige Noten</div>
        <div class="tileValue">${correctPercent}%</div>
      </div>
      <div class="tile">
        <div class="tileTitle">Wann √ºbst du am meisten?</div>
        <div class="barChart">
           ${generateBarChartHTML()}
        </div>
      </div>
      ${ generateLearningQualityGraphTile() }
      <div class="tile">
        <div class="tileTitle">Session</div>
        <div class="tileValue">${sessionCount}</div>
      </div>
      ${generateTrophyTile()}
    `;
  }
  
  function getLastThreeSessions() {
    // Beispiel: Session-Daten als Array von Objekten mit responseTimes (ms), errorCount, totalAttempts und sessionTime (in sec)
    const sessions = JSON.parse(localStorage.getItem("sessionData") || "[]");
    return sessions.slice(-3);
  }

  function calculateQuality(session) {
    // Durchschnittliche Antwortzeit in Sekunden (niedriger ist besser)
    const avgResponse = session.responseTimes.length
      ? session.responseTimes.reduce((a, b) => a + b, 0) / session.responseTimes.length / 1000
      : 0;
    // Fehlerquote (niedriger ist besser)
    const errorRate = session.totalAttempts ? (session.errorCount / session.totalAttempts) : 0;
    // Die Session-Dauer in Sekunden ‚Äì l√§ngere Sessions k√∂nnen auf mehr Engagement hinweisen
    const learningTime = session.sessionTime || 0;
    // Beispielhafte Gewichtung: Wir wollen, dass niedrigere Antwortzeiten und Fehlerquoten zu h√∂heren Qualit√§tswerten f√ºhren.
    // Hier eine einfache Rechnung, die in den meisten F√§llen einen Wert zwischen 0 und 100 liefert.
    let quality = 100 - (avgResponse * 10) - (errorRate * 100) + (learningTime / 60);
    return Math.max(0, Math.min(quality, 100));
  }
  
  function drawLearningQualityGraph(canvas, sessions) {
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);

    // Berechne die Qualit√§tswerte
    const qualities = sessions.map(calculateQuality);

    // Wir erwarten Werte zwischen 0 und 100, also skalieren wir den y-Wert entsprechend.
    ctx.beginPath();
    for (let i = 0; i < qualities.length; i++) {
      const x = (i / (qualities.length - 1)) * width;
      // H√∂here Qualit√§t => niedrigere y-Koordinate (oben ist 0)
      const y = height - (qualities[i] / 100 * height);
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      // Optional: Zeichne einen kleinen Kreis als Punkt
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fillStyle = "#007aff";
      ctx.fill();
      ctx.beginPath(); // Beginne neuen Pfad f√ºr die Linie
      if(i === 0) {
        ctx.moveTo(x,y);
      }
    }
    ctx.strokeStyle = "#007aff";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  

  function generateTrophyTile() {
    const tile = document.createElement("div");
    tile.className = "tile span-2";
    tile.style.display = "flex";
    tile.style.flexDirection = "row";
    tile.style.alignItems = "center";
    tile.style.justifyContent = "space-between";
    const title = document.createElement("div");
    title.className = "tileTitle";
    title.style.flex = "1";
    title.style.display = "flex";
    title.style.flexDirection = "column";
    title.style.justifyContent = "center";
    title.style.alignItems = "center";
    title.innerHTML = "üèÜ Troph√§en                 <span id='resetTrophiesBtn' style='cursor:pointer;' title='Reset'>üóëÔ∏è</span>";
    tile.appendChild(title);

    const trophyGrid = document.createElement("div");
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.alignItems = "flex-start";
    wrapper.style.flex = "2";
    trophyGrid.style.display = "grid";
    trophyGrid.style.gridTemplateColumns = "repeat(10, 1fr)";
    trophyGrid.style.gridGap = "5px";
    trophyGrid.style.fontSize = "2em";
trophyGrid.style.marginTop = "10px";

const descriptionBox = document.createElement("div");
descriptionBox.id = "trophyDescriptionBox";
descriptionBox.style.marginTop = "10px";
descriptionBox.style.fontSize = "1em";
descriptionBox.style.color = "#333";
descriptionBox.style.minHeight = "2em";
descriptionBox.style.marginLeft = "20px";
descriptionBox.style.textAlign = "left";
descriptionBox.style.maxWidth = "200px";

    const allTrophies = [
      "üê¢", "üêå", "üö∂‚Äç‚ôÇÔ∏è", "üèÉ", "‚ö°",     // Speed
      "üéº", "üéπ", "üé∫", "ü™ï", "ü™ó",     // Clef Accuracy
      "üå±", "üåø", "üåª", "üå≤", "üéÑ", "üî•", "üöÄ", "ü™ê", "üåû", "üëë", // Streak
      "üîÄ", "üåÄ", "üîÅ", "‚è©", "‚öôÔ∏è",     // Mode switching
      "üìè", "üìê", "üß≠", "üéØ", "üèÅ"      // Metronome precision
    ];

    const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
    const justUnlocked = [];

    allTrophies.forEach((emoji, index) => {
      const span = document.createElement("span");
      span.textContent = emoji;
      span.title = getTrophyDescription(index);
      span.style.cursor = "pointer";
      span.addEventListener("click", () => {
        descriptionBox.textContent = getTrophyDescription(index);
      });
      if (unlockedTrophies.includes(index)) {
        span.style.opacity = "1";
      } else {
        const shouldUnlock = checkTrophyCondition(index);
        if (shouldUnlock) {
          unlockedTrophies.push(index);
          justUnlocked.push(span);
          span.style.opacity = "0";
          setTimeout(() => {
            span.style.transition = "opacity 1s";
            span.style.opacity = "1";
            confetti({ particleCount: 50, spread: 50, origin: { x: 0.5, y: 0.5 } });
          }, 100);
        } else {
          span.style.opacity = "0.5";
        }
      }
      trophyGrid.appendChild(span);
    });

    localStorage.setItem("unlockedTrophies", JSON.stringify(unlockedTrophies));
    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
      unlockedTrophies.forEach(id => {
        window.webkit.messageHandlers.gameCenter.postMessage({
          type: "achievement",
          value: "trophy_" + id
        });
      });
    }
    wrapper.appendChild(trophyGrid);
    wrapper.appendChild(descriptionBox);
    tile.appendChild(wrapper);
    setTimeout(() => {
      const resetBtn = document.getElementById("resetTrophiesBtn");
      if (resetBtn) {
        resetBtn.addEventListener("click", () => {
          localStorage.removeItem("unlockedTrophies");
          updatePauseTiles();
        });
      }
    }, 0);
    return tile.outerHTML;
  }

  function checkTrophyCondition(index) {
    const avg = responseTimes.length ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
    if (index === 0) return avg < 1500;
    if (index === 1) return avg < 1000;
    if (index === 2) return avg < 900;
    if (index === 3) return avg < 800;
    if (index === 4) return avg < 400;

    if (index >= 5 && index <= 9) {
      const ranges = ["C", "D", "F", "G", "MC"];
      const range = ranges[index - 5];
      return rangeNotes[range].every(note => !errorNotes.some(e => e.note === note));
    }

    const streak = Number(localStorage.getItem("streak") || 0);
    const thresholds = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
    if (index >= 10 && index <= 19) return streak >= thresholds[index - 10];

    if (index >= 20 && index <= 24) {
      const avgSwitch = responseTimes.length > 10 ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
      return avgSwitch < (1500 - (index - 20) * 200);
    }

    if (index >= 25 && index <= 29) {
      if (!metronomeOn) return false;
      const maxDev = Math.max(...responseTimes.map(t => Math.abs(t - metronomeInterval)));
      const devPercent = maxDev / metronomeInterval;
      const limits = [0.3, 0.2, 0.15, 0.1, 0.05];
      return devPercent < limits[index - 25];
    }

    return false;
  }
function getTrophyDescription(index) {
const descriptions = [
"Durchschnittliche Reaktionszeit unter 1,5 Sekunden",
"Durchschnittliche Reaktionszeit unter 1 Sekunde",
"Durchschnittliche Reaktionszeit unter 0,9 Sekunden",
"Durchschnittliche Reaktionszeit unter 0,8 Sekunden",
"Durchschnittliche Reaktionszeit unter 0,4 Sekunden",
"Fehlerfrei in der C-Lage",
"Fehlerfrei in der D-Lage",
"Fehlerfrei in der F-Lage",
"Fehlerfrei in der G-Lage",
"Fehlerfrei in der MC-Lage",
"Streak von mindestens 2 Tagen",
"Streak von mindestens 3 Tagen",
"Streak von mindestens 5 Tagen",
"Streak von mindestens 8 Tagen",
"Streak von mindestens 13 Tagen",
"Streak von mindestens 21 Tagen",
"Streak von mindestens 34 Tagen",
"Streak von mindestens 55 Tagen",
"Streak von mindestens 89 Tagen",
"Streak von mindestens 144 Tagen",
"Schneller Lagenwechsel (Stufe 1)",
"Schneller Lagenwechsel (Stufe 2)",
"Schneller Lagenwechsel (Stufe 3)",
"Schneller Lagenwechsel (Stufe 4)",
"Schneller Lagenwechsel (Stufe 5)",
"Taktgef√ºhl: Abweichung <30%",
"Taktgef√ºhl: Abweichung <20%",
"Taktgef√ºhl: Abweichung <15%",
"Taktgef√ºhl: Abweichung <10%",
"Taktgef√ºhl: Abweichung <5%"
];
return descriptions[index] || "";
}
                                        
function generateBarChartHTML() {
// Standardwerte: Jeder Tag wird initial auf 0 gesetzt.
const dayCounts = { Mo: 0, Di: 0, Mi: 0, Do: 0, Fr: 0, Sa: 0, So: 0 };

// Z√§hle √ñffnungszeiten
const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
openTimes.forEach(timeStr => {
const d = new Date(timeStr);
const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
if (dayCounts.hasOwnProperty(day)) {
  dayCounts[day]++;
}
});

// Z√§hle Session-Zeitpunkte
const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
sessionTimes.forEach(timeStr => {
const d = new Date(timeStr);
const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
if (dayCounts.hasOwnProperty(day)) {
  dayCounts[day]++;
}
});

const days = ["Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"];
const maxVal = Math.max(...Object.values(dayCounts), 1);

// Erstelle Container als Flex-Layout f√ºr das Balkendiagramm
const container = document.createElement("div");
container.className = "bar-chart-container";

days.forEach(day => {
const val = dayCounts[day] || 0;
const barItem = document.createElement("div");
barItem.className = "bar-item";

const bar = document.createElement("div");
bar.className = "bar";
const height = Math.round((val / maxVal) * 100);
bar.style.height = `${height}px`;

const label = document.createElement("div");
label.className = "bar-label";
label.textContent = day;

barItem.appendChild(bar);
barItem.appendChild(label);
container.appendChild(barItem);
});

return container.outerHTML;
}
  
  


function calculateAdaptiveBreakTime(responseTimes, hitRate) {
// Berechne die durchschnittliche Antwortzeit in Millisekunden
let avgResponse = responseTimes.length > 0
? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
: 1000;
// Verwende hitRate (Erfolgsquote), um die Pausendauer anzupassen:
// Eine niedrigere Erfolgsquote (mehr Fehler) f√ºhrt zu l√§ngeren Pausen.
return avgResponse * (1 + (1 - hitRate));
}
  
const startPauseCountdown = () => {
logSessionStart(); // Neuen Session-Zeitstempel speichern
if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
window.webkit.messageHandlers.gameCenter.postMessage({
  type: "highscore",
  value: {
    accuracy: Math.round((correctAnswers / totalAttempts) * 100),
    duration: Math.floor((Date.now() - appStartTime) / 1000),
    mode: randomMode ? "random" : selectedMode
  }
});
}
const quote = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
const speed = responseTimes.length > 0
? Math.round(responseTimes.reduce((a, b) => a + b) / responseTimes.length)
: 0;
if (!userID) {
console.error("Keine userID gesetzt! Abbruch.");
return;
}
const timerElem = document.getElementById("timerContainer");
const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
if (
isiOS &&
timerElem &&
window.webkit &&
window.webkit.messageHandlers &&
window.webkit.messageHandlers.gameCenter
) {
timerElem.textContent = "Speichere Daten in GameCenter...";
setTimeout(() => {
  startRealPauseCountdown(); // Startet den eigentlichen Countdown
}, 2000);
return;
}

  stopMetronome();
  sessionPaused = true;
  sessionCount++;
  const hitRate = totalAttempts > 0 ? (correctAnswers / totalAttempts) : 1;
  pauseRemaining = Math.floor(calculateAdaptiveBreakTime(responseTimes, hitRate) * 2 + 300);
  pauseDuration = pauseRemaining;

  const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
  const previousTrophies = JSON.parse(sessionStorage.getItem("previousUnlockedTrophies") || "[]");
  
  const justUnlocked = unlockedTrophies.filter(index => !previousTrophies.includes(index));
  const justLost = previousTrophies.filter(index => !unlockedTrophies.includes(index));
  
  sessionStorage.setItem("justUnlockedTrophies", JSON.stringify(justUnlocked));
  sessionStorage.setItem("justLostTrophies", JSON.stringify(justLost));
  sessionStorage.setItem("previousUnlockedTrophies", JSON.stringify(unlockedTrophies));
  
  const pauseOverlay = document.getElementById("pauseOverlay");
  pauseOverlay.innerHTML = `
      <div id="pauseInfo">
        <div id="pauseHeader">SESSION PAUSIERT</div>
        <div id="pauseProgressContainer">
          <div id="pauseProgress"></div>
          <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
          <div id="remainingNotesDisplay">${sessionCounter}</div>
        </div>
      </div>
      <div id="pauseTiles"></div>
    `;
  document.getElementById("mainContent").style.display = "none";
  document.getElementById("timerContainer").style.display = "none";
  document.getElementById("settingsPanel").style.display = "none";
  pauseOverlay.style.display = "flex";
  confetti({
    particleCount: 150,
    spread: 70,
    origin: { x: 0.5, y: 0.5 }
  });
  updatePauseProgress();
  updatePauseTiles();
  const msgInterval = setInterval(() => { updatePauseTiles(); }, 3000);
  pauseInterval = setInterval(() => {
    pauseRemaining--;
    updatePauseProgress();
    if (pauseRemaining <= 0) {
      clearInterval(pauseInterval);
      clearInterval(msgInterval);
      endPause();
    }
  }, 1000);
};
  
  // Erstelle ein Audio-Objekt f√ºr den Gong
  const gongSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/gong-2-232435.mp3");
  
  // In deiner Funktion, die das Pausenfenster beendet, rufe den Sound ab:
  const endPause = () => {
    document.getElementById("pauseOverlay").style.display = "none";
    document.getElementById("mainContent").style.display = "block";
    document.getElementById("timerContainer").style.display = "flex";
    document.getElementById("settingsPanel").style.display = "flex";
    sessionPaused = false;
    // Setze den Sound zur√ºck und spiele ihn ab
    gongSound.currentTime = 0;
    gongSound.play();
    resetGame();
  };
let gameOver = false;
const endGame = () => {
  gameOver = true;
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  gameOverOverlay.textContent = "Game Over!";
  gameOverOverlay.style.display = "block";
  if (!scoreRecorded) recordScore();
  setTimeout(resetGame, 5000);
};
const recordScore = () => {
  if (totalAttempts <= 0) return;
  const durationMs = Date.now() - appStartTime;
  const secondsTotal = Math.floor(durationMs / 1000);
  const minutes = Math.floor(secondsTotal / 60);
  const seconds = secondsTotal % 60;
  const durationStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
  const accuracy = Math.round((correctAnswers / totalAttempts) * 100);
  const now = new Date();
  let dd = now.getDate();
  let mm = now.getMonth() + 1;
  dd = dd < 10 ? "0" + dd : dd;
  mm = mm < 10 ? "0" + mm : mm;
  const dateStr = dd + "." + mm;
  const scoreObj = { date: dateStr, accuracy: accuracy, duration: durationStr, seconds: secondsTotal, mode: randomMode ? "random" : selectedMode };
  let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
  highScores.push(scoreObj);
  highScores.sort((a, b) => (b.accuracy !== a.accuracy ? b.accuracy - a.accuracy : a.seconds - b.seconds));
  highScores = highScores.slice(0, 5);
  localStorage.setItem("highScores", JSON.stringify(highScores));
  scoreRecorded = true;
};
const updateScoreboard = () => {
  const allScores = JSON.parse(localStorage.getItem("highScores") || "[]");
  const filtered = allScores.filter(score => score.mode === (randomMode ? "random" : selectedMode));
  let html = "HIGHSCORES (" + (randomMode ? "random" : selectedMode) + ")\n";
  filtered.forEach((score, index) => {
    html += (index + 1) + ". " + score.date + " \t " + score.accuracy + "% " + score.duration + "\n";
  });
  document.getElementById("scoreboardOverlay").textContent = html;
};
const toggleScoreboard = () => {
  const overlay = document.getElementById("scoreboardOverlay");
  overlay.classList.toggle("hidden");
  if (!overlay.classList.contains("hidden")) updateScoreboard();
};
const autoSelectMode = () => {
  let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
  const leftScores = highScores.filter(score => score.mode === "left");
  const rightScores = highScores.filter(score => score.mode === "right");
  const bestLeft = leftScores.length ? Math.max(...leftScores.map(s => s.accuracy)) : 0;
  const bestRight = rightScores.length ? Math.max(...rightScores.map(s => s.accuracy)) : 0;
  if (bestLeft < bestRight) {
    selectedMode = "left";
    currentHandIndex = 0;
  } else {
    selectedMode = "left";
    currentHandIndex = 0;
  }
  const handToggle = document.getElementById("handToggle");
  if (handToggle) {
    handToggle.textContent = handOptions[currentHandIndex].symbol;
    handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
  }
};
function formatAccidentalName(raw) {
  if (raw.endsWith("#")) return raw.slice(0, -1) + "‚ôØ";
  if (raw.endsWith("b")) return raw.slice(0, -1) + "‚ô≠";
  return raw;
}
const cycleRange = () => {
  window.customModeSettings = null;
  currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
  currentRange = rangeArray[currentRangeIndex];
  document.getElementById("clefTitle").textContent = formatAccidentalName(currentRange);
  generateSeries();
  updateHeartsDisplay();
};

// Passive Listener f√ºr Touch-Events in setupFadeOnHover
const setupFadeOnHover = (element) => {
  element.addEventListener("mouseenter", () => element.classList.remove("faded"));
  element.addEventListener("mouseleave", () => element.classList.add("faded"));
  element.addEventListener("touchstart", () => element.classList.remove("faded"), {passive: true});
  element.addEventListener("touchend", () => element.classList.add("faded"), {passive: true});
};
let redrawQueued = false;
const queueRedraw = () => {
  if (!redrawQueued) {
    redrawQueued = true;
    requestAnimationFrame(() => {
      drawSeries();
      redrawQueued = false;
    });
  }
};
/* Animation (Hintergrund-Kreise) */
let blobsEnabled = true;
let circles = [];
const gradients = {
  "green": ["rgba(0,255,0,1)", "rgba(0,255,0,0.3)", "rgba(255,255,255,0)"],
  "blue": ["rgba(0,0,255,1)", "rgba(0,0,255,0.3)", "rgba(255,255,255,0)"],
  "pink": ["rgba(255,105,180,1)", "rgba(255,105,180,0.3)", "rgba(255,255,255,0)"],
  "yellow": ["rgba(255,255,0,1)", "rgba(255,255,0,0.3)", "rgba(255,255,255,0)"],
  "red": ["rgba(255,0,0,1)", "rgba(255,0,0,0.3)", "rgba(255,255,255,0)"],
  "violet": ["rgba(238,130,238,1)", "rgba(238,130,238,0.3)", "rgba(255,255,255,0)"],
  "gray": ["rgba(128,128,128,1)", "rgba(128,128,128,0.3)", "rgba(255,255,255,0)"],
  "black": ["rgba(0,0,0,1)", "rgba(0,0,0,0.3)", "rgba(255,255,255,0)"]
};
const positiveColors = ["green", "blue", "pink", "yellow"];
const negativeColors = ["orange", "violet", "crimson"];
function addCircle(type) {
  if (!blobsEnabled) return;
  const canvas = document.getElementById("animationCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const cw = canvas.width, ch = canvas.height;
  const margin = 10;
  const x = Math.random() * (cw - 2 * margin) + margin;
  const y = Math.random() * (ch - 2 * margin) + margin;
  const radius = Math.random() * 1000 + 800;
  const colors = type === "positive" ? positiveColors : negativeColors;
  const colorName = colors[Math.floor(Math.random() * colors.length)];
  const creationTime = Date.now();
  const duration = 2000;
  circles.push({ x, y, radius, color: colorName, creationTime, duration });
}
/* Intro-Animation */
function spawnIntroBlobs() {
  const canvas = document.getElementById("animationCanvas");
  if (!canvas) return;
  const cw = canvas.width, ch = canvas.height;
  const positions = [
    { x: cw - 500, y: 100 },
    { x: cw - 30, y: ch - 30 },
    { x: 50, y: ch / 2 }
  ];
  const colors = ["yellow", "pink", "blue"];
  positions.forEach((pos, index) => {
    const targetRadius = Math.random() * 1000 + 1000;
    const duration = 5000;
    circles.push({
      x: pos.x,
      y: pos.y,
      initialRadius: targetRadius,
      radius: targetRadius,
      color: colors[index % colors.length],
      creationTime: Date.now(),
      duration: duration
    });
  });
}
function animateCircles() {
  const canvas = document.getElementById("animationCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const now = Date.now();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  circles = circles.filter(circle => {
    const t = now - circle.creationTime;
    if (t >= circle.duration) return false;
    let opacity = 0;
    if (t < 500) { opacity = t / 500; }
    else if (t < 1500) { opacity = 1; }
    else { opacity = (circle.duration - t) / 500; }
    let currentRadius = circle.radius;
    const gradColors = gradients[circle.color] || [circle.color, circle.color, "rgba(255,255,255,0)"];
    const grad = ctx.createRadialGradient(circle.x, circle.y, 0, circle.x, circle.y, currentRadius);
    grad.addColorStop(0, gradColors[0]);
    grad.addColorStop(0.7, gradColors[1]);
    grad.addColorStop(1, gradColors[2]);
    ctx.globalAlpha = opacity;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, currentRadius, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.globalAlpha = 1;
    return true;
  });
  requestAnimationFrame(animateCircles);
}
function resetInactivityTimer() {
  if (inactivityTimeout) clearTimeout(inactivityTimeout);
  inactivityTimeout = setTimeout(spawnInactivityBlob, 180000);
}
function spawnInactivityBlob() {
  const canvas = document.getElementById("animationCanvas");
  if (!canvas) return;
  const cw = canvas.width, ch = canvas.height;
  const margin = 10;
  const x = Math.random() * (cw - 2 * margin) + margin;
  const y = Math.random() * (ch - 2 * margin) + margin;
  const radius = Math.random() * 1000 + 800;
  const colors = ["green", "blue", "pink", "yellow"];
  const colorName = colors[Math.floor(Math.random() * colors.length)];
  const creationTime = Date.now();
  const duration = 2000;
  circles.push({ x, y, radius, color: colorName, creationTime, duration });
  resetInactivityTimer();
}
document.addEventListener("DOMContentLoaded", () => {
  let canvas = document.getElementById("animationCanvas");
  // --- Apply saved notation position from localStorage ---
  const savedTransform = localStorage.getItem("notationTransform");
  if (savedTransform) {
    const notation = document.getElementById("notation");
    if (notation) {
      notation.style.position = "fixed";
      notation.style.top = "50%";
      notation.style.left = "50%";
      notation.style.transform = savedTransform;
    }
  }
  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.id = "animationCanvas";
    document.body.appendChild(canvas);
  }
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);
  animateCircles();
  resetInactivityTimer();
  const welcomeMessage = document.getElementById("welcomeMessage");
  const hour = new Date().getHours();
  let greeting;
  if (hour >= 6 && hour < 12) {
    greeting = "Guten Morgen";
  } else if (hour >= 12 && hour < 17) {
    greeting = "Guten Tag";
  } else {
    greeting = "Guten Abend";
  }
  const storedName = localStorage.getItem("userName") || "Gast";
  welcomeMessage.innerHTML = `${greeting}, ${storedName}<br>Willkommen zur√ºck.<br>`;
  if (storedName !== null) {
    welcomeMessage.innerHTML = `${greeting}, ${storedName || ""}<br> Willkommen zur√ºck.<br>`;
    welcomeMessage.style.cursor = "pointer";
    welcomeMessage.addEventListener("click", () => {
      const storedName = localStorage.getItem("userName");
      if (storedName !== null) {
        const nameOverlay = document.createElement("div");
        nameOverlay.id = "nameOverlay";
        nameOverlay.style.position = "fixed";
        nameOverlay.style.top = "0";
        nameOverlay.style.left = "0";
        nameOverlay.style.width = "100%";
        nameOverlay.style.height = "100%";
        nameOverlay.style.backgroundColor = "rgba(255,255,255,0.95)";
        nameOverlay.style.display = "flex";
        nameOverlay.style.justifyContent = "center";
        nameOverlay.style.alignItems = "center";
        nameOverlay.style.zIndex = "9999";
        nameOverlay.style.pointerEvents = "auto";

        const modal = document.createElement("div");
        modal.style.background = "#fff";
        modal.style.padding = "20px";
        modal.style.border = "2px solid #000";
        modal.style.borderRadius = "10px";
        modal.style.textAlign = "center";

        const label = document.createElement("label");
        label.textContent = "Wie hei√üt du?";
        label.style.fontSize = "1.5em";

        const input = document.createElement("input");
        input.type = "text";
        input.value = storedName;
        input.style.display = "block";
        input.style.margin = "15px auto";
        input.style.fontSize = "1.2em";
        input.style.padding = "5px";
        input.style.pointerEvents = "auto";
        input.tabIndex = 0;
        // Prevent typing in name input from affecting the game
        input.addEventListener('keydown', e => e.stopPropagation());
        input.addEventListener('keyup',   e => e.stopPropagation());
        input.addEventListener('keypress',e => e.stopPropagation());
        input.addEventListener('input',   e => e.stopPropagation());

        const button = document.createElement("button");
        button.textContent = "Speichern";
        button.style.padding = "10px 20px";
        button.style.border = "2px solid #000";
        button.style.borderRadius = "5px";
        button.style.backgroundColor = "#fff";
        button.style.color = "#000";
        button.style.cursor = "pointer";

        const skip = document.createElement("button");
        skip.textContent = "Keinen Namen anzeigen";
        skip.style.padding = "10px 20px";
        skip.style.border = "2px solid #000";
        skip.style.borderRadius = "5px";
        skip.style.backgroundColor = "#fff";
        skip.style.color = "#000";
        skip.style.cursor = "pointer";

        button.addEventListener("click", () => {
          localStorage.setItem("userName", input.value.trim());
          document.body.removeChild(nameOverlay);
          location.reload();
        });

        skip.addEventListener("click", () => {
          localStorage.setItem("userName", "");
          document.body.removeChild(nameOverlay);
          location.reload();
        });

        modal.appendChild(label);
        modal.appendChild(input);
        modal.appendChild(button);
        modal.appendChild(skip);
        nameOverlay.appendChild(modal);
        document.body.appendChild(nameOverlay);
      }
    });
    welcomeMessage.style.fontSize = "2em";
    setTimeout(proceedToMainScreen, 5000);
  } else {
    document.getElementById("mainContent").style.opacity = "0";
    document.getElementById("timerContainer").style.opacity = "0";
    document.getElementById("settingsPanel").style.opacity = "0";

    const nameOverlay = document.createElement("div");
    nameOverlay.id = "nameOverlay";
    nameOverlay.style.position = "fixed";
    nameOverlay.style.top = "0";
    nameOverlay.style.left = "0";
    nameOverlay.style.width = "100%";
    nameOverlay.style.height = "100%";
    nameOverlay.style.backgroundColor = "rgba(255,255,255,0.95)";
    nameOverlay.style.display = "flex";
    nameOverlay.style.justifyContent = "center";
    nameOverlay.style.alignItems = "center";
    nameOverlay.style.zIndex = "9999";
    nameOverlay.style.pointerEvents = "auto";

    const modal = document.createElement("div");
    modal.style.background = "#fff";
    modal.style.padding = "20px";
    modal.style.border = "2px solid #000";
    modal.style.borderRadius = "10px";
    modal.style.textAlign = "center";

    const label = document.createElement("label");
    label.textContent = "Wie hei√üt du?";
    label.style.fontSize = "1.5em";

    const input = document.createElement("input");
    input.type = "text";
    input.style.display = "block";
    input.style.margin = "15px auto";
    input.style.fontSize = "1.2em";
    input.style.padding = "5px";
    input.style.pointerEvents = "auto";
    input.tabIndex = 0;
    // Prevent typing in name input from affecting the game
    input.addEventListener('keydown', e => e.stopPropagation());
    input.addEventListener('keyup',   e => e.stopPropagation());
    input.addEventListener('keypress',e => e.stopPropagation());
    input.addEventListener('input',   e => e.stopPropagation());

    const button = document.createElement("button");
    button.textContent = "Weiter";
    button.style.fontSize = "1em";
    button.style.marginRight = "10px";
    button.style.padding = "10px 20px";
    button.style.border = "none";
    button.style.borderRadius = "5px";
    button.style.backgroundColor = "#fff";
    button.style.color = "#000";
    button.style.border = "2px solid #000";
    button.disabled = true;
    button.style.opacity = "0.8";
    
    input.addEventListener("input", () => {
      const hasText = input.value.trim().length > 0;
      button.disabled = !hasText;
      button.style.opacity = hasText ? "1" : "0.8";
    });

    const skip = document.createElement("button");
    skip.textContent = "Keinen Namen angeben";
    skip.style.fontSize = "1em";
    skip.style.padding = "10px 20px";
    skip.style.border = "none";
    skip.style.borderRadius = "5px";
    skip.style.backgroundColor = "#fff";
    skip.style.color = "#000";
    skip.style.border = "2px solid #000";

    button.addEventListener("click", () => {
      localStorage.setItem("userName", input.value.trim());
      document.body.removeChild(nameOverlay);
      proceedToMainScreen();
      document.getElementById("mainContent").style.opacity = "1";
      document.getElementById("timerContainer").style.opacity = "1";
      document.getElementById("settingsPanel").style.opacity = "1";
    });

    skip.addEventListener("click", () => {
      localStorage.setItem("userName", "");
      document.body.removeChild(nameOverlay);
      proceedToMainScreen();
      document.getElementById("mainContent").style.opacity = "1";
      document.getElementById("timerContainer").style.opacity = "1";
      document.getElementById("settingsPanel").style.opacity = "1";
    });

    modal.appendChild(label);
    modal.appendChild(input);
    modal.appendChild(button);
    modal.appendChild(skip);
    nameOverlay.appendChild(modal);
    document.body.appendChild(nameOverlay);
  }
  
  const settingsPanel = document.getElementById("settingsPanel");
  // Handtoggle
  const handToggle = document.createElement("span");
  handToggle.id = "handToggle";
  handToggle.textContent = handOptions[currentHandIndex].symbol;
  handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
  settingsPanel.appendChild(handToggle);
  handToggle.addEventListener("click", () => {
    if (!randomMode) {
      currentHandIndex = (currentHandIndex + 1) % handOptions.length;
      selectedMode = handOptions[currentHandIndex].mode;
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      window.customModeSettings = null;
      generateSeries();
    }
  });
  
  const playerToggle = document.createElement("span");
  playerToggle.id = "playerToggle";
  playerToggle.textContent = "ü§ù";
  settingsPanel.appendChild(playerToggle);
  playerToggle.addEventListener("click", () => {
    document.getElementById("notation").style.display = "none";
    showPlayerList();
  });
  // (Optional) Remove or comment out the separate ‚ûï button outside the list, since "+" is now part of the list.
  // const addPlayerToggle = document.createElement("span");
  // addPlayerToggle.id = "addPlayerToggle";
  // addPlayerToggle.textContent = "‚ûï";
  // settingsPanel.appendChild(addPlayerToggle);
  // addPlayerToggle.addEventListener("click", () => {
  //   const name = prompt("Neuer Spielername:");
  //   if (name && name.trim()) {
  //     const trimmed = name.trim();
  //     const existing = JSON.parse(localStorage.getItem("playerStats") || "{}");
  //     if (!existing[trimmed]) {
  //       existing[trimmed] = {};
  //       localStorage.setItem("playerStats", JSON.stringify(existing));
  //     }
  //     localStorage.setItem("userName", trimmed);
  //     location.reload();
  //   }
  // });
// Spieler-Liste anzeigen mit Tabelle und "+" Button am Ende
function showPlayerList() {
  // Spielerstatistiken aus dem LocalStorage laden
  const stats = JSON.parse(localStorage.getItem("playerStats") || "{}");
  const players = Object.keys(stats).map(name => ({
    name,
    avg: stats[name]?.avg !== undefined ? stats[name].avg : "-"
  }));
  const overlay = document.createElement("div");
  overlay.id = "playerListOverlay";
  overlay.style.position = "fixed";
  overlay.style.top = "0";
  overlay.style.left = "0";
  overlay.style.width = "100vw";
  overlay.style.height = "100vh";
  overlay.style.background = "rgba(255,255,255,0.97)";
  overlay.style.zIndex = "99999";
  overlay.style.display = "flex";
  overlay.style.justifyContent = "center";
  overlay.style.alignItems = "center";
  overlay.style.pointerEvents = "auto";
  overlay.innerHTML = `
    <div style="background:#fff; padding:20px; border:2px solid #000; border-radius:10px; text-align:center; max-width:400px; width:90%;">
      <h2 style="margin-bottom:10px;">Highscores</h2>
      <table style="width:100%; border-collapse:collapse; font-size:1.1em;">
        <thead>
          <tr>
            <th style="border-bottom:1px solid #000; padding:8px;">Name</th>
            <th style="border-bottom:1px solid #000; padding:8px;">√ò-Score (%)</th>
          </tr>
        </thead>
        <tbody>
          ${
            players.map(p => `
              <tr style="cursor:pointer;" onclick="selectPlayer('${p.name}')" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'">
                <td style="padding:8px; border-bottom:1px solid #ccc;">${p.name}</td>
                <td style="padding:8px; border-bottom:1px solid #ccc;">${p.avg}</td>
              </tr>
            `).join("")
          }
          <tr style="cursor:pointer; background-color:#eef;" onclick="createNewPlayerFromList()" onmouseover="this.style.background='#ddeeff'" onmouseout="this.style.background='#eef'">
            <td colspan="2" style="text-align:center; padding:12px; font-weight:bold;">‚ûï Neuen Spieler anlegen</td>
          </tr>
        </tbody>
      </table>
      <button onclick="closePlayerList()" style="margin-top:15px; padding:8px 16px; border:2px solid #000; border-radius:6px; background:#fff; cursor:pointer;">Zur√ºck</button>
    </div>
  `;
  // Remove any previous overlays
  document.querySelectorAll("#playerListOverlay").forEach(el => el.remove());
  document.body.appendChild(overlay);
}

// Spieler-Auswahl
function selectPlayer(name) {
  localStorage.setItem("userName", name);
  closePlayerList();
  location.reload();
}

// "+" Button in der Liste: Neuen Spieler anlegen
function createNewPlayerFromList() {
  const name = prompt("Neuer Spielername:");
  if (name && name.trim()) {
    const trimmed = name.trim();
    const existing = JSON.parse(localStorage.getItem("playerStats") || "{}");
    if (!existing[trimmed]) {
      existing[trimmed] = {};
      localStorage.setItem("playerStats", JSON.stringify(existing));
    }
    localStorage.setItem("userName", trimmed);
    closePlayerList();
    location.reload();
  }
}

function closePlayerList() {
  const overlay = document.getElementById("playerListOverlay");
  if (overlay) overlay.parentElement.removeChild(overlay);
  // Notation ggf. wieder anzeigen
  const notation = document.getElementById("notation");
  if (notation) notation.style.display = "";
}
  // Zeichne den Crayon-Button f√ºr Scale-Modus
  const customModeToggle = document.createElement("span");
  customModeToggle.id = "customModeToggle";
  customModeToggle.textContent = "üñçÔ∏è";
  customModeToggle.style.cursor = "pointer";
  customModeToggle.style.marginTop = "10px";
  settingsPanel.appendChild(customModeToggle);
  // Buttons f√ºr Reset und Speichern im Scale-Modus
  const resetScaleBtn = document.createElement("span");
  resetScaleBtn.id = "resetScaleBtn";
  resetScaleBtn.textContent = "üîÅ";
  resetScaleBtn.style.cursor = "pointer";
  resetScaleBtn.style.display = "none";
  settingsPanel.appendChild(resetScaleBtn);
  resetScaleBtn.addEventListener("click", () => {
    // Reset selection mode and clear stored notes for this octave
    scaleSelectionMode = true;
    if (window.selectedNotesByOctave) {
      window.selectedNotesByOctave[selectedOctave] = [];
    }
    selectedNotes = [];
    // Entferne visuelle Selektion in der SVG
    document.querySelectorAll("svg g.vf-stavenote.selected").forEach(svgNote => {
      svgNote.classList.remove("selected");
      // Reset color to black
      svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
        shape.setAttribute('fill', 'black');
        shape.setAttribute('stroke', 'black');
      });
    });
    // Skala neu anzeigen
    generateScaleSeries(false);
  });
  
  
  const saveScaleBtn = document.createElement("span");
  saveScaleBtn.id = "saveScaleBtn";
  saveScaleBtn.textContent = "‚úÖ";
  saveScaleBtn.style.cursor = "pointer";
  saveScaleBtn.style.display = "none";
  settingsPanel.appendChild(saveScaleBtn);
  saveScaleBtn.addEventListener("click", () => {
    // Wechsle in Final-Phase und starte unendliche Serie
    scaleSelectionMode = false;
    resetScaleBtn.style.display = "none";
    saveScaleBtn.style.display = "none";
    // Merge all per-octave selections into global selectedNotes
    if (window.selectedNotesByOctave) {
      selectedNotes = [].concat(...Object.values(window.selectedNotesByOctave));
    }
    // Hide octave selector on save
    const sel = document.getElementById("scaleSelector");
    if (sel) sel.style.display = "none";
    generateScaleSeries(true);
  });

  // Oktavenauswahl-Container
  const scaleSelector = document.createElement("div");
  scaleSelector.id = "scaleSelector";
  scaleSelector.style.display = "none";
  scaleSelector.style.gap = "8px";
  settingsPanel.appendChild(scaleSelector);

  // Buttons f√ºr jede Oktave
  Object.keys(octaveOptions).forEach(label => {
    const btn = document.createElement("button");
    btn.textContent = label;
    btn.style.cursor = "pointer";
    btn.addEventListener("click", () => {
      // Setze Octave und passenden Clef: tiefe Oktaven links (Bass), hohe Oktaven rechts (Treble)
      selectedOctave = label;
      if (label === 'gro√üe Oktave' || label === 'kleine Oktave') {
        selectedClef = 'bass';
      } else {
        selectedClef = 'treble';
      }
      // Anzeige und Rendern aktualisieren
      const sel = document.getElementById("scaleSelector");
      if (sel) sel.style.display = "flex";
      generateScaleSeries(false);
    });
    scaleSelector.appendChild(btn);
  });

  customModeToggle.addEventListener("click", () => {
    // Toggle zwischen Auswahl- und Final-Phase im Scale-Modus
    if (!scaleSelectionMode) {
      // Auswahlphase starten
      selectedMode = "scale";
      scaleSelectionMode = true;
      sessionPaused = false;
      seriesCounter = 0;
      correctNoteCount = 0;
      // Timer anzeigen und aktualisieren
      document.getElementById("timerContainer").style.display = "flex";
      updateTimer();
      // Module ausblenden, Settings sichtbar
      const modeCarousel = document.getElementById("modeCarousel");
      if (modeCarousel) modeCarousel.style.display = "none";
      document.getElementById("settingsPanel").style.display = "flex";
      // Tonleiter zur Auswahl anzeigen
      generateScaleSeries(false);
      resetScaleBtn.style.display = "inline";
      saveScaleBtn.style.display = "inline";
      scaleSelector.style.display = "flex";
    } else {
      // Finalphase: fortlaufende Serie generieren
      scaleSelector.style.display = "none";
      scaleSelectionMode = false;
      generateScaleSeries(true);
      resetScaleBtn.style.display = "none";
      saveScaleBtn.style.display = "none";
    }
  });
  
  // Randomtoggle
  const randomToggle = document.createElement("span");
  randomToggle.id = "randomToggle";
  randomToggle.textContent = "üêá";
  settingsPanel.appendChild(randomToggle);
  randomToggle.addEventListener("click", () => {
    randomMode = !randomMode;
    randomToggle.style.opacity = randomMode ? "1" : "0.5";
    generateSeries();
  });
  

  
  function showHomework() {
    let modal = document.getElementById("homeworkModal");
    if (!modal) {
      modal = document.createElement("div");
      modal.id = "homeworkModal";
      Object.assign(modal.style, {
        position: "fixed", top:"35%", right:"90px", width:"300px",
        background:"white", border:"2px solid black", borderRadius:"10px",
        padding:"20px", zIndex:"150"
      });
      document.body.appendChild(modal);
    }
    // Dynamisch Titel/Beschreibung w√§hlen
    // Automatischer Scan bei leerer Hausaufgabe
    if (!homeworkData) {
      openCameraScan().then(code => {
        if (code && code.data) {
          try {
            homeworkData = JSON.parse(code.data);
            localStorage.setItem("homeworkData", JSON.stringify(homeworkData));
          } catch {
            alert("Ung√ºltiger QR-Code");
          }
        }
        showHomework();
      }).catch(() => {
        // Scan abgebrochen oder Fehler ‚Äì trotzdem das Modal anzeigen
        showHomework();
      });
      return;
    }
    const title = homeworkData?.HA || "Keine HA";
    const desc  = homeworkData?.Beschreibung || "";
    modal.innerHTML = `
      <h2>Hausaufgabe</h2>
      <p><strong>Titel:</strong> ${title}</p>
      <p><strong>Beschreibung:</strong> ${desc}</p>
      <button id="hwReceive">HA erhalten</button>
      <button id="hwSend">HA senden</button>
    `;
    // Button-Listener
    document.getElementById("hwReceive").addEventListener("click", () => {
      openCameraScan().then(code => {
        if (code && code.data) {
          try {
            homeworkData = JSON.parse(code.data);
            localStorage.setItem("homeworkData", JSON.stringify(homeworkData));
          } catch {
            alert("Ung√ºltiger QR-Code");
          }
        }
        showHomework();
      });
    });
  // Overlay Camera Scan: openCameraScan implementation
  function openCameraScan() {
    return new Promise((resolve, reject) => {
      // Create overlay
      let scanOverlay = document.createElement("div");
      Object.assign(scanOverlay.style, {
        position: "fixed", top:"20%", left:"10%", width:"80%", height:"60%",
        background:"rgba(0,0,0,0.8)", display:"flex", alignItems:"center", justifyContent:"center", zIndex:"2000"
      });
      scanOverlay.id = "scanOverlay";
      // Create video element
      let video = document.createElement("video");
      video.setAttribute("autoplay", true);
      video.setAttribute("playsinline", true);
      video.style.width = "100%";
      video.style.height = "100%";
      video.style.objectFit = "cover";
      // Add close button
      let closeBtn = document.createElement("button");
      closeBtn.textContent = "Abbrechen";
      closeBtn.style.position = "absolute";
      closeBtn.style.top = "10px";
      closeBtn.style.right = "10px";
      closeBtn.style.zIndex = "2100";
      closeBtn.style.padding = "8px 16px";
      closeBtn.style.background = "white";
      closeBtn.style.border = "1px solid #000";
      closeBtn.style.borderRadius = "6px";
      closeBtn.style.cursor = "pointer";
      closeBtn.addEventListener("click", () => {
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.stop());
        }
        document.body.removeChild(scanOverlay);
        reject(new Error("Scan cancelled"));
      });
      scanOverlay.appendChild(video);
      scanOverlay.appendChild(closeBtn);
      document.body.appendChild(scanOverlay);
      // Access camera
      navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(stream => {
        video.srcObject = stream;
        // Use a QR scanner library or implement simple scanning
        // For now, simulate scan after 3 seconds
        // In real code, integrate a QR code library such as jsQR or html5-qrcode
        setTimeout(() => {
          // Stop camera
          stream.getTracks().forEach(track => track.stop());
          document.body.removeChild(scanOverlay);
          // Simulate a QR result object
          resolve({ data: '{"HA":"Beispiel","Beschreibung":"Test"}' });
        }, 3000);
      }).catch(err => {
        document.body.removeChild(scanOverlay);
        alert("Kamera konnte nicht ge√∂ffnet werden: " + err);
        reject(err);
      });
    });
  }
    document.getElementById("hwSend").addEventListener("click", () => {
      modal.innerHTML = `
        <h2>Hausaufgabe erstellen</h2>
        <label>Titel:<br><input id="newHA" value="${homeworkData?.HA||""}"></label><br>
        <label>Beschreibung:<br><textarea id="newDesc">${homeworkData?.Beschreibung||""}</textarea></label><br>
        <button id="generateQR">QR-Code erstellen</button>
      `;
      // Prevent HA input from affecting the notation/game
      const haInput = document.getElementById("newHA");
      const descInput = document.getElementById("newDesc");
      [haInput, descInput].forEach(el => {
        el.addEventListener('keydown', e => e.stopPropagation());
        el.addEventListener('keyup',   e => e.stopPropagation());
        el.addEventListener('keypress',e => e.stopPropagation());
        el.addEventListener('input',   e => e.stopPropagation());
      });
      document.getElementById("generateQR").addEventListener("click", () => {
        const obj = { HA: document.getElementById("newHA").value, Beschreibung: document.getElementById("newDesc").value };
        modal.innerHTML = `<div id="qrContainer"></div>`;
        new QRCode(document.getElementById("qrContainer"), { text: JSON.stringify(obj), width:200, height:200 });
        localStorage.setItem("homeworkData", JSON.stringify(obj));
      });
    });
  }

  // Called by Swift after scanning QR code
  function handleIncomingHomework() {
    console.log("üè† Received homeworkData from Swift:", window.homeworkData);
    // Speichere es noch einmal ab ‚Äì so verh√§lt sich auch der Fallback-Mechanismus
    localStorage.setItem("homeworkData", JSON.stringify(window.homeworkData));
    // √ñffne oder aktualisiere das Modal
    showHomework();
  }

  
  
  const blobToggle = document.createElement("span");
  blobToggle.id = "blobToggle";
  blobToggle.textContent = "üîÜ";
  blobToggle.style.cursor = "pointer";
  settingsPanel.appendChild(blobToggle);

  blobToggle.addEventListener("click", () => {
    blobsEnabled = !blobsEnabled;
    blobToggle.textContent = blobsEnabled ? "üîÜ" : "üîÖ";
  });
  
  // Pausen-Button
  function blinkGreenBackground() {
    // Urspr√ºngliche Hintergrundfarbe speichern (falls gesetzt, sonst Standardwert)
    const originalBg = document.body.style.backgroundColor || "";
    // Setze den Hintergrund auf den bekannten Gr√ºnton
    document.body.style.backgroundColor = "LightBlue"; // hier den gew√ºnschten Gr√ºnton anpassen
    // Nach 300 Millisekunden wieder zur√ºcksetzen
    setTimeout(function() {
      document.body.style.backgroundColor = originalBg;
    }, 300);
  }
  
  pauseButton.addEventListener("click", () => {
    if (!sessionPaused) {
      saveStatistics();
      saveButtonEffect();
      console.log("Statistiken gespeichert und gr√ºner Farbtupfer ausgel√∂st.");
    }
  });
  
  
  
  // Metronom-Ton (tick.mp3)
  const metronomeSound = new Audio('tick.mp3');
  // Metronom-Toggle
  // Metronom-Setup: Zustandsvariablen und Steuerfunktionen
  let metronomeOn = false;
  let metronomeInterval = 60000;         // Millisekunden pro Schlag, wird bei BPM-√Ñnderung angepasst
  let lastTickTime = Date.now();         // Zeitstempel des letzten Metronom-Schlags
  let metronomeTimer;                    // Intervall-Timer f√ºr Metronom
  let metronomeTolerance = 0;            // Fehlertoleranz (wird noch gesetzt)

  // Startet das Metronom: aktualisiert lastTickTime bei jedem Schlag und spielt Ton ab
  function startMetronome() {
    if (metronomeTimer) clearInterval(metronomeTimer);
    metronomeOn = true;
    lastTickTime = Date.now();
    metronomeTimer = setInterval(() => {
      // Metronom-Ton abspielen
      metronomeSound.currentTime = 0;
      metronomeSound.play();
      lastTickTime = Date.now();
    }, metronomeInterval);
  }

  // Stoppt das Metronom
  function stopMetronome() {
    metronomeOn = false;
    if (metronomeTimer) {
      clearInterval(metronomeTimer);
      metronomeTimer = null;
    }
  }

  // Metronom-Container mit Emoji und BPM-Anzeige
  const metronomeContainer = document.createElement("div");
  metronomeContainer.style.display = "inline-block";
  metronomeContainer.style.textAlign = "center";
  settingsPanel.appendChild(metronomeContainer);

  const metronomeToggle = document.createElement("span");
  metronomeToggle.id = "metronomeToggle";
  metronomeToggle.textContent = "‚è≤Ô∏è";
  metronomeToggle.style.opacity = "0.5";
  metronomeContainer.appendChild(metronomeToggle);

  const bpmDisplay = document.createElement("span");
  bpmDisplay.id = "bpmDisplay";
  bpmDisplay.style.display = "block";
  // const emojiWidth = metronomeToggle.getBoundingClientRect().width;
  bpmDisplay.style.fontSize = "14px"; // feste Schriftgr√∂√üe, frei anpassbar
  bpmDisplay.style.fontWeight = "bold";
  bpmDisplay.textContent = metronomeBPM > 0 ? metronomeBPM + " BPM" : "";
  metronomeContainer.appendChild(bpmDisplay);
  bpmDisplay.addEventListener("click", () => {
    let existingInput = document.getElementById("bpmInput");
    if (!existingInput) {
      const input = document.createElement("input");
      input.id = "bpmInput";
      input.type = "number";
      input.min = "1";
      input.placeholder = metronomeBPM > 0 ? metronomeBPM : "";
      Object.assign(input.style, {
        backgroundColor: "white",
        border: "1px solid #000",
        width: "60px",
        fontSize: "1em",
        borderRadius: "5px",
        outline: "none",
        marginLeft: "5px"
      });
      metronomeContainer.appendChild(input);
      input.focus();
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const bpm = Number(input.value);
          if (bpm > 0) {
            metronomeBPM = bpm;
            metronomeInterval = 60000 / bpm;
            document.getElementById("bpmDisplay").textContent = metronomeBPM + " BPM";
            metronomeTolerance = metronomeInterval * 0.3;
            if (metronomeOn) startMetronome();
            startMetronome();
            metronomeToggle.style.opacity = "1";
            metronomeOn = true;
          }
          input.remove();
        }
      });
      input.addEventListener("blur", () => {
        input.remove();
      });
    }
  });
metronomeToggle.addEventListener("click", () => {
if (metronomeOn) {
stopMetronome();
metronomeOn = false;
metronomeToggle.style.opacity = "0.5";
document.getElementById("bpmDisplay").textContent = "";
} else {
let existingInput = document.getElementById("bpmInput");
if (!existingInput) {
  let input = document.createElement("input");
  input.id = "bpmInput";
  input.type = "number";
  input.min = "1";
  input.placeholder = metronomeBPM > 0 ? metronomeBPM : "";
  input.style.backgroundColor = "white";
  input.style.border = "1px solid #000";
  input.style.width = "60px";
  input.style.fontSize = "1em";
  input.style.borderRadius = "5px";
  input.style.outline = "none";
  input.style.marginLeft = "5px";

  metronomeToggle.parentElement.appendChild(input);
  input.focus();

  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      const bpm = Number(input.value);
      if (bpm > 0) {
        metronomeBPM = bpm;
        metronomeInterval = 60000 / bpm;
        document.getElementById("bpmDisplay").textContent = metronomeBPM + " BPM";
        metronomeTolerance = metronomeInterval * 0.3;
        if (metronomeOn) startMetronome();
        startMetronome();
        metronomeToggle.style.opacity = "1";
        metronomeOn = true;
      }
      input.remove();
    }
  });

  input.addEventListener("blur", () => {
    input.remove();
  });
}
}
});

  const kidsModeToggle = document.createElement("span");
  kidsModeToggle.id = "kidsModeToggle";
  kidsModeToggle.textContent = "üêù";
  kidsModeToggle.style.cursor = "pointer";
  kidsModeToggle.style.opacity = "0.5";
  settingsPanel.appendChild(kidsModeToggle);

  kidsModeToggle.addEventListener("click", () => {
    kidsMode = !kidsMode;
    kidsModeToggle.style.opacity = kidsMode ? "1" : "0.5";
    drawSeries();
  });
  
  
  
  
  

  // Move Notation Toggle
  const moveNotationToggle = document.createElement("span");
  moveNotationToggle.id = "moveNotationToggle";
  moveNotationToggle.textContent = "üìê";
  settingsPanel.appendChild(moveNotationToggle);

  let moveModeActive = false;
  let currentX = 0, currentY = 0; // Persist position for storage
  let startX = 0, startY = 0;
  let isDragging = false;
  let xGuide, yGuide, xLabel, yLabel;
  let duringDrag, endDrag; // For removal of listeners

  moveNotationToggle.addEventListener("click", () => {
    const notation = document.getElementById("notation");
    // Drag-Cursor f√ºr Notation
    notation.style.cursor = "grab";
    // Ensure startX, startY are declared only once at top-level
    if (!moveModeActive) {
      moveModeActive = true;
      // Show notation zoom controls in move mode
      zoomInBtn.style.display = 'inline';
      zoomOutBtn.style.display = 'inline';

      // --- Add dynamic guide lines with percentage labels ---
      xGuide = document.createElement("div");
      xGuide.style.position = "fixed";
      xGuide.style.top = "0";
      xGuide.style.height = "100%";
      xGuide.style.width = "1px";
      xGuide.style.background = "blue";
      xGuide.style.zIndex = "1999";
      xGuide.style.left = "50%";
      xGuide.style.transform = `translateX(${currentX}px)`;

      yGuide = document.createElement("div");
      yGuide.style.position = "fixed";
      yGuide.style.left = "0";
      yGuide.style.width = "100%";
      yGuide.style.height = "1px";
      yGuide.style.background = "blue";
      yGuide.style.zIndex = "1999";
      yGuide.style.top = "50%";
      yGuide.style.transform = `translateY(${currentY}px)`;

      xLabel = document.createElement("div");
      xLabel.style.position = "fixed";
      xLabel.style.top = "0";
      xLabel.style.left = `calc(50% + ${currentX}px + 5px)`;
      xLabel.style.color = "blue";
      xLabel.style.fontSize = "12px";
      xLabel.style.zIndex = "1999";
      xLabel.textContent = `${Math.round((currentX / window.innerWidth) * 100)}%`;

      yLabel = document.createElement("div");
      yLabel.style.position = "fixed";
      yLabel.style.left = "0";
      yLabel.style.top = `calc(50% + ${currentY}px + 5px)`;
      yLabel.style.color = "blue";
      yLabel.style.fontSize = "12px";
      yLabel.style.zIndex = "1999";
      yLabel.textContent = `${Math.round((currentY / window.innerHeight) * 100)}%`;

      document.body.appendChild(xGuide);
      document.body.appendChild(yGuide);
      document.body.appendChild(xLabel);
      document.body.appendChild(yLabel);

      // Save references for later removal
      window._notationGuides = [xGuide, yGuide, xLabel, yLabel];

      // --- Pointer-based drag functionality ---
      startX = 0;
      startY = 0;
      // Try to restore from localStorage if exists
      let saved = localStorage.getItem("notationTransform");
      if (saved && saved.includes("translate(-50%, -50%) translate(")) {
        // Try to extract px values
        let match = saved.match(/translate\(-50%, -50%\)\s*translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
        if (match) {
          currentX = parseFloat(match[1]);
          currentY = parseFloat(match[2]);
        }
      }
      xGuide.style.transform = `translateX(${currentX}px)`;
      yGuide.style.transform = `translateY(${currentY}px)`;
      xLabel.style.left = `calc(50% + ${currentX}px + 5px)`;
      xLabel.textContent = `${Math.round((currentX / window.innerWidth) * 100)}%`;
      yLabel.style.top = `calc(50% + ${currentY}px + 5px)`;
      yLabel.textContent = `${Math.round((currentY / window.innerHeight) * 100)}%`;
      notation.style.position = "fixed";
      notation.style.top = "50%";
      notation.style.left = "50%";
      notation.style.transform = `translate(-50%, -50%) translate(${currentX}px, ${currentY}px)`;

      // Drag logic
      const startDrag = (e) => {
        isDragging = true;
        notation.style.cursor = "grabbing";
        const evt = e.touches ? e.touches[0] : e;
        startX = evt.clientX;
        startY = evt.clientY;
        e.preventDefault();
      };
      duringDrag = (e) => {
        if (!isDragging) return;
        const evt = e.touches ? e.touches[0] : e;
        const dx = evt.clientX - startX;
        const dy = evt.clientY - startY;
        currentX += dx;
        currentY += dy;
        startX = evt.clientX;
        startY = evt.clientY;

        xGuide.style.transform = `translateX(${currentX}px)`;
        yGuide.style.transform = `translateY(${currentY}px)`;
        xLabel.style.left = `calc(50% + ${currentX}px + 5px)`;
        xLabel.textContent = `${Math.round((currentX / window.innerWidth) * 100)}%`;
        yLabel.style.top = `calc(50% + ${currentY}px + 5px)`;
        yLabel.textContent = `${Math.round((currentY / window.innerHeight) * 100)}%`;

        notation.style.position = "fixed";
        notation.style.top = "50%";
        notation.style.left = "50%";
        notation.style.transform = `translate(-50%, -50%) translate(${currentX}px, ${currentY}px)`;
      };
      endDrag = () => {
        isDragging = false;
        notation.style.cursor = "grab";
      };

      [xGuide, yGuide, xLabel, yLabel].forEach(el => {
        el.style.touchAction = "none";
        el.addEventListener("mousedown", startDrag);
        el.addEventListener("touchstart", startDrag);
      });
      // Erlaube Ziehen direkt am Notations-DIV
      notation.addEventListener("mousedown", startDrag);
      notation.addEventListener("touchstart", startDrag, { passive: false });
      window.addEventListener("mousemove", duringDrag);
      window.addEventListener("touchmove", duringDrag);
      window.addEventListener("mouseup", endDrag);
      window.addEventListener("touchend", endDrag);

    } else {
      moveModeActive = false;
      // Hide notation zoom controls when exiting move mode
      zoomInBtn.style.display = 'none';
      zoomOutBtn.style.display = 'none';
      // Persist the final position when move mode is disabled
      localStorage.setItem("notationTransform", `translate(-50%, -50%) translate(${currentX}px, ${currentY}px)`);
      // Store the final position and clean up listeners and guides
      if (window._notationGuides) {
        [xGuide, yGuide, xLabel, yLabel] = window._notationGuides;
        [xGuide, yGuide, xLabel, yLabel].forEach(el => {
          if (el && el.parentElement) el.parentElement.removeChild(el);
        });
        window._notationGuides = null;
      }
      window.removeEventListener("mousemove", duringDrag);
      window.removeEventListener("touchmove", duringDrag);
      window.removeEventListener("mouseup", endDrag);
      window.removeEventListener("touchend", endDrag);
    }
  });
  
document.getElementById("timerContainer").addEventListener("click", () => {
let existingInput = document.getElementById("counterInput");
if (!existingInput) {
let timerContainer = document.getElementById("timerContainer");
let input = document.createElement("input");
input.id = "counterInput";
input.type = "number";
input.min = "1";
input.placeholder = sessionCounter;
input.value = sessionCounter;
input.style.backgroundColor = "white";
input.style.border = "1px solid #000";
  input.style.width = "150px";
  input.style.fontSize = "2em";
input.style.textAlign = "center";
input.style.borderRadius = "5px";
input.style.outline = "none";

timerContainer.innerHTML = "";
timerContainer.appendChild(input);
input.focus();

let confirmed = false;

input.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    confirmed = true;
    const num = parseInt(input.value, 10);
    if (!isNaN(num) && num > 0) {
      sessionCounter = num;
      localStorage.setItem("sessionCounter", sessionCounter);
      updateTimer();
      if (sessionCounter === 0 && !sessionPaused) {
        startPauseCountdown();
      }
    }
    timerContainer.innerHTML = sessionCounter;
  }
});

input.addEventListener("blur", () => {
  if (!confirmed) {
    input.focus(); // Bleibe im Feld, bis best√§tigt
  }
});
}
});
  
  

  // Animated carousel using a sliding track
  const carouselContainer = document.createElement('div');
  carouselContainer.id = 'carouselContainer';
  const carouselTrack = document.createElement('div');
  carouselTrack.id = 'carouselTrack';
  carouselContainer.appendChild(carouselTrack);
  settingsPanel.appendChild(carouselContainer);
  // Notation zoom controls
  let notationZoom = parseFloat(localStorage.getItem('notationZoom')) || 1;
  const zoomInBtn = document.createElement('span');
  zoomInBtn.id = 'notationZoomIn';
  zoomInBtn.textContent = '‚ûï';
  zoomInBtn.style.cursor = 'pointer';
  settingsPanel.appendChild(zoomInBtn);
  const zoomOutBtn = document.createElement('span');
  zoomOutBtn.id = 'notationZoomOut';
  zoomOutBtn.textContent = '‚ûñ';
  zoomOutBtn.style.cursor = 'pointer';
  settingsPanel.appendChild(zoomOutBtn);
  // Hide zoom buttons by default
  zoomInBtn.style.display = 'none';
  zoomOutBtn.style.display = 'none';

  // Zoom factor handlers
  zoomInBtn.addEventListener('click', () => {
    notationZoom *= 1.1;
    localStorage.setItem('notationZoom', notationZoom);
    drawSeries();
  });
  zoomOutBtn.addEventListener('click', () => {
    notationZoom /= 1.1;
    localStorage.setItem('notationZoom', notationZoom);
    drawSeries();
  });
  // F√ºge den Tonleiter-Modus-Button direkt nach dem Karussell ein


  const carouselButtons = [pauseButton, blobToggle, kidsModeToggle, moveNotationToggle];
  carouselButtons.forEach(btn => {
    const item = document.createElement('div');
    item.className = 'carouselItem';
    item.appendChild(btn);
    carouselTrack.appendChild(item);
  });
  let currentIndex = 0;
  function updateCarousel() {
    carouselTrack.style.transform = `translateX(-${currentIndex * 100}%)`;
  }
  updateCarousel();
  carouselContainer.addEventListener('touchstart', e => {
    startX = e.touches[0].clientX;
  });
  carouselContainer.addEventListener('touchend', e => {
    const endX = e.changedTouches[0].clientX;
    if (startX !== null) {
      const deltaX = endX - startX;
      if (deltaX < -30) {
        currentIndex = (currentIndex + 1) % carouselButtons.length;
      } else if (deltaX > 30) {
        currentIndex = (currentIndex - 1 + carouselButtons.length) % carouselButtons.length;
      }
      updateCarousel();
    }
    startX = null;
  });

  // Speech bubble hint for carousel, only once
  if (!localStorage.getItem('carouselHintShown')) {
    const bubble = document.createElement('div');
    bubble.className = 'speech-bubble';
    bubble.innerHTML = '<span class="close-btn">√ó</span>Wische hier, um weitere Funktionen zu sehen!';
    document.body.appendChild(bubble);
    const pauseBtn = document.getElementById('pauseButton');
    if (pauseBtn) {
      // Wait one frame so bubble has its dimensions
      requestAnimationFrame(() => {
        const rect = pauseBtn.getBoundingClientRect();
        const bubbleRect = bubble.getBoundingClientRect();
        bubble.style.top = `${rect.top - bubbleRect.height - 10}px`;
        bubble.style.left = `${rect.left + (rect.width - bubbleRect.width) / 2}px`;
      });
    }
    bubble.querySelector('.close-btn').addEventListener('click', () => {
      localStorage.setItem('carouselHintShown', 'true');
      bubble.remove();
    });
  }
  // Scoreboard-Toggle

  // --- Quintenzirkel & Lagen: Definition der verf√ºgbaren Lagen und Tonarten ---
  // Verf√ºgbare Lagen und Quintenzirkel-Tonarten
 

  autoSelectMode();
  generateSeries();

  updateHeartsDisplay();
  document.addEventListener("keydown", (event) => {
    if (event.code === "Space") { handleMIDIMessage(144, 60, 127); }
  });


});
              
let melodyContext = {
lastNote: null,
direction: 1, // 1 = aufw√§rts, -1 = abw√§rts
scale: ["c", "d", "e", "f", "g", "a", "b"], // C-Dur
};
// Stelle sicher, dass selectedClef global initialisiert ist
selectedClef = "treble";
let notesInCurrentPhase = 0;

// Extrahierte Funktion f√ºr den Tonleiter-Modus
function generateScaleSeries(isFinal = false) {
// Reset counters
seriesCounter = 0;
correctNoteCount = 0;
// Always show full octave in selection phase
const defaultScaleNotes = octaveOptions[selectedOctave] || [];
if (!isFinal) {
// Selection-mode: render all notes of the current octave
currentSeriesSingle = defaultScaleNotes.map(s => {
  const [, n, o] = s.match(/^([A-G])(\d)$/);
  return { note: n.toLowerCase(), octave: parseInt(o, 10), clef: selectedClef, color: 'black' };
});
drawSeries();
return;
}
// Final-mode: build infinite series from the explicit clicks, per-octave.
let notesToUse;
// Use per-octave clicked notes if any, otherwise default octave notes
const stored = (window.selectedNotesByOctave && window.selectedNotesByOctave[selectedOctave]) || [];
if (stored.length > 0) {
notesToUse = stored.map(pitch => {
  const [n, o] = pitch.split("/");
  return { note: n.toLowerCase(), octave: parseInt(o, 10) };
});
} else {
notesToUse = defaultScaleNotes.map(s => {
  const [, n, o] = s.match(/^([A-G])(\d)$/);
  return { note: n.toLowerCase(), octave: parseInt(o, 10) };
});
}
currentSeriesSingle = [];
for (let i = 0; i < seriesLength; i++) {
const { note, octave } = notesToUse[i % notesToUse.length];
currentSeriesSingle.push({ note, octave, clef: selectedClef, color: 'black' });
}
drawSeries();
}
  
  // Gibt f√ºr einen Roh-Ton und eine Lage den vollst√§ndigen VexFlow-Key zur√ºck
  function getNoteKey(rawNote, range) {
    const pitch = rawNote.toLowerCase();
    let octave = 4; // Standard-Oktave
    // Spezialfall G-Lage: C und D eine Oktave h√∂her
    if (range === "G" && (pitch === "c" || pitch === "d")) {
      octave = 5;
    }
    return pitch + "/" + octave;
  }

const generateSeries = () => {
// Update progressbar for current Lage whenever a new series is loaded
drawLageProgress(currentRange, lageProgress[currentRange] || 0);
// Wenn im Smartphone-Lernmodus: nur exakt 1 Note generieren und zeichnen
if (isChordMode && selectedChords.length) {
  const chord = selectedChords[Math.floor(Math.random()*selectedChords.length)];
  currentSeriesSingle = [{ chordName: chord.name, chordNotes: chord.notes }];
  drawSeries();
  return;
}
if (window.isMobile) {
  // (a) Pr√ºfe, ob wir im Einhand-/Treble-/Bass-Modus sind
  const handClef = (selectedMode === "left") ? "bass" : "treble";

  // (b) W√§hle genau eine zuf√§llige Note aus rangeNotes[currentRange]
  const notes = rangeNotes[currentRange] || [];
  const idx = Math.floor(Math.random() * notes.length);
  const chosen = notes[idx];

  // (c) Setze passende Oktave (Bass=3, Treble=4; F-Lage-C evtl. +1)
  let octave = (handClef === "bass") ? 3 : 4;
  if (currentRange === "F" && handClef === "treble" && chosen.toLowerCase() === "c") {
    octave = 5;
  }
  // G-Lage: C und D eine Oktave h√∂her
  if (currentRange === "G" && ["c", "d"].includes(chosen.toLowerCase())) {
    octave = 5;
  }

  // (d) Baue ein einzelnes Note-Objekt und zeichne es
  currentSeriesSingle = [{
    note: chosen,
    octave: octave,
    clef: handClef,
    color: "black"
  }];
  drawSeries();

  // (e) Verlasse die gesamte Serie-Funktion, damit nichts weiter passiert
  return;
}
if (selectedMode === "scale") {
generateScaleSeries();
return;
}
seriesCounter = 0;
correctNoteCount = 0;
// --- Manuelle Notenauswahl aus UI ber√ºcksichtigen ---
const noteSelectorElements = document.querySelectorAll("#noteSelector .selectable-note.selected");
const manuallySelectedNotes = Array.from(noteSelectorElements).map(el => el.textContent.toLowerCase());
nextMotivationThreshold = getRandomThreshold();
document.getElementById("noteNameDisplay").textContent = "";

// Einhandmodus: customNoteSeries bevorzugen, sonst fallback
if (selectedMode === "left" || selectedMode === "right") {
if (typeof customNoteSeries !== "undefined" && customNoteSeries.length > 0) {
  currentSeriesSingle = customNoteSeries.slice();
} else {
  // Einhand-Modus ohne Custom: nur Noten der aktuellen Lage verwenden
  const handClef = selectedMode === "left" ? "bass" : "treble";
  const notes = rangeNotes[currentRange];
  currentSeriesSingle = [];
  for (let i = 0; i < seriesLength; i++) {
    const idx = Math.floor(Math.random() * notes.length);
    const chosen = notes[idx];
    let octave = handClef === "bass" ? 3 : 4;
    // F-Lage: C eine Oktave h√∂her
    if (currentRange === "F" && handClef === "treble" && chosen.toLowerCase() === "c") {
      octave = 5;
    }
    // G-Lage: C und D eine Oktave h√∂her
    if (currentRange === "G" && ["c", "d"].includes(chosen.toLowerCase())) {
      octave = 5;
    }
    currentSeriesSingle.push({ note: chosen, octave: octave, clef: handClef, color: "black" });
  }
}
seriesCounter = 0;
correctNoteCount = 0;
drawSeries();
return;
}

let seriesClef, chooseNote;
// Pr√ºfe, ob benutzerdefinierte Einstellungen aktiv sind
if (window.customModeSettings && window.customModeSettings.clef && window.customModeSettings.range) {
  // Einhand-Modus Custom: Nur benutzerdefinierte Noten oder aktuelle Lage-Noten
  seriesClef = window.customModeSettings.clef;
  currentRange = window.customModeSettings.range;
  const customNotes = (selectedMode === "left")
    ? window.customModeSettings.leftNotes
    : window.customModeSettings.rightNotes;
  // Fallback: wenn keine benutzerdefinierten Noten, verwende Lage-Noten
  const notesForSeries = (customNotes && customNotes.length > 0)
    ? customNotes
    : rangeNotes[currentRange];
  currentSeriesSingle = notesForSeries.map(note => ({
    note: note,
    octave: octaveDefinitions[currentRange].baseOctave,
    clef: seriesClef
  }));
  seriesCounter = currentSeriesSingle.length;
  return;

} else {
// Bestehendes Verhalten, wenn kein Custom Mode aktiv ist
if (randomMode) {
  seriesClef = Math.random() < 0.5 ? "bass" : "treble";
  notesInCurrentPhase += seriesLength;
  if (notesInCurrentPhase >= 20) {
    let oldRange = currentRange;
    if (typeof alternatingRanges !== 'undefined' && alternatingRanges.length > 0) {
      currentRange = alternatingRanges[Math.floor(Math.random() * alternatingRanges.length)];
    }
    if (oldRange !== currentRange) {
      gongSound.currentTime = 0;
      gongSound.play();
      var clefTitle = document.getElementById("clefTitle");
      clefTitle.textContent = currentRange + "-Lage";
      clefTitle.style.border = "3px solid red";
      setTimeout(() => {
        if (document.body.classList.contains("dark-mode")) {
          clefTitle.style.border = "3px solid #fff";
        } else {
          clefTitle.style.border = "3px solid #000";
        }
      }, 300);
    }
    notesInCurrentPhase = 0;
  }
} else {
  seriesClef = (selectedMode === "left") ? "bass" : "treble";
}
chooseNote = () => {
  if (errorNotes.length > 0 && Math.random() < 0.6) {
    const idx = errorNotes.findIndex(note => note.clef === seriesClef);
    if (idx !== -1) {
      return errorNotes.splice(idx, 1)[0];
    }
  }
  let defaultNotes;
  if (currentRange === "MC") {
    defaultNotes = seriesClef === "bass"
      ? ["f", "g", "a", "b", "c"]
      : ["c", "d", "e", "f", "g"];
  } else if (currentRange === "D") {
    defaultNotes = ["d", "e", "f#", "g", "a"];
  } else if (currentRange === "F") {
    defaultNotes = ["f", "g", "a", "bb", "c"];
  } else {
    defaultNotes = rangeNotes[currentRange];
  }
  // --- Effektive Noten bestimmen: manuelle Auswahl hat Vorrang ---
  let effectiveNotes;
  if (manuallySelectedNotes.length > 0) {
    effectiveNotes = manuallySelectedNotes;
  } else {
    effectiveNotes = defaultNotes;
  }
  const randomIndex = Math.floor(Math.random() * effectiveNotes.length);
  const chosenNote = effectiveNotes[randomIndex];
  let noteOctave = seriesClef === "bass" ? 3 : 4;
  // F-Lage: ensure C is one octave higher in treble clef
  if (currentRange === "F" && seriesClef === "treble" && chosenNote.toLowerCase() === "c") {
    noteOctave = 5;
  }
  // G-Lage: C und D eine Oktave h√∂her
  if (currentRange === "G" && ["c", "d"].includes(chosenNote.toLowerCase())) {
    noteOctave = 5;
  }
  let accidental = undefined;
  if (["F", "G"].includes(currentRange)) {
    if (currentRange === "F" && chosenNote.toLowerCase() === "bb") {
      accidental = "b";
    } else if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
      accidental = chosenNote;
    } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
      accidental = chosenNote;
    }
  }
  return { note: chosenNote, octave: noteOctave, clef: seriesClef, color: "black", accidental: accidental };
};
}

currentSeriesSingle = [];
for (let i = 0; i < seriesLength; i++) {
currentSeriesSingle.push(chooseNote());
}
drawSeries();
};
                                        
selectedNotes = [];
let scaleSelectionMode = false; // Flag f√ºr Scale-Auswahl-Phase
// Oktaven-Definitionen
const octaveOptions = {
'gro√üe Oktave':       ['C2','D2','E2','F2','G2','A2','B2','C3'],
'kleine Oktave':      ['C3','D3','E3','F3','G3','A3','B3','C4'],
'eingestrichene Oktave': ['C4','D4','E4','F4','G4','A4','B4','C5'],
'zweigestrichene Oktave': ['C5','D5','E5','F5','G5','A5','B5','C6']
};
let selectedOctave = 'gro√üe Oktave';
const drawSeries = () => {
// Debug: Log clef context to diagnose undefined issues
console.log("drawSeries() context:", { selectedMode, selectedClef, firstClef: currentSeriesSingle?.[0]?.clef });
if (isChordMode && currentSeriesSingle[0].chordName) {
const chord = currentSeriesSingle[0];
notation.innerHTML = '';
const renderer = new VF.Renderer(notation, VF.Renderer.Backends.SVG);
renderer.resize(notation.clientWidth, 120);
const ctx = renderer.getContext();
const stave = new VF.Stave(10,10,notation.clientWidth-20);
stave.addClef('treble').setContext(ctx).draw();
const note = new VF.StaveNote({ keys: chord.chordNotes, duration: 'w' });
VF.Formatter.FormatAndDraw(ctx, stave, [note]);
const label = document.createElement('div');
label.textContent = chord.chordName;
label.style.textAlign = 'center';
notation.appendChild(label);
return;
}
const noteAnimals = {
"c": "üê±", "d": "üê≥", "e": "üê∑", "f": "üêü",
"g": "üê§", "a": "ü¶ä", "b": "üêù", "bb": "ü¶Å",
"f#": "üêô", "g#": "üêµ", "d#": "üê≠"
};

const notationDiv = document.getElementById("notation");
const baseWidth = window.isMobile ? 150 : 600;
if (window.isMobile) {
notationDiv.style.margin = "0 10px";
}
const ratio = window.devicePixelRatio || 1;
const height = 300 * ratio;
notationDiv.style.display = "block";
notationDiv.innerHTML = "";

const renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
const baseZoom = 1.4;
const userZoom = parseFloat(localStorage.getItem('notationZoom')) || 1;
const zoomFactor = baseZoom * userZoom;
renderer.resize(baseWidth * ratio * zoomFactor, height * zoomFactor);

const svg = notationDiv.querySelector("svg");
if (svg) {
svg.setAttribute("width", baseWidth * zoomFactor);
svg.setAttribute("height", 100 * zoomFactor);
svg.style.transform = `scale(${zoomFactor})`;
svg.style.transformOrigin = "top left";
}

const context = renderer.getContext();
// Bestimme Clef, mit Fallback auf 'treble' bei ung√ºltigem Wert
const stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
let clefToUse = (selectedMode === "scale")
? selectedClef
: (currentSeriesSingle && currentSeriesSingle.length > 0)
  ? currentSeriesSingle[0].clef
  : selectedClef;
// Validiere Clef ohne Absturz, benutze statische Liste als Fallback
let availableClefs = ['treble', 'bass', 'alto', 'tenor'];
if (Vex.Flow.Tables && typeof Vex.Flow.Tables.currentGlyphs === 'function') {
const glyphs = Vex.Flow.Tables.currentGlyphs();
if (glyphs && glyphs.clef) {
  availableClefs = Object.keys(glyphs.clef);
}
}
if (!clefToUse || !availableClefs.includes(clefToUse)) {
console.warn(`Ung√ºltiger Clef '${clefToUse}', setze Fallback auf 'treble'`);
clefToUse = 'treble';
}
stave.addClef(clefToUse);
// Nur f√ºr echte Quintenzirkel-Tonarten ein Key Signature setzen
if (["A", "E", "B", "F#", "C#", "Ab", "Eb", "Bb"].includes(currentRange)) {
  stave.addKeySignature(currentRange);
}
stave.setContext(context).draw();

const noteDuration = (window.customModeSettings && window.customModeSettings.noteValue === "8") ? "8" : "q";
const noteOrder = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"];

const staveNotes = currentSeriesSingle.map(item => {
let noteName = item.note.toLowerCase().replace(/‚ôØ/g, "#").replace(/‚ô≠/g, "b");
const key = noteName + "/" + item.octave;
const staveNote = new Vex.Flow.StaveNote({
  clef: item.clef,
  keys: [key],
  duration: noteDuration
  
});

staveNote.setStyle({ fillStyle: item.color, strokeStyle: item.color });

const noteIndex = noteOrder.indexOf(noteName);
const midiNumber = (item.octave + 1) * 12 + noteIndex;
const threshold = item.clef === "bass" ? 50 : 71;
staveNote.setStemDirection(midiNumber >= threshold ? -1 : 1);

return staveNote;
});

const voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
voice.setStrict(false);
staveNotes.forEach(note => voice.addTickable(note));
new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
voice.draw(context, stave);

// Interaktive Noten im Scale-Modus mit per-Oktave Speicherung
if (selectedMode === "scale" && scaleSelectionMode) {
const noteElements = document.querySelectorAll("svg g.vf-stavenote");
// Ensure storage exists
if (!window.selectedNotesByOctave) window.selectedNotesByOctave = {};
if (!window.selectedNotesByOctave[selectedOctave]) {
  window.selectedNotesByOctave[selectedOctave] = [];
}
let selectedNotesByOctave = window.selectedNotesByOctave;
noteElements.forEach((svgNote, idx) => {
  svgNote.style.cursor = "pointer";
  const pitch = `${currentSeriesSingle[idx].note}/${currentSeriesSingle[idx].octave}`;
  svgNote.dataset.pitch = pitch;
  const selArr = selectedNotesByOctave[selectedOctave];
  // Restore visual state
  if (selArr.includes(pitch)) {
    svgNote.classList.add("selected");
    svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
      shape.setAttribute('fill', 'green');
      shape.setAttribute('stroke', 'green');
    });
  } else {
    svgNote.classList.remove("selected");
    svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
      shape.setAttribute('fill', 'black');
      shape.setAttribute('stroke', 'black');
    });
  }
  // Toggle on click
  svgNote.onclick = () => {
    const arr = selectedNotesByOctave[selectedOctave];
    if (arr.includes(pitch)) {
      selectedNotesByOctave[selectedOctave] = arr.filter(n => n !== pitch);
      svgNote.classList.remove("selected");
      svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
        shape.setAttribute('fill', 'black');
        shape.setAttribute('stroke', 'black');
      });
    } else {
      arr.push(pitch);
      svgNote.classList.add("selected");
      svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
        shape.setAttribute('fill', 'green');
        shape.setAttribute('stroke', 'green');
      });
    }
  };
});
}

// üêù Kinder-Modus: Emojis auf die Notenk√∂pfe setzen
if (kidsMode) {
  const svg = notationDiv.querySelector("svg");
  if (!svg) return;

  svg.querySelectorAll(".note-emoji").forEach(el => el.remove());

  staveNotes.forEach((note, index) => {
    const coords = note.getModifierStartXY(Vex.Flow.Modifier.Position.LEFT, 0);
    const emoji = noteAnimals[currentSeriesSingle[index].note.toLowerCase()] || "‚ùì";
    const centerX = coords.x + 8;
    const centerY = coords.y - 2;

    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", centerX);
    text.setAttribute("y", centerY); // kleiner Feintuning-Wert
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute("font-size", "30"); // etwas gr√∂√üer als Notenkopf
    text.setAttribute("class", "note-emoji");
    text.textContent = emoji;
    svg.appendChild(text);
    // Geometrie-Modus: Emoji-Klick-Handler
    text.style.cursor = "pointer";
    text.addEventListener("click", function (event) {
      // 1. Position und Gr√∂√üe speichern
      if (typeof saveEmojiPositionAndSize === "function") {
        saveEmojiPositionAndSize(event.target);
      }
      // 2. Geometrie-Modus speichern
      if (typeof saveGeometryMode === "function") {
        saveGeometryMode();
      }
      // 3. Geometrie-Modus beenden / schlie√üen
      if (typeof closeGeometryMode === "function") {
        closeGeometryMode();
      }
    });
  });
}

// Dreieck-Markierung f√ºr aktive Note
if (seriesCounter < staveNotes.length) {
const activeNote = staveNotes[seriesCounter];
if (activeNote && typeof activeNote.getBoundingBox === 'function') {
  const bbox = activeNote.getBoundingBox();
  if (bbox) {
    const noteX = bbox.getX() + bbox.getW() / 2;
    const triangleHeight = 5;
    const noteY = stave.getY() - 1 - triangleHeight;
    const triangleWidth = 10;
    const p1 = `${noteX - triangleWidth / 2},${noteY}`;
    const p2 = `${noteX + triangleWidth / 2},${noteY}`;
    const p3 = `${noteX},${noteY + triangleHeight}`;
    const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    triangle.setAttribute('points', `${p1} ${p2} ${p3}`);
    triangle.setAttribute('fill', 'black');
    svg.appendChild(triangle);
  }
}
}

if (["8", "16", "32"].includes(noteDuration)) {
// Erzwinge Balken ohne F√§hnchen f√ºr alle schnellen Notenwerte
staveNotes.forEach(note => {
  note.setStemDirection(1);
  // Entferne Flag-Modifikatoren (F√§hnchen) aus allen schnellen Noten
  note.modifiers = note.modifiers.filter(mod => mod.getCategory() !== 'flag');
});
const beams = Vex.Flow.Beam.generateBeams(staveNotes);
beams.forEach(beam => beam.setContext(context).draw());
}
};

const isNoteCorrect = (midiInfo) => {
  const expected = currentSeriesSingle[seriesCounter];
  if (!expected) return false;
const normalizeNote = n => n.replace("‚ô≠", "b").replace("‚ôØ", "#").toLowerCase();
const playedNote = normalizeNote(midiInfo.note);
const expectedNote = normalizeNote(expected.note);
  return playedNote === expectedNote && midiInfo.octave === expected.octave;
};
const removeFromErrorNotes = (noteObj) => {
  errorNotes = errorNotes.filter(n => !(n.note === noteObj.note && n.octave === noteObj.octave && n.clef === noteObj.clef));
};
  
  const startLocalTimer = () => {
    sessionPaused = true;
    // Setze die Opacity des Notensystems auf 50%
    const notationDiv = document.getElementById("notation");
    if (notationDiv) {
      notationDiv.style.opacity = "0.5";
    }
    pauseRemaining = 10; // 10 Sekunden
    updateLocalTimer();
    pauseInterval = setInterval(() => {
      pauseRemaining--;
      updateLocalTimer();
      if (pauseRemaining <= 0) {
        clearInterval(pauseInterval);
        endLocalTimer();
      }
    }, 1000);
  };
  
  

  const updateLocalTimer = () => {
    const timerElem = document.getElementById("timerContainer");
    if (timerElem) {
      const minutes = Math.floor(pauseRemaining / 60);
      const seconds = pauseRemaining % 60;
      timerElem.textContent = `${minutes < 10 ? "0" + minutes : minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
    }
  };

  const endLocalTimer = () => {
    sessionPaused = false;
    // Setze die Opacity des Notensystems wieder auf 100%
    const notationDiv = document.getElementById("notation");
    if (notationDiv) {
      notationDiv.style.opacity = "1";
    }
    if (gongSound) {
      gongSound.currentTime = 0;
      gongSound.play();
    }
    resetGame();
  };
  
let reverseAnimationTimeout;
let menusHidden = false;
function scheduleReverseAnimation() {
clearTimeout(reverseAnimationTimeout);
reverseAnimationTimeout = setTimeout(() => {
    const settingsPanel = document.getElementById("settingsPanel");
    const streakDisplay = document.getElementById("streakDisplay");
    if (settingsPanel) {
      settingsPanel.classList.remove("fly-out-right");
      settingsPanel.classList.add("fly-in-right");
    }
    if (streakDisplay) {
      streakDisplay.classList.remove("fly-out-left");
      streakDisplay.classList.add("fly-in-left");
    }
    menusHidden = false;
  }, 2000);
}
const handleMIDIMessage = (status, data1, data2) => {
  if (sessionPaused) return;
  // Animation beim Anschlagen einer Taste:
  const settingsPanel = document.getElementById("settingsPanel");
  const streakDisplay = document.getElementById("streakDisplay");
  if (!menusHidden) {
    if (settingsPanel) {
      settingsPanel.classList.remove("fly-in-right", "fly-out-right");
      void settingsPanel.offsetWidth;
      settingsPanel.classList.add("fly-out-right");
    }
    if (streakDisplay) {
      streakDisplay.classList.remove("fly-in-left", "fly-out-left");
      void streakDisplay.offsetWidth;
      streakDisplay.classList.add("fly-out-left");
    }
    menusHidden = true;
  }
  scheduleReverseAnimation();
  if (metronomeOn) {
    const now = Date.now();
    const diff = now - lastTickTime;
    if (Math.abs(diff) > metronomeTolerance) {
      console.log(`MIDI au√üerhalb der Metronom-Toleranz: ${diff}ms`);
      return;
    }
  }
  resetInactivityTimer();
  if ((status & 0xf0) === 0x90 && data2 > 0) {
    if (seriesCounter >= currentSeriesSingle.length) return;
    let currentTime = Date.now();
    let responseTime = currentTime - lastNoteTimestamp;
    responseTimes.push(responseTime);
    lastNoteTimestamp = currentTime;
    const midiInfo = (() => {
      const noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
      const octave = Math.floor(data1 / 12) - 1;
      const rawNote = noteNames[data1 % 12];
      const convertedNote = (rawNote === "a#") ? "bb" : rawNote;
      return { note: convertedNote, octave: octave };
    })();
let playedNoteDisplay;
if (kidsMode) {
  const emojiMap = {
    "c": "üê±", "d": "üê≥", "e": "üê∑", "f": "üêü",
    "g": "üê§", "a": "ü¶ä", "b": "üêù", "bb": "ü¶Å",
    "f#": "üêô", "g#": "üêµ", "d#": "üê≠"
  };
  playedNoteDisplay = emojiMap[midiInfo.note.toLowerCase()] || "‚ùì";
} else {
  playedNoteDisplay = (midiInfo.note === "b" ? "h" : midiInfo.note);
}
    const noteDisplay = document.getElementById("noteNameDisplay");
    totalAttempts++;
    
    if (isNoteCorrect(midiInfo)) {
      // Standardfarbe f√ºr korrekte Noten: gr√ºn
      let displayColor = "green";
      if (metronomeOn) {
        const currentTime = Date.now();
        const actualInterval = currentTime - lastTickTime;
        const tolerance = metronomeInterval * 0.3;
        // Wenn zu schnell oder zu langsam gespielt wird, setze die Farbe auf gelb und zeige entsprechende Motivation
        if (actualInterval < metronomeInterval - tolerance) {
          displayColor = "orange";
          showMotivation("Zu schnell! Langsamer spielen.");
        } else if (actualInterval > metronomeInterval + tolerance) {
          displayColor = "orange";
          showMotivation("Zu langsam! Schneller spielen.");
        } else {
          clearMotivation();
          showMotivation("Super! Weiter so!");
        }
      } else {
        // Ohne Metronom: explizit gr√ºn
        clearMotivation();
        showMotivation("Super! Weiter so!");
        displayColor = "green";
      }
      // Setze die Farbe im Noten-Objekt, damit sie auch beim Zeichnen verwendet wird
      currentSeriesSingle[seriesCounter].color = displayColor;
      
      correctAnswers++;
      correctNoteCount++;
      removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
      addCircle("positive");
      updateLageProgress(true);
    if (noteDisplay) {
      noteDisplay.innerHTML = '<span style="color:' + displayColor + ';">' + playedNoteDisplay + '</span>';
    }
    sessionCounter--;
      
    } else {
      // Falsche Note: rot markieren
      currentSeriesSingle[seriesCounter].color = "red";
      errorNotes.push(currentSeriesSingle[seriesCounter]);
      addCircle("negative");
      updateLageProgress(false);
    if (noteDisplay) {
      const correctRaw = currentSeriesSingle[seriesCounter].note;
      // Deutsche Darstellung: "#" ‚Üí "is", "b" (H) ‚Üí "H"
      let correctDisplay;
      if (correctRaw.endsWith("#")) {
        correctDisplay = correctRaw.charAt(0).toUpperCase() + "is";
      } else if (correctRaw === "b") {
        correctDisplay = "H";
      } else {
        correctDisplay = correctRaw.toUpperCase();
      }
      if (kidsMode) {
        const emojiMap = {
          "c": "üê±", "d": "üê≥", "e": "üê∑", "f": "üêü",
          "g": "üê§", "a": "ü¶ä", "b": "üêù", "bb": "ü¶Å",
          "f#": "üêô", "g#": "üêµ", "d#": "üê≠"
        };
        const playedEmoji = emojiMap[midiInfo.note.toLowerCase()] || "‚ùì";
        const correctEmoji = emojiMap[correctRaw.toLowerCase()] || "‚ùì";
        noteDisplay.innerHTML = '<span style="color:red;">' + playedEmoji + ' h√§tte ' + correctEmoji + ' sein m√ºssen</span>';
      } else {
        noteDisplay.innerHTML = '<span style="color:red;">' + playedNoteDisplay + '</span> <span style="color:black; font-size:1em; margin:0 5px;">&#8594;</span> <span style="color:green;">' + correctDisplay + '</span>';
        // Wizard-Modus: Inline-Auswahl der Buchstaben anzeigen
        if (wizardMode) {
          // Dynamische Auswahl basierend auf Custom Mode Settings f√ºr die aktuelle Hand
          const correctRaw = currentSeriesSingle[seriesCounter].note;
          // Deutsche Darstellung f√ºr Wizard-Auswahl
          let correctLetter;
          if (correctRaw.endsWith("#")) {
            correctLetter = correctRaw.charAt(0).toUpperCase() + "is";
          } else if (correctRaw === "b") {
            correctLetter = "H";
          } else {
            correctLetter = correctRaw.toUpperCase();
          }
          // Determine available notes for current hand
          const handNotes = (selectedMode === "left"
            ? window.customModeSettings?.leftNotes
            : window.customModeSettings?.rightNotes) || [];
          // Deutsche ‚Äûis‚Äú-Schreibweise f√ºr Auswahlm√∂glichkeiten
          const defaultNotes = ["C","Cis","D","Dis","E","Eis","F","Fis","G","Gis","A","Ais","H","C"];
          const choices = handNotes.length > 0
            ? handNotes.map(n => {
                // Deutsche Darstellung f√ºr Auswahl: "#" ‚Üí "is", "b" ‚Üí "H"
                let upper = n.toLowerCase();
                if (upper.endsWith("#")) {
                  return upper.charAt(0).toUpperCase() + "is";
                } else if (upper === "b") {
                  return "H";
                } else {
                  return upper.toUpperCase();
                }
              })
            : defaultNotes;
          let html = `<span style="color:red;">${playedNoteDisplay}</span> <span style="color:black;">‚Üí</span> <span style="color:black; margin:0 5px;">?</span> <span style="color:black; margin:0 5px;"></span> `;
          choices.forEach(letter => {
            html += `<span class="correction-letter" style="opacity:0.5; margin:0 2px; padding:2px 4px; display:inline-block; cursor:pointer;">${letter}</span>`;
          });
          html += ` <span style="color:black; margin:0 5px;"></span>`;
          noteDisplay.innerHTML = html;
          // Klick-Handler f√ºr jeden Buchstaben
          Array.from(noteDisplay.querySelectorAll('.correction-letter')).forEach(el => {
            el.addEventListener('click', () => {
              el.style.opacity = '1';
              const selected = el.textContent;
              if (selected === correctLetter) {
                el.style.color = 'green';
                // Markiere die Note im Notensystem
                currentSeriesSingle[seriesCounter].color = 'green';
                drawSeries();
                // Als korrekte Note z√§hlen
                correctAnswers++;
                correctNoteCount++;
                removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
                addCircle("positive");
                // Counter reduzieren und Timer aktualisieren
                sessionCounter--;
                updateTimer();
                // UI schlie√üen und Fortschritt
                noteDisplay.innerHTML = '';
                correctionActive = false;
                seriesCounter++;
                if (seriesCounter < seriesLength) {
                  queueRedraw();
                } else {
                  generateSeries();
                }
              } else {
                el.style.color = 'red';
                const correctEl = Array.from(noteDisplay.querySelectorAll('.correction-letter'))
                  .find(e => e.textContent === correctLetter);
                if (correctEl) {
                  correctEl.style.color = 'orange';
                  correctEl.style.opacity = '1';
                }
              }
            });
          });
          return;
        }
      }
    }
      if (!unlimitedLives) {
        hearts--;
        updateHeartsDisplay();
        if (hearts <= 0) { endGame(); return; }
      }
    }
    
  // Sofortiges Redraw im Scale-Modus
  if (selectedMode === "scale") {
    drawSeries();
  }

  // Scale-Mode beendet: Serie neu auswerten
  if (sessionCounter <= 0 && !sessionPaused && selectedMode !== "scale") {
    sessionCounter = 0;
    updateTimer();
    startLocalTimer();
    return;
  }
  seriesCounter++;
  if (selectedMode === "scale") {
    if (seriesCounter >= currentSeriesSingle.length) {
      generateScaleSeries(true);
    }
    return;
  }
  if (seriesCounter >= currentSeriesSingle.length) {
    generateSeries();
  } else {
    queueRedraw();
  }
  updateTimer();
  }
};
  const resetGame = () => {
    sessionCounter = 5;      // Counter auf 1000
    totalAttempts = 0;          // Z√§hler f√ºr gespielte Noten auf 0
    elapsedTimer = 0;           // Timer auf 0
    gameOver = false;
    seriesCounter = 0;
    correctAnswers = 0;
    correctNoteCount = 0;
    nextMotivationThreshold = getRandomThreshold();
    sessionPaused = false;
    confettiShown = false;
    errorNotes = [];
    document.getElementById("pauseOverlay").style.display = "none";
    scoreRecorded = false;
    // Setze den Timer-Container (falls genutzt) auf 0
    document.getElementById("timerContainer").textContent = "0";
    // Nur neues Spiel starten, wenn nicht scale-Modus
    if (selectedMode !== "scale") {
      generateSeries();
    }
    updateHeartsDisplay();
  };
                                        

// Funktion, die den Hintergrund f√ºr kurze Zeit gr√ºn f√§rbt und danach wieder zur√ºcksetzt

function checkOrientation() {
const settingsPanel = document.getElementById("settingsPanel");
if (!settingsPanel) return;
// Immer rechtsb√ºndig und vertikal mittig platzieren
settingsPanel.style.top = "50%";
settingsPanel.style.right = "20px";
settingsPanel.style.left = "";
settingsPanel.style.transform = "translateY(-50%)";
// Icons untereinander anordnen
settingsPanel.style.flexDirection = "column";
}
window.addEventListener("resize", checkOrientation);
checkOrientation();

</script>
</body>
<!-- Vereinheitlichte MIDI-Initialisierung -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // iOS check: Verwende nativen Swift-Handler, falls vorhanden
  if (window.webkit?.messageHandlers?.customPrompt) {
    console.log("üì± iOS WebView erkannt ‚Äì MIDI wird nativ behandelt.");
    return;
  }

  if (!navigator.requestMIDIAccess) {
    console.warn("‚ùå Web MIDI API wird nicht unterst√ºtzt.");
    return;
  }

  navigator.requestMIDIAccess({ sysex: false }).then((midiAccess) => {
    console.log("‚úÖ MIDI Access erfolgreich.");
    midiAccess.inputs.forEach((input) => {
      input.onmidimessage = ({ data }) => {
        const [status, data1, data2] = data;
        if ((status & 0xf0) === 0x90 && data2 > 0) {
          handleMIDIMessage(status, data1, data2);
        }
      };
    });

    midiAccess.onstatechange = (event) => {
      const port = event.port;
      if (port.type === "input" && port.state === "connected") {
        console.log("üéπ Neues MIDI-Ger√§t verbunden:", port.name);
        port.onmidimessage = ({ data }) => {
          const [status, data1, data2] = data;
          if ((status & 0xf0) === 0x90 && data2 > 0) {
            handleMIDIMessage(status, data1, data2);
          }
        };
      }
    };
  }).catch((err) => {
    console.error("‚ùå MIDI Zugriff fehlgeschlagen:", err);
  });
});
</script>
</html>
<script>


function startTutorialSequence() {
  const savedName = localStorage.getItem("userName") || "";
  const greeting = savedName ? `Hallo, ${savedName}!` : "Hallo!";
  const steps = [
    [greeting, "Du scheinst das erste Mal hier zu sein ...", "...lass uns dir zeigen, wie die App funktioniert!"],
    ["‚öôÔ∏è Test: Spiele C4", "Bitte spiele C4 (MIDI-Note 60)", "‚úÖ Super, weiter geht's!"],
    ["Du kannst nun angezeigte Noten im Notensystem spielen.", "Hierzu gibt es folgende Einstellungsm√∂glichkeiten...", "‚úã Auswahl der Hand", "üêá Zufallsmodus oder üñçÔ∏è Benutzerdefiniert", "üåô Dark Mode", "‚è≤Ô∏è Metronom"],
    ["Soweit startklar?", "Viel Spa√ü beim Spielen!"]
  ];

  const tutorialOverlay = document.createElement("div");
  tutorialOverlay.id = "tutorialOverlay";
  tutorialOverlay.style.position = "fixed";
  tutorialOverlay.style.top = "0";
  tutorialOverlay.style.left = "0";
  tutorialOverlay.style.width = "100%";
  tutorialOverlay.style.height = "100%";
  tutorialOverlay.style.backgroundColor = "#000";
  tutorialOverlay.style.zIndex = "3000";
  tutorialOverlay.style.display = "flex";
  tutorialOverlay.style.justifyContent = "center";
  tutorialOverlay.style.alignItems = "center";
  tutorialOverlay.style.color = "#FFF";
  // Stack vertically
  tutorialOverlay.style.flexDirection = "column";

  const tutorialTextContainer = document.createElement("div");
  tutorialTextContainer.id = "tutorialTextContainer";
  tutorialTextContainer.style.fontSize = "2em";
  tutorialTextContainer.style.textAlign = "center";
  tutorialTextContainer.style.opacity = "0";
  tutorialTextContainer.style.transition = "opacity 1s ease";

  tutorialOverlay.appendChild(tutorialTextContainer);
  document.body.appendChild(tutorialOverlay);

  document.getElementById("mainContent").style.display = "none";
  document.getElementById("timerContainer").style.display = "none";
  document.getElementById("settingsPanel").style.display = "none";

  let phase = 0;
  let index = 0;
  let skipRequested = false;

  // Wartet, bis das mittlere C (MIDI-Note 60) gespielt wird
  function waitForMiddleC() {
    return navigator.requestMIDIAccess({ sysex: false }).then(midiAccess => {
      return new Promise(resolve => {
        const handler = (e) => {
          const [status, data1, data2] = e.data;
          if ((status & 0xf0) === 0x90 && data2 > 0 && data1 === 60) {
            resolve();
            midiAccess.inputs.forEach(input => {
              input.removeEventListener('midimessage', handler);
            });
          }
        };
        midiAccess.inputs.forEach(input => {
          input.addEventListener('midimessage', handler);
        });
      });
    });
  }

  function showNext() {
    if (phase >= steps.length) {
      // Fade-√úbergang zum Hauptscreen
      tutorialOverlay.style.transition = "opacity 1s";
      tutorialOverlay.style.opacity = "0";
      const mainContent = document.getElementById("mainContent");
      const timerContainer = document.getElementById("timerContainer");
      const settingsPanel = document.getElementById("settingsPanel");
      mainContent.style.display = "block";
      timerContainer.style.display = "flex";
      settingsPanel.style.display = "flex";
      mainContent.style.opacity = "0";
      timerContainer.style.opacity = "0";
      settingsPanel.style.opacity = "0";
      setTimeout(() => {
        mainContent.style.transition = "opacity 1s";
        timerContainer.style.transition = "opacity 1s";
        settingsPanel.style.transition = "opacity 1s";
        mainContent.style.opacity = "1";
        timerContainer.style.opacity = "1";
        settingsPanel.style.opacity = "1";
      }, 50);
      setTimeout(() => {
        tutorialOverlay.remove();
        localStorage.setItem("tutorialCompleted", "true");
      }, 1050);
      return;
    }
    const step = steps[phase];
    // Wenn alle Nachrichten dieser Phase durchlaufen sind, zur n√§chsten Phase wechseln
    if (index >= step.length) {
      phase++;
      index = 0;
      setTimeout(showNext, 500);
      return;
    }
    const message = step[index];
    // Nachricht ausblenden
    tutorialTextContainer.style.opacity = "0";
    setTimeout(() => {
      // Nachricht setzen und einblenden
      tutorialTextContainer.textContent = message;
      tutorialTextContainer.style.opacity = "1";
      // Spezielle Phase 1, Nachricht 2: auf das mittlere C warten
      if (phase === 1 && index === 1) {
        // Reset skip flag and show skip button
        skipRequested = false;
        const skipBtn = document.createElement("button");
        skipBtn.id = "tutorialSkipBtn";
        skipBtn.textContent = "√úberspringen";
        skipBtn.style.marginTop = "20px";
        // Style the skip button
        skipBtn.style.backgroundColor = "#000";
        skipBtn.style.color = "#FFF";
        skipBtn.style.border = "1px solid #FFF";
        skipBtn.style.padding = "0.5em 1em";
        skipBtn.style.cursor = "pointer";
        skipBtn.style.fontSize = "1em";
        skipBtn.style.borderRadius = "4px";
        skipBtn.style.boxShadow = "none";
        skipBtn.style.backgroundImage = "none";
        tutorialOverlay.appendChild(skipBtn);
        skipBtn.addEventListener("click", () => {
          skipRequested = true;
          skipBtn.remove();
          tutorialTextContainer.style.opacity = "0";
          setTimeout(() => {
            index++;
            showNext();
          }, 1000);
        });
        // Wait for middle C or skip
        waitForMiddleC().then(() => {
          skipBtn.remove();
          if (!skipRequested) {
            tutorialTextContainer.style.opacity = "0";
            setTimeout(() => {
              index++;
              showNext();
            }, 1000);
          }
        });
      } else {
        // Normales Weiterschalten nach 3 Sekunden
        index++;
        setTimeout(() => {
          tutorialTextContainer.style.opacity = "0";
          setTimeout(showNext, 1000);
        }, 3000);
      }
    }, 1000);
  }

  showNext();
}
// Starte das Hilfe-/Tutorial-Fenster beim Laden, falls noch nicht abgeschlossen
document.addEventListener("DOMContentLoaded", () => {
if (!localStorage.getItem('tutorialCompleted')) {
startTutorialSequence();
}
});
</script>
<style>
.vf-stavenote.selected path {
stroke: green !important;
fill: green !important;
}
.correction-letter {
font-size: 0.9em;
line-height: 1;
}
@keyframes flyOutRight {
from { opacity: 1; transform: translateX(0); }
to   { opacity: 0; transform: translateX(100%); }
}
@keyframes flyOutLeft {
from { opacity: 1; transform: translateX(0); }
to   { opacity: 0; transform: translateX(-100%); }
}
.fly-out-right {
animation: flyOutRight 0.5s forwards;
}
.fly-out-left {
animation: flyOutLeft 0.5s forwards;
}
@keyframes flyInRight {
from { opacity: 0; transform: translateX(100%); }
to   { opacity: 1; transform: translateX(0); }
}
@keyframes flyInLeft {
from { opacity: 0; transform: translateX(-100%); }
to   { opacity: 1; transform: translateX(0); }
}
.fly-in-right {
animation: flyInRight 0.5s forwards;
}
.fly-in-left {
animation: flyInLeft 0.5s forwards;
}
/* Intro Overlay Styles */
#introOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: white;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  transform: translateY(0);
  transition: transform 1s ease-in-out;
}
#introOverlay.hidden {
  transform: translateY(-100%);
}
/* Twemoji: Konsistente Emoji-Gr√∂√üe */
img.emoji {
  height: 1.2em;
  vertical-align: -0.1em;
}
</style>
<style>
/* Weniger Abstand des Notensystems nach oben */
#notation {
margin-top: 10px;
}
/* Scale-Clef-Buttons standardm√§√üig verbergen */
#scaleSelector {
display: none;
}
/* Styling f√ºr Oktaven-Buttons: wei√üer Hintergrund, schwarzer Rand */
#scaleSelector button {
background-color: white;
border: 2px solid black;
border-radius: 4px;
padding: 4px 8px;
cursor: pointer;
}
</style>
<style>
@media screen and (max-width: 768px) {
#settingsPanel,
#timerContainer,
#streakDisplay {
  display: none !important;
}
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qwerty-hancock/0.7.2/qwerty-hancock.min.js"></script>
<script>
// Intro Overlay Animation, ensure inside DOMContentLoaded
document.addEventListener("DOMContentLoaded", () => {
  const introOverlay = document.getElementById("introOverlay");
  setTimeout(() => {
    introOverlay.classList.add("hidden");
  }, 5000);
});
</script>
  <!-- Twemoji f√ºr Emoji-Darstellung -->
<script src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    twemoji.parse(document.body, {
      folder: 'svg',
      ext: '.svg'
    });
  });
</script>
<script>
// Doppelklick (bzw. Doppeltippen) auf Body: Geometrie-Modus speichern & schlie√üen
document.addEventListener("DOMContentLoaded", () => {
  document.body.addEventListener("dblclick", () => {
    // Hier die Funktion zum Speichern und Abschlie√üen des Geometrie-Modus aufrufen.
    // Beispiel:
    if (typeof saveGeometryMode === "function") {
      saveGeometryMode();
    }
    if (typeof closeGeometryMode === "function") {
      closeGeometryMode();
    }
    // Falls keine Funktionen existieren, kannst du stattdessen deine eigene Logik hier einf√ºgen.
  });
});
</script>
</head>
<body>
    <div id="introOverlay">
      <div id="introOverlayText">
        MIT ‚ù§Ô∏è ENTWICKELT VON <br>JAN-PHILIPP ZUSAMMEN MIT<p><img src="https://raw.githubusercontent.com/jp0024/piano.github.io/main/kklogo-1135x186.png" style="width:80%; height:80%";>
      </div>
    </div>
<!-- Direkt nach <body> einf√ºgen -->


<div id="streakDisplay"></div>
<!-- Canvas f√ºr Animation (Hintergrund) -->
<canvas id="animationCanvas"></canvas>
<!-- Audio-Element (deaktiviert) -->
<!--
<audio id="backgroundSound" autoplay>
    <source src="https://raw.githubusercontent.com/JP0024/piano.github.io/3d35e0a8d4eb3e018151018e36e225dc7a856ecd/mixkit-relaxing-harp-sweep-2628.wav" type="audio/wav">
        Dein Browser unterst√ºtzt das Audio-Element nicht.
</audio>
-->
<!-- Pause-Overlay -->
<div id="pauseOverlay">
    <div id="pauseInfo">
        <div id="pauseHeader">SESSION PAUSIERT</div>
        <div id="pauseProgressContainer">
          <div id="pauseProgress"></div>
          <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
          <div id="remainingNotesDisplay">${sessionCounter}</div>
        </div>
    </div>
    <!-- Kachelwand -->
    <div id="pauseTiles"></div>
</div>
<!-- Welcome Overlay -->
<div id="welcomeOverlay">
    <div id="welcomeMessage"><br>Sch√∂n, dass du da bist!<br></div>
</div>
<!-- Game Over Overlay -->
<div id="gameOverOverlay"></div>
<!-- Scoreboard Overlay -->
<div id="scoreboardOverlay" class="hidden"></div>
<!-- Motivationsfenster -->
<div id="motivationOverlay"></div>
<!-- Timer Container -->
<div id="timerContainer"></div>
<!-- Hauptinhalt -->
<div id="settingsPanel" style="position: fixed; top: 20%; right: 10px; background: rgba(255,255,255,0.8); padding: 10px; border: 2.5px solid #000; border-radius: 8px; z-index: 200;"></div>
<div id="mainContent">
  <div id="newsPopup" style="display:none; position:fixed; top:20px; left:20px; background:#fff; border:2px solid #000; border-radius:10px; padding:20px; max-width:300px; z-index:9999; box-shadow:0 4px 10px rgba(0,0,0,0.2);">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <strong>üÜï Neuigkeiten</strong>
      <span id="newsPopupClose" style="cursor:pointer; font-weight:bold;">‚úñ</span>
    </div>
    <div id="newsPopupContent" style="margin-top:10px; text-align: justify;">
      Willkommen zur neuen Version! üéâ Wir haben das Design minimalisitischer gestaltet.<p> Zudem findest du nun eine Fortschrittsanzeige neben dem Lagen-Button. Hier wird dir angezeigt, wie gut du derzeit in jeder Lage bist. Den Counter der zu spielenden Noten haben wir auch dort hin verschoben. Auch das Men√º wurde etwas vereinfacht.
    </div>
    <div class="separator"></div>
    <button id="chordButton">Akkorde</button>
  </div>
   
    <div id="notation"></div>
    <div id="noteChoiceGrid" class="hidden"></div>
    <div id="noteNameDisplay" style="position: fixed; left:50%; bottom:110px; transform: translateX(-50%); font-size:5em; text-transform: uppercase; z-index: 1000; pointer-events: auto;"></div>
    <div id="correctionBox" class="hidden">
      <div id="correctionChoices">
        <button id="prevNoteBtn">&lt;</button>
        <span id="correctionNoteDisplay">&lt; ? &gt;</span>
        <button id="nextNoteBtn">&gt;</button>
      </div>
      <button id="confirmNoteBtn">OK</button>
    </div>
    <div id="buttonContainer">
          <div id="lageProgressCircle"></div>
        
        <div id="lageButton" onclick="cycleLage()">C-Lage</div>
        <div id="toneButton" onclick="cycleTone()">A</div>
        <div id="heartsContainer" style="margin-left:10px;"></div>
    </div>
</div>
<!-- Einstellungen-Men√º -->

<script>
    // Separate Arrays f√ºr alte Lagen und Quintenzirkel-Tonarten
    const lageArray = ["C", "D", "F", "G", "MC"];
    const toneArray = ["A", "E", "B", "F#", "C#", "Ab", "Eb", "Bb"];
    let currentLageIndex = 0;
    let currentToneIndex = 0;
    // Initialisiere currentRange auf die erste Lage
    currentRange = lageArray[currentLageIndex];

    // Funktion zum Wechseln der alten Lagen
    function cycleLage() {
      currentLageIndex = (currentLageIndex + 1) % lageArray.length;
      currentRange = lageArray[currentLageIndex];
      document.getElementById("lageButton").textContent = currentRange + "-Lage";
      document.getElementById("lageButton").style.opacity = "1";
      document.getElementById("toneButton").style.opacity = "0.5";
      generateSeries();
    }
    window.cycleLage = cycleLage;

    // Funktion zum Wechseln der Quintenzirkel-Tonarten
    function cycleTone() {
      currentToneIndex = (currentToneIndex + 1) % toneArray.length;
      currentRange = toneArray[currentToneIndex];
      document.getElementById("toneButton").textContent = currentRange;
      document.getElementById("toneButton").style.opacity = "1";
      document.getElementById("lageButton").style.opacity = "0.5";
      generateSeries();
    }
    window.cycleTone = cycleTone;
    /* Falls im Pause-Modus: Aktualisiere Fortschrittsbalken und verbleibende Zeit (mm:ss) */
    function updatePauseProgress() {
        const noteDisplay = document.getElementById("remainingNotesDisplay");
        if (noteDisplay) noteDisplay.textContent = `${sessionCounter} Noten`;
        const progressBar = document.getElementById("pauseProgress");
        const timeDisplay = document.getElementById("pauseTime");
        if (progressBar && pauseDuration > 0) {
            const percent = ((pauseDuration - pauseRemaining) / pauseDuration) * 100;
            progressBar.style.width = percent + "%";
            if (timeDisplay) {
                const m = Math.floor(pauseRemaining / 60);
                const s = pauseRemaining % 60;
                timeDisplay.textContent = (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
            }
        }
    }
    
</script>

<script>
    let deferredPrompt;
    // Abfangen des beforeinstallprompt-Events und automatisches Ausl√∂sen des Prompts
    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        console.log('beforeinstallprompt Event empfangen');
        // Automatisch das Installations-Prompt ausl√∂sen
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
            if (choiceResult.outcome === 'accepted') {
                console.log('User accepted the PWA install prompt');
            } else {
                console.log('User dismissed the PWA install prompt');
            }
            deferredPrompt = null;
        });
    });
    
    // Falls die App installiert wurde, kann hier optional eine Logik implementiert werden
    window.addEventListener('appinstalled', () => {
        console.log('App wurde als PWA installiert');
    });
</script>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        // --- Smartphone-Lernmodus: UI anpassen, Hand-Toggle duplizieren ---
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
          // 1) Elemente ausblenden
          const settingsPanel = document.getElementById("settingsPanel");
          if (settingsPanel) settingsPanel.style.display = "none";
          const timerContainer = document.getElementById("timerContainer");
          if (timerContainer) timerContainer.style.display = "none";
          const streakDisplay = document.getElementById("streakDisplay");
          if (streakDisplay) streakDisplay.style.display = "none";
          const btnContainer = document.getElementById("buttonContainer");
          if (btnContainer) btnContainer.style.display = "none";

          // 2) Hand-Anzeige unten mittig klonen
          const handToggle = document.getElementById("handToggle");
          if (handToggle) {
            const mobileHand = handToggle.cloneNode(true);
            mobileHand.id = "mobileHandToggle";
            Object.assign(mobileHand.style, {
              position: "fixed",
              bottom: "20px",
              left: "50%",
              transform: "translateX(-50%)",
              fontSize: "2em",
              cursor: "pointer",
              zIndex: 1000
            });
            document.body.appendChild(mobileHand);
            mobileHand.addEventListener("click", () => {
              handToggle.click();
            });
          }

          // 3) Einzelnoten-Modus:
          window.isMobile = true;
          window.seriesLength = 1;
        }
        const settingsPanel = document.getElementById("settingsPanel");
        if (!settingsPanel) return;
        let fadeTimeout;
        const resetFadeTimer = () => {
            clearTimeout(fadeTimeout);
            // Setze sofort auf volle Opacity
            settingsPanel.style.opacity = "1";
            // Starte Timer: nach 10 Sekunden wird die Opacity auf 0.5 reduziert
            fadeTimeout = setTimeout(() => {
                settingsPanel.style.opacity = "0.5";
            }, 10000);
        };
        // Initialer Timer-Start
        resetFadeTimer();
        // Bei Maus- oder Touch-Interaktion den Timer zur√ºcksetzen
        settingsPanel.addEventListener("mouseenter", resetFadeTimer);
        settingsPanel.addEventListener("touchstart", resetFadeTimer);

        // Klick auf den Hintergrund im Mobilmodus: neue Note generieren und Korrekturanzeige √∂ffnen
        if (window.isMobile) {
          document.body.addEventListener("click", (e) => {
            const ignoreIds = [
              "mobileHandToggle", "handToggle",
              "toneButton", "lageButton",
              "settingsPanel", "buttonContainer",
              "timerContainer", "streakDisplay"
            ];
            if (e.target.id && ignoreIds.includes(e.target.id)) return;
            // Neue Note erzeugen
            generateSeries();
            wizardMode = true;
            seriesCounter = 0;
            drawSeries();
            // Korrekturanzeige anzeigen √ºber bestehende UI
            const correctRaw = currentSeriesSingle[seriesCounter].note;
            const choices = ["C","Cis","D","Dis","E","Eis","F","Fis","G","Gis","A","Ais","H"];
            // Setze expectedNote und availableNotes f√ºr vorhandene Korrekturbox
            expectedNote = correctRaw.toUpperCase();
            availableNotes = choices;
            selectedNoteIndex = 0;
            updateCorrectionDisplay();
            document.getElementById("correctionBox").classList.remove("hidden");
          });
        }
    });
    
    function getAllTrophies() {
        return [
                "üê¢","üêå","üö∂‚Äç‚ôÇÔ∏è","üèÉ","‚ö°",
                "üéº","üéπ","üé∫","ü™ï","ü™ó",
                "üå±","üåø","üåª","üå≤","üéÑ","üî•","üöÄ","ü™ê","üåû","üëë",
                "üîÄ","üåÄ","üîÅ","‚è©","‚öôÔ∏è",
                "üìè","üìê","üß≠","üéØ","üèÅ"
                ];
    }
    
    function showTrophyTransitionScreen(callback) {
        const overlay = document.getElementById("pauseOverlay");
        overlay.innerHTML = "";
        overlay.style.display = "flex";
        
        const trophyContainer = document.createElement("div");
        trophyContainer.style.display = "flex";
        trophyContainer.style.flexDirection = "column";
        trophyContainer.style.alignItems = "center";
        trophyContainer.style.justifyContent = "center";
        trophyContainer.style.opacity = "0";
        trophyContainer.style.transition = "opacity 1s";
        
        const newUnlocked = JSON.parse(sessionStorage.getItem("justUnlockedTrophies") || "[]");
        const justLost = JSON.parse(sessionStorage.getItem("justLostTrophies") || "[]");
        
        if (newUnlocked.length > 0) {
            const gainedTitle = document.createElement("h2");
            gainedTitle.textContent = isGerman ? "Neu freigeschaltet" : "Newly Unlocked";
            trophyContainer.appendChild(gainedTitle);
            
            newUnlocked.forEach(index => {
                const emoji = getAllTrophies()[index];
                const description = getTrophyDescription(index);
                const block = document.createElement("div");
                block.style.margin = "10px";
                block.style.fontSize = "1.5em";
                block.innerHTML = `<div>${emoji}</div><div style="font-size:0.8em">${description}</div>`;
                trophyContainer.appendChild(block);
            });
        }
        
        if (justLost.length > 0) {
            const lostTitle = document.createElement("h2");
            lostTitle.textContent = isGerman ? "Verloren" : "Lost";
            trophyContainer.appendChild(lostTitle);
            
            justLost.forEach(index => {
                const emoji = getAllTrophies()[index];
                const description = getTrophyDescription(index);
                const block = document.createElement("div");
                block.style.margin = "10px";
                block.style.opacity = "0.5";
                block.style.fontSize = "1.5em";
                block.innerHTML = `<div>${emoji}</div><div style="font-size:0.8em">${description}</div>`;
                trophyContainer.appendChild(block);
            });
        }
        
        overlay.appendChild(trophyContainer);
        
        // Fade-in
        setTimeout(() => {
            trophyContainer.style.opacity = "1";
        }, 100);
        
        // Nach 3 Sekunden weiter zur Session-Pause
        setTimeout(() => {
            overlay.style.opacity = "0";
            setTimeout(() => {
                overlay.style.display = "none";
                overlay.style.opacity = "1";
                callback();
            }, 1000);
        }, 3000);
    }
    
</script>
<script>
document.addEventListener("DOMContentLoaded", function() {
  // 1) Create hidden keyboard container
  const vk = document.createElement("div");
  vk.id = "virtualKeyboard";
  vk.style.position = "fixed";
  const bc = document.getElementById("buttonContainer");
  const bottomOffset = bc.offsetHeight + 15;
  vk.style.bottom = bottomOffset + "px";
  vk.style.left = "20px";
  vk.style.width = "calc(100% - 40px)";
  vk.style.height = "200px";
  vk.style.display = "none";
  document.body.appendChild(vk);

  // 2) Helper to convert note name to MIDI number
  function noteToMidi(note) {
    const semitones = { c:0, "c#":1, d:2, "d#":3, e:4, f:5, "f#":6, g:7, "g#":8, a:9, "a#":10, b:11 };
    const m = note.match(/^([a-g]#?)(\d)$/i);
    if (!m) return 60;
    const pitch = m[1].toLowerCase();
    const octave = parseInt(m[2], 10);
    return (octave + 1) * 12 + semitones[pitch];
  }

  // 3) Initialize Qwerty Hancock keyboard
  const keyboard = new QwertyHancock({
    id: "virtualKeyboard",
    width: window.innerWidth,
    height: 200,
    octaves: 1,
    startNote: "C4",
    whiteNotesColour: "#fff",
    blackNotesColour: "#000",
    hoverColour: "#f00"
  });
  keyboard.keyDown = (note, freq) => {
    const vk = document.getElementById("virtualKeyboard");
    const isVisible = vk && vk.style.display !== "none";
    if (!isVisible) return; // Prevent double trigger when not actively visible
    handleMIDIMessage(144, noteToMidi(note), 127);
  };
  keyboard.keyUp = () => {};

  // 4) Add toggle button to settings panel
  const btn = document.createElement("span");
  btn.id = "keyboardToggle";
  btn.textContent = "";
  btn.style.cursor = "pointer";
  const settingsPanel = document.getElementById("settingsPanel");
  if (settingsPanel) settingsPanel.appendChild(btn);


  btn.addEventListener("click", () => {
    if (vk.style.display === "none") {
      vk.style.display = "block";
      const kbHeight = vk.offsetHeight;
      document.getElementById("mainContent").style.marginBottom = kbHeight + "px";
      const noteDisplay = document.getElementById("noteNameDisplay");
      if (noteDisplay) noteDisplay.style.bottom = (kbHeight + 110) + "px";
    } else {
      vk.style.display = "none";
      document.getElementById("mainContent").style.marginBottom = "0";
      const noteDisplay = document.getElementById("noteNameDisplay");
      if (noteDisplay) noteDisplay.style.bottom = "110px";
    }
  });
});
</script>
<script>
  
    
    // Neuer Custom Mode JS (vereinfachte Version)
    document.addEventListener('DOMContentLoaded', function() {
      const modal = document.getElementById('customModeModal');
      if (!modal) return;

      // 1. Neue Mapping-Struktur f√ºr Kombination von Schl√ºssel + Lage
      const clefRangeMapping = {
        bass: {
          C: ["C", "D", "E", "F", "G", "A", "H"],
          D: ["d", "e", "f#", "g", "a"],
          F: ["f", "g", "a", "bb", "c"],
          G: ["g", "a", "h", "c", "d"],
          MC: ["c", "d", "e", "f", "g"]
        },
        treble: {
          C: ["c'", "d'", "e'", "f'", "g'", "a'", "h'"],
          D: ["d'", "e'", "f#'", "g'", "a'"],
          F: ["f'", "g'", "a'", "bb'", "c''"],
          G: ["g'", "a'", "h'", "c''", "d''"],
          MC: ["c'", "d'", "e'", "f'", "g'"]
        }
      };

      // 2. Neue globale Variablen
      let selectedClef = null;
      let selectedRange = null;

      // 3. Statische Oktaven und Noten-Checkboxen beim Laden/erstmaligem √ñffnen
      const content = document.getElementById('customModeContent');
      if (content) {
        content.innerHTML = '';
        const octaves = {
          "gro√üe Oktave": ["C", "D", "E", "F", "G", "A", "H"],
          "kleine Oktave": ["c", "d", "e", "f", "g", "a", "h"],
          "eingestrichene Oktave": ["c'", "d'", "e'", "f'", "g'", "a'", "h'"],
          "zweigestrichene Oktave": ["c''", "d''", "e''", "f''", "g''", "a''", "h''"],
        };
        Object.entries(octaves).forEach(([octaveName, notes]) => {
          const headline = document.createElement('div');
          headline.textContent = octaveName;
          headline.style.fontWeight = "bold";
          headline.style.marginTop = "10px";
          content.appendChild(headline);
          notes.forEach(note => {
            const label = document.createElement('label');
            label.style.marginRight = "8px";
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = note;
            checkbox.checked = false;
            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(note));
            content.appendChild(label);
          });
        });
      }

      // 4. Zentrale Aktualisierungsfunktion f√ºr Checkboxen
      function updateCustomModeCheckboxes() {
        if (!selectedClef || !selectedRange) return;
        const notesToActivate = clefRangeMapping[selectedClef][selectedRange] || [];
        const checkboxes = document.querySelectorAll('#customModeContent input[type=checkbox]');
        checkboxes.forEach(cb => {
          cb.checked = notesToActivate.includes(cb.value);
        });
      }

      // 5. Eventlistener f√ºr Lagen-Auswahl (Range)
      document.querySelectorAll('.custom-mode-range-option').forEach(el => {
        el.addEventListener('click', () => {
          document.querySelectorAll('.custom-mode-range-option').forEach(opt => opt.classList.remove('active'));
          el.classList.add('active');
          selectedRange = el.getAttribute('data-range');
          updateCustomModeCheckboxes();
        });
      });

      // 6. Eventlistener f√ºr Schl√ºsselauswahl (Clef)
      document.querySelectorAll('.custom-mode-clef-option').forEach(el => {
        el.addEventListener('click', () => {
          document.querySelectorAll('.custom-mode-clef-option').forEach(opt => opt.classList.remove('active'));
          el.classList.add('active');
          selectedClef = el.getAttribute('data-clef');
          updateCustomModeCheckboxes();
        });
      });

      // 7. Speichern-Button
      const saveBtn = document.getElementById('custom-mode-save-button');
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          const content = document.getElementById('customModeContent');
          if (!selectedClef || !selectedRange || !content) return;
          const selected = Array.from(content.querySelectorAll('input[type=checkbox]'))
            .filter(cb => cb.checked)
            .map(cb => cb.value);
          // Notenwert-Checkbox
          const noteValueCheckbox = document.getElementById('noteValueCheckbox');
          const noteValue = noteValueCheckbox && noteValueCheckbox.checked ? "8" : "q";
          window.customModeSettings = {
            clef: selectedClef,
            range: selectedRange,
            selectedNotes: selected.map(n => n.replace(/'/g, "").toLowerCase()),
            noteValue: noteValue
          };
          // clefTitle aktualisieren
          const clefTitle = document.getElementById("clefTitle");
          if (clefTitle && selectedRange) {
            clefTitle.textContent = selectedRange + "-Lage";
          }
          generateSeries();
          modal.classList.add('hidden');
        });
      }
    });
    
    window.addEventListener("DOMContentLoaded", () => {
      const confirmBtn = document.getElementById("confirmScaleSelection");
      if (confirmBtn) {
        confirmBtn.addEventListener("click", () => {
          if (selectedMode === "scale" && selectedNotes.length > 0) {
            localStorage.setItem("customOneHandNotes", JSON.stringify(selectedNotes));
            selectedMode = "left";
            seriesCounter = 0;
            correctNoteCount = 0;

            currentSeriesSingle = Array.from({ length: 1000 }, () => {
              const i = Math.floor(Math.random() * selectedNotes.length);
              return selectedNotes[i];
            });

            drawSeries();
          } else {
            alert("Bitte mindestens eine Note ausw√§hlen, bevor du speicherst!");
          }
        });
      }
    });
</script>

<div id="customModeModal" class="hidden">
    <h2>Benutzerdefiniert</h2>
    <div class="custom-mode-row">
        <!-- Notenschl√ºssel & Lagen-Auswahl -->
        <div class="custom-mode-clef-container">
            <div class="custom-mode-clef-option" data-clef="treble">üéº</div>
            <div class="custom-mode-clef-option" data-clef="bass">ùÑ¢</div>
        </div>
        <div class="custom-mode-range-container">
            <div class="custom-mode-range-option" data-range="C">C</div>
            <div class="custom-mode-range-option" data-range="D">D</div>
            <div class="custom-mode-range-option" data-range="F">F</div>
            <div class="custom-mode-range-option" data-range="G">G</div>
            <div class="custom-mode-range-option" data-range="MC">MC</div>
        </div>
    </div>
    <div id="customModeContent" style="margin-top: 10px;">
      <!-- Hier werden dynamisch Oktavennamen und Checkboxen eingef√ºgt -->
    </div>
    <div class="custom-mode-row">
        <label for="noteValueCheckbox" style="font-weight: bold;">Wertvariation</label>
        <input type="checkbox" id="noteValueCheckbox" />
      </div>
    <div class="custom-mode-save">
        <button id="custom-mode-save-button">Speichern</button>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('customModeModal');
        if (!modal) {
            console.error('Modal nicht gefunden.');
            return;
        }

        let selectedCustomClef = null;
        let selectedCustomRange = null;

        // Eventlistener f√ºr Schl√ºsselauswahl
        document.querySelectorAll('.custom-mode-clef-option').forEach(el => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.custom-mode-clef-option').forEach(opt => opt.classList.remove('active'));
                el.classList.add('active');
                selectedCustomClef = el.getAttribute('data-clef');
                populateCustomNotes();
            });
        });

        // Eventlistener f√ºr Lagen-Auswahl
        document.querySelectorAll('.custom-mode-range-option').forEach(el => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.custom-mode-range-option').forEach(opt => opt.classList.remove('active'));
                el.classList.add('active');
                selectedCustomRange = el.getAttribute('data-range');
                populateCustomNotes();
            });
        });

        // Notenzuordnungen f√ºr linke und rechte Hand
        const customLeftNotesMapping = {
            "C": ["C", "D", "E", "F", "G", "A"],
            "D": ["D", "E", "F#", "G", "A", "B"],
            "F": ["F", "G", "A", "Bb", "C"],
            "G": ["G", "A", "B", "C", "D", "E"],
            "MC": ["F", "G", "A", "B", "C"]
        };
        const customRightNotesMapping = {
            "C": ["C", "D", "E", "F", "G", "A"],
            "D": ["D", "E", "F#", "G", "A", "B"],
            "F": ["F", "G", "A", "Bb", "C"],
            "G": ["G", "A", "B", "C", "D", "E"],
            "MC": ["F", "G", "A", "B", "C"]
        };

        // Funktion, um basierend auf der ausgew√§hlten Lage die Noten f√ºr linke und rechte Hand zu bef√ºllen
        function populateCustomNotes() {
            if (!selectedCustomRange) return;
            const leftContainer = document.getElementById('left-hand-notes');
            const rightContainer = document.getElementById('right-hand-notes');
            if (!leftContainer || !rightContainer) {
                console.error('Noten-Container nicht gefunden.');
                return;
            }
            leftContainer.innerHTML = '';
            rightContainer.innerHTML = '';

            customLeftNotesMapping[selectedCustomRange].forEach(note => {
                const noteEl = document.createElement('div');
                noteEl.className = 'custom-mode-note-option';
                noteEl.textContent = note;
                noteEl.setAttribute('data-note', note);
                noteEl.addEventListener('click', () => {
                    noteEl.classList.toggle('active');
                });
                leftContainer.appendChild(noteEl);
            });

            customRightNotesMapping[selectedCustomRange].forEach(note => {
                const noteEl = document.createElement('div');
                noteEl.className = 'custom-mode-note-option';
                noteEl.textContent = note;
                noteEl.setAttribute('data-note', note);
                noteEl.addEventListener('click', () => {
                    noteEl.classList.toggle('active');
                });
                rightContainer.appendChild(noteEl);
            });
        }

        // Eventlistener f√ºr den Speichern-Button im Custom Mode Modal
        const saveButton = document.getElementById('custom-mode-save-button');
        if (saveButton) {
            saveButton.addEventListener('click', () => {
                const activeClef = document.querySelector('.custom-mode-clef-option.active');
                const activeRange = document.querySelector('.custom-mode-range-option.active');
                const activeLeftNotes = document.querySelectorAll('#left-hand-notes .custom-mode-note-option.active');
                const activeRightNotes = document.querySelectorAll('#right-hand-notes .custom-mode-note-option.active');
                const noteValueCheckbox = document.getElementById('noteValueCheckbox');
                const noteValue = noteValueCheckbox.checked ? "8" : "q";  // "8" f√ºr Achtelnoten, "q" als Standard (Viertelnoten)
                
                const settings = {
                    clef: activeClef ? activeClef.getAttribute('data-clef') : null,
                    range: activeRange ? activeRange.getAttribute('data-range') : null,
                    leftNotes: Array.from(activeLeftNotes).map(el => el.getAttribute('data-note')),
                    rightNotes: Array.from(activeRightNotes).map(el => el.getAttribute('data-note')),
                    noteValue: noteValue
                };
                
                console.log("Benutzerdefinierte Einstellungen:", settings);
                window.customModeSettings = settings;
                modal.classList.add('hidden');
                
                // Aktualisiere den Lagen-Button (clefTitle)
                const clefTitle = document.getElementById("clefTitle");
                if (clefTitle && settings.range) {
                    clefTitle.textContent = settings.range + "-Lage";
                }
                
                generateSeries();
            });
        } else {
            console.warn('Speichern-Button nicht gefunden.');
        }
    });
    
    function showCorrection(note, choices) {
      correctionActive = true;
      expectedNote = note;
      availableNotes = choices;
      selectedNoteIndex = 0;
      updateCorrectionDisplay();
      document.getElementById("correctionBox").classList.remove("hidden");
    }

    function updateCorrectionDisplay(result) {
      const display = document.getElementById("correctionNoteDisplay");
      const confirm = document.getElementById("confirmNoteBtn");
      if (result === "correct") {
        confirm.textContent = "ü•≥";
      } else if (result === "wrong") {
        confirm.textContent = "‚ùå";
      } else {
        confirm.textContent = "OK";
      }
      display.textContent = `< ${availableNotes[selectedNoteIndex] || "?"} >`;
    }

    const prevNoteBtn = document.getElementById("prevNoteBtn");
    if (prevNoteBtn) {
      prevNoteBtn.addEventListener("click", () => {
        selectedNoteIndex = (selectedNoteIndex - 1 + availableNotes.length) % availableNotes.length;
        updateCorrectionDisplay();
      });
    }

    const nextNoteBtn = document.getElementById("nextNoteBtn");
    if (nextNoteBtn) {
      nextNoteBtn.addEventListener("click", () => {
        selectedNoteIndex = (selectedNoteIndex + 1) % availableNotes.length;
        updateCorrectionDisplay();
      });
    }

    const confirmNoteBtn = document.getElementById("confirmNoteBtn");
    if (confirmNoteBtn) {
      confirmNoteBtn.addEventListener("click", () => {
        const selected = availableNotes[selectedNoteIndex];
        if (selected === expectedNote) {
          updateCorrectionDisplay("correct");
          setTimeout(() => {
            document.getElementById("correctionBox").classList.add("hidden");
            correctionActive = false;
            resetGame(); // oder n√§chster Schritt
          }, 1000);
        } else {
          updateCorrectionDisplay("wrong");
        }
      });
    }

    function handleCorrectionInput(notePlayed) {
      if (!correctionActive) return;
      if (notePlayed === expectedNote) {
        updateCorrectionDisplay("correct");
        setTimeout(() => {
          document.getElementById("correctionBox").classList.add("hidden");
          correctionActive = false;
          resetGame();
        }, 1000);
      } else {
        updateCorrectionDisplay("wrong");
      }
    }
    
      function showCorrection(note, choices) {
        correctionActive = true;
        expectedNote = note;
        availableNotes = choices;

        let container = document.getElementById('correctionContainer');
        if (!container) {
          container = document.createElement('div');
          container.id = 'correctionContainer';
          Object.assign(container.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: '#fff',
            padding: '20px',
            border: '2px solid #000',
            zIndex: '1000'
          });
          document.body.appendChild(container);
        }
        container.innerHTML = '';

        choices.forEach(choice => {
          const btn = document.createElement('div');
          btn.textContent = choice.toUpperCase();
          btn.className = 'correction-choice';
          btn.addEventListener('click', () => {
            if (btn.textContent === expectedNote.toUpperCase()) {
              btn.style.opacity = '1';
              btn.style.backgroundColor = 'green';
            } else {
              btn.style.opacity = '1';
              btn.style.backgroundColor = 'red';
              const correctBtn = Array.from(container.children)
                .find(child => child.textContent === expectedNote.toUpperCase());
              if (correctBtn) correctBtn.style.backgroundColor = 'yellow';
            }
            setTimeout(() => {
              container.remove();
              correctionActive = false;
              resetGame();
            }, 1000);
          });
          container.appendChild(btn);
        });
      }
    </script>
<script>
    // Referenzen
    const settingsPanel       = document.getElementById('settingsPanel');
    const emojiContainer      = document.getElementById('settingsEmojiContainer');
    const emojiItems = emojiContainer ? emojiContainer.querySelectorAll('.settings-emoji') : [];

    // --- A) Long-Press (3 Sekunden) zum Auf-/Zuklappen ---
    let longPressTimer;
    settingsPanel.addEventListener('pointerdown', () => {
      longPressTimer = setTimeout(() => {
        settingsPanel.classList.toggle('expanded');
      }, 3000); // 3000 ms = 3 s
    });
    ['pointerup','pointerleave','pointercancel'].forEach(evt =>
      settingsPanel.addEventListener(evt, () => clearTimeout(longPressTimer))
    );
    // --- B) Drag-n-Drop zum Umordnen und Speichern ---
    let dragged = null;
    emojiItems.forEach(item => {
      item.addEventListener('dragstart',  e => { dragged = item; });
      item.addEventListener('dragover',   e => { e.preventDefault(); item.classList.add('drag-over'); });
      item.addEventListener('dragleave',  () => { item.classList.remove('drag-over'); });
      item.addEventListener('drop',       e => {
        e.preventDefault();
        item.classList.remove('drag-over');
        if (dragged && dragged !== item) {
          // Zeige Korrekturanzeige wie im Standardmodus
          const correctRaw = currentSeriesSingle[seriesCounter].note;
          // Deutsche Auswahl-Liste wie in der Korrektur-UI
          const choices = ["C","Cis","D","Dis","E","Eis","F","F'is","G","G'is","A","A'is","H"];
          showCorrection(correctRaw.toUpperCase(), choices);

          // Reihenfolge in DOM anpassen
          const nodes = Array.from(emojiContainer.children);
          const from = nodes.indexOf(dragged);
          const to   = nodes.indexOf(item);
          if (from < to) emojiContainer.insertBefore(dragged, item.nextSibling);
          else           emojiContainer.insertBefore(dragged, item);
          // Neue Reihenfolge speichern
          const order = Array.from(emojiContainer.children).map(el => el.textContent);
          localStorage.setItem('settingsEmojiOrder', JSON.stringify(order));
        }
      });
    });

    // --- C) Reihenfolge beim Laden wiederherstellen ---
    const savedOrder = JSON.parse(localStorage.getItem('settingsEmojiOrder')||'[]');
    if (savedOrder.length) {
      savedOrder.forEach(sym => {
        const el = Array.from(emojiContainer.children)
                        .find(span => span.textContent === sym);
        if (el) emojiContainer.appendChild(el);
      });
    }
    
    const lageColors = {
      "C": "#007AFF",  // blau
      "G": "#34C759",  // gr√ºn
      "D": "#FF9500",  // orange
      "A": "#FF2D55",  // pink/rot
      "E": "#AF52DE",  // violett
      "B": "#FFD60A",  // gelb
      "F#": "#FF375F",
      "C#": "#5AC8FA",
      "Ab": "#4CD964",
      "Eb": "#5856D6",
      "Bb": "#FFCC00",
      "F": "#FF3B30"
    };
    
    let lageProgress = JSON.parse(localStorage.getItem("lageProgress") || "{}");
    // Initialisieren, falls noch nicht vorhanden
    rangeArray.forEach(lage => {
      if (!lageProgress[lage]) lageProgress[lage] = 0;
    });
    
    function drawLageProgress(lage, value) {
      const color = lageColors[lage] || "#007AFF";
      const circle = document.getElementById("lageProgressCircle");
      circle.innerHTML = ""; // clear previous

      // SVG Kreis
      const size = 60;
      const stroke = 12;
      const radius = (size/2) - (stroke/2);
      const circumference = 2 * Math.PI * radius;
      const progress = Math.max(0, Math.min(100, value)); // clamp
      const offset = circumference * (1 - progress/100);

      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", size);
      svg.setAttribute("height", size);
      svg.classList.add("lage-progress-svg");

      // Hintergrund-Kreis
      const bgCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      bgCircle.setAttribute("cx", size/2);
      bgCircle.setAttribute("cy", size/2);
      bgCircle.setAttribute("r", radius);
      bgCircle.setAttribute("stroke", "#eee");
      bgCircle.setAttribute("stroke-width", stroke);
      bgCircle.setAttribute("fill", "none");

      // Progress-Kreis
      const fgCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      fgCircle.setAttribute("cx", size/2);
      fgCircle.setAttribute("cy", size/2);
      fgCircle.setAttribute("r", radius);
      fgCircle.setAttribute("stroke", color);
      fgCircle.setAttribute("stroke-width", stroke);
      fgCircle.setAttribute("fill", "none");
      fgCircle.setAttribute("stroke-linecap", "round");
      fgCircle.setAttribute("stroke-dasharray", circumference);
      fgCircle.setAttribute("stroke-dashoffset", offset);
      fgCircle.setAttribute("transform", `rotate(-90 ${size/2} ${size/2})`);

      svg.appendChild(bgCircle);
      svg.appendChild(fgCircle);

      circle.appendChild(svg);

      // Prozentzahl in die Mitte
      const txt = document.createElement("div");
      txt.className = "lage-progress-text";
      txt.style.fontSize = "0.7em";
      txt.textContent = `${sessionCounter}`;
      circle.appendChild(txt);

      // Add click handler to circle for sessionCounter overlay input
      circle.style.cursor = "pointer";

      // Bestehendes Eingabefeld entfernen, falls vorhanden
      const existingInput = document.getElementById("counterInputOverlay");
      if (existingInput) existingInput.remove();

      circle.addEventListener("click", () => {
        const overlay = document.createElement("div");
        overlay.id = "counterInputOverlay";
        Object.assign(overlay.style, {
          position: "fixed",
          top: "0",
          left: "0",
          width: "100vw",
          height: "100vh",
          background: "rgba(0,0,0,0.6)",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          zIndex: "5000"
        });

        const inputBox = document.createElement("div");
        Object.assign(inputBox.style, {
          background: "#fff",
          padding: "20px",
          borderRadius: "10px",
          textAlign: "center",
          fontSize: "1.2em"
        });

        const label = document.createElement("label");
        label.textContent = "Anzahl der Noten:";
        label.style.display = "block";
        label.style.marginBottom = "10px";

        const input = document.createElement("input");
        input.type = "number";
        input.min = "1";
        input.value = sessionCounter;
        input.style.width = "100px";
        input.style.fontSize = "1.2em";

        const btn = document.createElement("button");
        btn.textContent = "OK";
        btn.style.marginTop = "15px";
        btn.style.padding = "6px 12px";
        btn.style.fontSize = "1em";
        btn.style.cursor = "pointer";

        btn.onclick = () => {
          const parsed = parseInt(input.value);
          if (!isNaN(parsed) && parsed > 0) {
            sessionCounter = parsed;
            localStorage.setItem("customSessionCounter", sessionCounter);
            drawLageProgress(lage, value);
          }
          overlay.remove();
        };

        inputBox.appendChild(label);
        inputBox.appendChild(input);
        inputBox.appendChild(btn);
        overlay.appendChild(inputBox);
        document.body.appendChild(overlay);
      });
    }
    
    function updateLageProgress(correct) {
      // aktuelle Lage aus globalem State:
      const lage = currentRange;
      let val = lageProgress[lage] || 0;
      if (correct) {
        val += 4; // z.B. 4% f√ºr richtige Note
      } else {
        val -= 8; // z.B. 8% Abzug f√ºr Fehler
      }
      val = Math.max(0, Math.min(100, val));
      lageProgress[lage] = val;
      localStorage.setItem("lageProgress", JSON.stringify(lageProgress));
      drawLageProgress(lage, val);
      // Ensure the display is updated after progress change
    }
    
    function onLageChanged(newLage) {
      drawLageProgress(newLage, lageProgress[newLage] || 0);
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      drawLageProgress(currentRange, lageProgress[currentRange] || 0);
    });
    // News-Popup-Block
    document.addEventListener("DOMContentLoaded", () => {
      const newsId = "v1.4-update"; // Diese ID bei jeder neuen Nachricht √§ndern
      const cookieKey = "newsDismissed_" + newsId;
      const dismissed = localStorage.getItem(cookieKey);

      if (!dismissed) {
        const popup = document.getElementById("newsPopup");
        if (popup) popup.style.display = "block";

        const closeBtn = document.getElementById("newsPopupClose");
        if (closeBtn) {
          closeBtn.addEventListener("click", () => {
            popup.style.display = "none";
            localStorage.setItem(cookieKey, "true");
          });
        }
      }
    });
    
function showPlayerList() {
      // Hide main content and notation while player list is shown
      const mainContent = document.getElementById("mainContent");
      if (mainContent) mainContent.style.display = "none";
      const notationDiv = document.getElementById("notation");
      if (notationDiv) notationDiv.style.display = "none";

      let overlay = document.getElementById("playerOverlay");
      if (!overlay) {
        overlay = document.createElement("div");
        overlay.id = "playerOverlay";
        Object.assign(overlay.style, {
          position: "fixed", top: "50%", left: "50%",
          transform: "translate(-50%, -50%)",
          background: "#fff", border: "2px solid #000",
          borderRadius: "10px", padding: "20px",
          zIndex: "9999", maxHeight: "80vh",
          overflowY: "auto", textAlign: "center",
          minWidth: "300px"
        });
        document.body.appendChild(overlay);
      }

      const stats = JSON.parse(localStorage.getItem("playerStats") || "{}");
      const players = Object.entries(stats).map(([name, data]) => {
        const sum = Object.values(data).reduce((a, b) => a + b, 0);
        const avg = sum > 0 ? Math.round(sum / Object.values(data).length) : 0;
        return { name, avg };
      }).sort((a, b) => b.avg - a.avg);

      overlay.innerHTML = `
    <div style="background:#fff; padding:20px; border:2px solid #000; border-radius:10px; text-align:center; max-width:400px; width:90%;">
      <h2>Highscores</h2>
      <table style="width:100%; border-collapse:collapse; font-size:1.1em;">
        <thead>
          <tr>
            <th style="border-bottom:1px solid #000; padding:8px;">Name</th>
            <th style="border-bottom:1px solid #000; padding:8px;">√ò (%)</th>
            <th style="border-bottom:1px solid #000; padding:8px;">Details</th>
          </tr>
        </thead>
        <tbody>
          ${
            players.map(p => {
              const stats = JSON.parse(localStorage.getItem("playerStats") || "{}")[p.name] || {};
              const detail = Object.entries(stats).map(([k, v]) => `${k}: ${v}`).join(", ");
              return `
              <tr style="cursor:pointer;" onclick="selectPlayer('${p.name}')" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='transparent'">
                <td style="padding:8px; border-bottom:1px solid #ccc;">${p.name}</td>
                <td style="padding:8px; border-bottom:1px solid #ccc;">${p.avg}</td>
                <td style="padding:8px; border-bottom:1px solid #ccc;">${detail}</td>
              </tr>`;
            }).join("")
          }
          <tr id="addPlayerRow" style="background-color:#eef;" onmouseover="this.style.background='#ddeeff'" onmouseout="this.style.background='#eef'">
        </tbody>
  <input id="newPlayerInput" type="text" placeholder="Name eingeben‚Ä¶" style="margin-top:8px; padding:4px; font-size:1em;" onkeydown="if(event.key==='Enter'){submitNewPlayer();}" />
      </table>
      <button id="playerOverlayCloseBtn" style="margin-top:15px; padding:8px 16px; border:2px solid #000; border-radius:6px; background:#fff; cursor:pointer;">Zur√ºck</button>
    </div>
  `;
      const closeBtn = document.getElementById('playerOverlayCloseBtn');
      if (closeBtn) closeBtn.addEventListener('click', closePlayerList);
      overlay.style.display = "block";
    }

    // Expose to global scope so inline onclick handlers work
    window.closePlayerList = function closePlayerList() {
      // Remove the overlay and restore main UI
      const overlay = document.getElementById("playerOverlay");
      if (overlay) overlay.remove();
      const mainContent = document.getElementById("mainContent");
      if (mainContent) mainContent.style.display = "block";
      const notationDiv = document.getElementById("notation");
      if (notationDiv) notationDiv.style.display = "block";
    }
    // Handler f√ºr neuen Spieler anlegen (Eingabe-UI)
    function submitNewPlayer() {
      const input = document.getElementById("newPlayerInput");
      if (!input) return;
      const name = input.value.trim();
      if (name) {
        const existing = JSON.parse(localStorage.getItem("playerStats") || "{}");
        if (!existing[name]) {
          existing[name] = {};
          localStorage.setItem("playerStats", JSON.stringify(existing));
        }
        localStorage.setItem("userName", name);
        closePlayerList();
        location.reload();
      } else {
        input.focus();
      }
    }
    function selectPlayer(name) {
      localStorage.setItem("userName", name);
      closePlayerList();
      location.reload(); // neu laden, um Werte und Begr√º√üung zu aktualisieren
    }
    function savePlayerStats(range, isCorrect) {
      const name = localStorage.getItem("userName") || "Gast";
      const data = JSON.parse(localStorage.getItem("playerStats") || "{}");
      if (!data[name]) data[name] = {};
      if (!data[name][range]) data[name][range] = 0;
      if (isCorrect) data[name][range] += 1;
      localStorage.setItem("playerStats", JSON.stringify(data));
    }
    
    document.addEventListener("dblclick", () => {
      const geometryToggle = document.getElementById("geometryToggle");
      if (geometryToggle) {
        geometryToggle.click(); // Toggle den Geometriemodus
      }
    });
    
    let lastTap = 0;
    document.addEventListener("touchend", function(e) {
      const currentTime = new Date().getTime();
      const tapLength = currentTime - lastTap;
      if (tapLength < 300 && tapLength > 0) {
        // Doppeltipp erkannt
        const geometryToggle = document.getElementById("geometryToggle");
        if (geometryToggle) {
          geometryToggle.click();
        }
      }
      lastTap = currentTime;
    });
</script>
<div id="chordModal">
  <h2>Akkordauswahl</h2>
  <div id="chordList"></div>
  <span class="confirm-chords">‚úÖ</span>
</div>
</body>
</html>

    
    
