<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Notentraining - Anpassung</title>
  <!-- VexFlow laden -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <!-- canvas-confetti laden -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    /* Grundlayout */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #ffffff;
      font-family: sans-serif;
      text-align: center;
      transition: background-color 0.3s, color 0.3s;
      overflow: hidden;
    }

    body.dark-mode {
      background-color: #121212;
      color: #e0e0e0;
    }
    /* Vollbild-Canvas f√ºr Animation (Hintergrund) */
    #animationCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      filter: blur(20px);
      opacity: 0.2;
    }
    /* Einhand-Notation (normaler Modus) */
    #notation {
      display: none;
      position: fixed;
      top: 70%;
      left: 70%;
      transform: translate(-50%, -50%);
      width: 100%;
      max-width: calc(100% - 10px);
      padding: 10px;
      box-sizing: border-box;
      z-index: 1;
    }
    #notation svg {
      width: 100%;
      height: auto;
      shape-rendering: crispEdges;
      display: block;
      margin: 0 auto;
    }
    #notation svg * {
      vector-effect: non-scaling-stroke;
    }
    body.dark-mode #notation svg * {
      stroke: #fff;
      fill: #fff;
    }
    /* Motivationsfenster */
    #motivationOverlay {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      font-size: 2em;
      color: #000;
      text-shadow: none;
    }
    @keyframes floatFade {
      0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
    }
    .animate-motivation {
      animation: floatFade 2.5s ease-out forwards;
    }
    /* Pause-Overlay */
    #pauseOverlay {
      position: fixed;
      top: 15px;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      z-index: 1000;
      display: none;
      flex-direction: column;
    }
    /* Obere Info-Leiste im Pausenmodus */
    #pauseInfo {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }
    #pauseHeader {
      font-size: 2em;
      font-weight: bold;
      color: #000;
      white-space: nowrap;
    }
    /* Fortschrittsbalken */
    #pauseProgressContainer {
      flex-grow: 1;
      height: 20px;
      border: 3px solid #000;
      border-radius: 20px;
      position: relative;
      background: #fff;
    }
    #pauseProgress {
      height: 100%;
      width: 0%;
      background: red;
      border-radius: 20px;
      transition: width 1s linear;
    }
    /* Verbleibende Zeit im Format mm:ss */
    #pauseTime {
      font-size: 14px;
      color: #000;
      white-space: nowrap;
      margin-left: 10px;
    }
    /* Kachelwand im Pausenmodus ‚Äì F√ºllt den restlichen Raum wie eine Tapete */
    #pauseTiles {
      flex-grow: 1;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      grid-auto-rows: 230px;
      gap: 12px;
      overflow-y: auto;
    }
    /* Variierende Kacheln (Mauerstein-Effekt) */
    .tile:nth-child(3n) {
      grid-row: span 2;
    }
    .tile:nth-child(4n) {
      grid-column: span 2;
    }
    .tile {
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 15px;
      font-size: 14px;
      color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }
    .tileIcon {
      font-size: 5em;
      margin-bottom: 8px;
    }
    .tileTitle {
      font-size: 3em;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .tileValue {
      font-size: 2.5em;
      font-weight: normal;
    }
    .barChart {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      width: 100%;
      margin-top: 5px;
      gap: 5px;
    }
    .bar {
      width: 10%;
      background-color: #007aff;
      border-radius: 4px 4px 0 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      color: #fff;
      font-size: 0.8em;
    }
    /* Game Over Overlay */
    #gameOverOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: none;
    }
    body.dark-mode #gameOverOverlay {
      border: 3px solid #fff;
    }
    /* Scoreboard Overlay */
    #scoreboardOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: block;
    }
    .hidden {
      display: none !important;
    }
    /* Timer Container */
    /* Timer Container */
        #timerContainer {
          position: fixed;
          right: 10px;
          bottom: 30px;
          font-size: 1.5em;
          z-index: 100;
          display: none; /* Versteckt, bis der Intro-Modus beendet ist */
          align-items: center;
          justify-content: center;
          cursor: pointer;
          background: rgba(255, 255, 255, 0.8);
          padding: 5px 10px;
          border-radius: 5px;
        }
    /* Hauptinhalt */
    #mainContent {
      display: none;
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease-in;
      padding-bottom: 50px;
    }
    /* Einstellungen-Men√º */
    #settingsPanel {
      /* Behalte deine Positionierung bei */
      position: fixed;
      top: 23%;
      right: 20px;
      display: none; /* wird sp√§ter per JS auf 'flex' gesetzt */
      flex-direction: column;
      align-items: center;
      z-index: 10;

      /* 3D-Optik */
      background: white;               /* Heller Pastellton */
      border: 2px solid black;         /* Passender Randton */
      border-radius: 8px;
      box-shadow:
        0 6px 0 black,                 /* ‚Äûfester‚Äú Schatten f√ºr die 3D-Kante */
        0 6px 6px rgba(0, 0, 0, 0.2);    /* Weicher Schlagschatten */
      padding: 16px 24px;                /* Innenabstand */
      margin: 8px;                       /* Au√üenabstand */
      font-size: 1.2em;                  /* Schriftgr√∂√üe */
      text-align: center;
      color: black;
      box-sizing: border-box;

      /* Animation/√úberg√§nge beim Dr√ºcken */
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #settingsPanel:active {
      transform: translateY(6px);
      box-shadow:
        0 0 0 #abc9ab,
        0 6px 6px rgba(0,0,0,0.2);
    }

    /* ================================= */
    /* 3D-Stil f√ºr das Lagen-Rechteck    */
    /* ================================= */
    #clefTitle {
      background: #d0e8d0;
      border: 2px solid #b7d3b7;
      border-radius: 8px;
      box-shadow:
        0 6px 0 black,
        0 6px 6px rgba(0, 0, 0, 0.2);
      padding: 16px 24px;
      margin: 8px;
      font-size: 1.2em;
      text-align: center;
      color: #333;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #clefTitle:active {
      transform: translateY(6px);
      box-shadow:
        0 0 0 #abc9ab,
        0 6px 6px rgba(0, 0, 0, 0.2);
    }
    body.dark-mode #settingsPanel {
      background: #000;
      border-color: #fff;
    }
    #settingsPanel span {
      display: block;
      cursor: pointer;
      font-size: 1.8em;
      margin: 8px 0;
      padding: 2px;
      text-align: center;
      background: none;
      border: none;
      transition: background 0.2s, opacity 0.2s;
    }
    #settingsPanel span:hover {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    /* Lagewechsel-Button */
    #clefTitle {
      display: inline-block;
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
    }
    body.dark-mode #clefTitle {
      background: #000;
      border-color: #fff;
      color: #fff;
    }
    /* Neuer Pausen-Button im Men√º */
    #pauseButton {
      display: inline-block;
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
      margin-top: 10px;
    }
    body.dark-mode #pauseButton {
      background: #000;
      border-color: #fff;
      color: #fff;
    }
    /* Container f√ºr Button & Herzen */
    #buttonContainer {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      z-index: 50;
    }
    #heartsContainer {
      display: inline-block;
      margin-left: 10px;
      vertical-align: middle;
      font-size: 1.5em;
    }
    /* Notenname-Anzeige (normaler Modus) */
    #noteNameDisplay {
      margin-top: 10px;
      font-size: 24px;
      color: #000;
      text-transform: uppercase;
    }
    body.dark-mode #noteNameDisplay { color: #e0e0e0; }
    /* Welcome Overlay */
    #welcomeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
      background-color: transparent;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #welcomeMessage {
      font-size: 2.5em;
      color: #000;
      margin-bottom: 20px;
      font-weight: bold;
    }
    body.dark-mode #welcomeMessage { color: #e0e0e0; }
    
    .bar-chart-container {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      width: 100%;
      padding: 10px;
      height: 120px; /* Gesamth√∂he inkl. Label */
    }

    .bar-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .bar {
      width: 100%;
      background: linear-gradient(to top, black, grey);
      border-radius: 4px 4px 0 0;
      transition: height 0.5s ease-in-out;
    }

    .bar-label {
      margin-top: 4px;
      font-size: 0.9em;
      text-align: center;
      color: #000;
    }
      
      /* Beispiel: Klasse f√ºr eine breite, aber nur 1 Zeile hohe Kachel */
      .tile.span-2 {
        grid-column: span 2;
        /* Falls eine andere Regel (nth-child(3n)) sie hochskalieren w√ºrde, √ºberschreiben wir das: */
        grid-row: span 1 !important;
      }
      
      body.dark-mode #pauseOverlay {
        background: #121212; /* dunkler Hintergrund */
      }

      body.dark-mode #pauseHeader,
      body.dark-mode #pauseTime {
        color: white; /* helle Schrift */
      }

      body.dark-mode #pauseProgressContainer {
        background: black; /* evtl. noch dunklerer Hintergrund f√ºr den Fortschrittsbalken */
        border-color: white;
      }
      
      .tile.span-2 {
        grid-column: span 2;
        grid-row: span 1 !important;
      }
      
      #streakDisplay {
        position: fixed;
        left: 20px;
        bottom: 30px;
        font-size: 1.5em;
        z-index: 50;
      }
      
@media screen and (max-width: 600px) {
  
  /* Notensystem k√ºrzen: Notation-Container anpassen */
  #notation {
    top: 60%;
    max-width: 90%;
    padding: 5px;
  }
  
  /* Passe die Notenanzeige an (falls n√∂tig) */
  #noteNameDisplay {
    font-size: 3em;
    bottom: 80px; /* leicht nach oben verschieben, wenn n√∂tig */
  }
  
  /* Optional: Passe den Button-Container an, falls er zu gro√ü ist */
  #buttonContainer {
    flex-direction: column;
    bottom: 20px;
  }
}
      
  </style>
  <script>
      
      function showMotivation(message) {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = message;
          overlay.style.opacity = "1";
          overlay.classList.add("animate-motivation");
          setTimeout(() => {
               overlay.style.opacity = "0";
               overlay.classList.remove("animate-motivation");
          }, 2000);
      }

      function clearMotivation() {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = "";
      }
      
    /************** Funktionen, die vor der Verwendung deklariert sein m√ºssen **************/
    // Eigene Prompt-Funktion, die in Swift-Umgebungen den Message-Handler nutzt
      function customPrompt(message) {
    if (typeof prompt === 'function') {
          return prompt(message);
    } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt) {
          // Sende die Nachricht an Swift; Swift muss dann eine Antwort zur√ºckliefern,
          // z. B. indem es window.customPromptResponse setzt.
          window.webkit.messageHandlers.customPrompt.postMessage(message);
          // Hier nehmen wir an, dass Swift synchron oder zeitnah eine Antwort liefert und
          // diese in window.customPromptResponse speichert. (Alternativ muss hier asynchron vorgegangen werden.)
          return window.customPromptResponse || "";
        } else {
          console.log("Kein Prompt verf√ºgbar.");
          return "";
        }
      }
      
    // Metronom-Variablen und Funktionen
      let metronomeOn =false;
      let metronomeBPM = 0;
      let metronomeInterval = 0;
      let metronomeTimer = null;
      let lastTickTime = 0;
      // Tick-Sound (bitte ggf. die URL anpassen)
      const tickSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/tick.mp3");
    
      function startMetronome() {
        lastTickTime = Date.now();
        tickSound.currentTime = 0;
        tickSound.play();
        metronomeTimer = setInterval(() => {
          tickSound.currentTime = 0;
          tickSound.play();
          lastTickTime = Date.now();
        }, metronomeInterval);
      }
    
      function stopMetronome() {
        clearInterval(metronomeTimer);
      }

      function showPauseScreen() {
        sessionPaused = true;
        document.getElementById("mainContent").style.display = "none";
        document.getElementById("timerContainer").style.display = "none";
        document.getElementById("settingsPanel").style.display = "none";
        document.getElementById("pauseOverlay").style.display = "flex";
      }
      
    // Neue Funktion, die einen gr√ºnen Farbtupfer erzeugt
    function saveButtonEffect() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      
      // Hole die Position des Men√ºs (settingsPanel)
      const settingsPanel = document.getElementById("settingsPanel");
      let x, y;
      if (settingsPanel) {
        const rect = settingsPanel.getBoundingClientRect();
        // Tupfer soll in der Mitte des Men√ºs erscheinen
        x = rect.left + rect.width / 2;
        y = rect.top + rect.height / 2;
      } else {
        // Fallback: Mitte des Canvas
        x = canvas.width / 2;
        y = canvas.height / 2;
      }
      
      // Definiere Parameter f√ºr den Tupfer
      const radius = Math.random() * 200 + 200; // Gr√∂√üe anpassen
      const creationTime = Date.now();
      const duration = 1500; // Dauer in Millisekunden
      
      // Erzeuge den Tupfer (Farbtupfer wird zur globalen circles-Array hinzugef√ºgt)
      circles.push({ x, y, radius, color: "green", creationTime, duration });
    }
      
    function updateStreak() {
      // Hole den bisherigen Streak (falls vorhanden)
      let streak = Number(localStorage.getItem("streak")) || 0;
      // Hole das Datum der letzten Lernsession, falls vorhanden
      let lastDateStr = localStorage.getItem("lastLearnDate");
      // Bestimme heute (ohne Uhrzeit)
      let today = new Date();
      today.setHours(0,0,0,0);
      
      if (lastDateStr) {
        let lastDate = new Date(lastDateStr);
        lastDate.setHours(0,0,0,0);
        // Berechne den Unterschied in Tagen
        let diffDays = (today - lastDate) / (1000 * 60 * 60 * 24);
        if (diffDays === 1) {
          // Konsekutiver Tag: Erh√∂he den Streak
          streak++;
        } else if (diffDays > 1) {
          // Mehr als ein Tag Pause: Streak zur√ºcksetzen
          streak = 1;
        }
        // Falls diffDays === 0: wir sind noch am gleichen Tag; der Streak bleibt unver√§ndert
      } else {
        streak = 1;
      }
      
      // Speichere das heutige Datum und den aktuellen Streak
      localStorage.setItem("lastLearnDate", today.toISOString());
      localStorage.setItem("streak", streak);
      
      return streak;
    }
      
      document.addEventListener("DOMContentLoaded", () => {
        // Aktualisiere und zeige den Streak an:
        const currentStreak = updateStreak();
        const streakDisplay = document.getElementById("streakDisplay");
        streakDisplay.textContent = "üî• " + currentStreak;
        streakDisplay.style.cursor = "pointer";
        streakDisplay.addEventListener("click", () => {
          showPauseScreen();
        });

        // ... restlicher Initialisierungscode
      });
      
    function logSessionStart() {
      const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
      sessionTimes.push(new Date().toISOString());
      localStorage.setItem("sessionTimes", JSON.stringify(sessionTimes));
    }
      
    // Speichert die relevanten Statistiken im localStorage
    function saveStatistics() {
      const stats = {
        totalAttempts: totalAttempts,
        correctAnswers: correctAnswers,
        correctNoteCount: correctNoteCount,
        responseTimes: responseTimes,
        sessionCount: sessionCount,
        hearts: hearts,
        errorNotes: errorNotes,
        // Du kannst hier auch weitere Variablen eintragen, z.B. openTimes, appStartTime etc.
        appStartTime: appStartTime
      };
      localStorage.setItem("appStatistics", JSON.stringify(stats));
    }

    // L√§dt die Statistiken aus dem localStorage und weist sie den globalen Variablen zu
    function loadStatistics() {
      const statsStr = localStorage.getItem("appStatistics");
      if (statsStr) {
        const stats = JSON.parse(statsStr);
        totalAttempts = stats.totalAttempts || 0;
        correctAnswers = stats.correctAnswers || 0;
        correctNoteCount = stats.correctNoteCount || 0;
        responseTimes = stats.responseTimes || [];
        sessionCount = stats.sessionCount || 0;
        hearts = stats.hearts || (unlimitedLives ? Infinity : 4);
        errorNotes = stats.errorNotes || [];
        appStartTime = stats.appStartTime || Date.now();
      }
    }

    // Optional: Speichern der Statistiken, wenn die Seite geschlossen wird
    window.addEventListener("beforeunload", saveStatistics);

    // Beim Laden der Seite die Statistiken laden
    document.addEventListener("DOMContentLoaded", loadStatistics);
    
    function proceedToMainScreen() {
      const audio = document.getElementById("backgroundSound");
      if (audio) { audio.pause(); }
      const welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.opacity = "0";
      setTimeout(() => {
        welcomeOverlay.classList.add("hidden");
        const mainContent = document.getElementById("mainContent");
        mainContent.style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        setTimeout(() => { mainContent.style.opacity = "1"; }, 10);
      }, 500);
    }
    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      // Erstelle den Pause-Button und f√ºge ihn dem Einstellungen-Panel hinzu
      const settingsPanel = document.getElementById("settingsPanel");
      const pauseButton = document.createElement("span");
      pauseButton.id = "pauseButton";
      pauseButton.textContent = "üíæ";
      settingsPanel.appendChild(pauseButton);

      // F√ºge den Event Listener hinzu
      pauseButton.addEventListener("click", () => {
        if (!sessionPaused) {
          saveStatistics();
          saveButtonEffect();
          console.log("Statistiken gespeichert und gr√ºner Farbtupfer ausgel√∂st.");
        }
      });
    });
      
    /************** Globale Variablen & Konstanten **************/
    // Handoptionen
    const handOptions = [
      { mode: "left", symbol: "‚úã" },
      { mode: "right", symbol: "‚úã", flip: true }
    ];
    let currentHandIndex = 0;
    let selectedMode = handOptions[currentHandIndex].mode;
    let randomMode = false;
    
    // Verf√ºgbare Lagen
    const rangeArray = ["C", "D", "F", "G", "MC"];
    const alternatingRanges = ["C", "D", "MC"]; // Vordefinierte Lagen, die im Hasenmodus alternieren sollen
    let currentRangeIndex = 0;
    let currentRange = rangeArray[currentRangeIndex];
    
    // Wichtig: Definition der rangeNotes ‚Äì Zuordnung von Lage zu Noten
    const rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    let currentSeriesSingle = [];
    let seriesCounter = 1000;
    const seriesLength = 5;
    let totalAttempts = 0;
    let correctAnswers = 0;
    let correctNoteCount = 0;
    let nextMotivationThreshold = getRandomThreshold();
    let errorNotes = [];
    let responseTimes = [];
    let lastNoteTimestamp = Date.now();
    let appStartTime = Date.now();
    let sessionCounter = 1000; // 5 korrekte Noten erforderlich
    let sessionPaused = false;
    let scoreRecorded = false;
    let sessionCount = 0;
    let unlimitedLives = true;
    let hearts = unlimitedLives ? Infinity : 4;
    let inactivityTimeout = null;
    
    // Beim Laden der Seite oder zu Beginn eines Trainings:
    const saveOpenTime = () => {
      const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
      openTimes.push(new Date().toISOString());
      localStorage.setItem("openTimes", JSON.stringify(openTimes));
    };

    document.addEventListener("DOMContentLoaded", saveOpenTime);
    
    const updateHeartsDisplay = () => {
      const heartsElem = document.getElementById("heartsContainer");
      heartsElem.textContent = unlimitedLives ? "" : "‚ù§Ô∏è".repeat(hearts);
    };
      const updateTimer = () => {
        document.getElementById("timerContainer").textContent = sessionCounter;
      };
      setInterval(updateTimer, 1000);
    function calculateAdaptiveBreakTime(responseTimes, hitRate) {
      if (responseTimes.length === 0) return 5;
      let sum = responseTimes.reduce((acc, time) => acc + time, 0);
      let avgResponseTime = sum / responseTimes.length;
      const baseline = 500;
      let slowdownFactor = avgResponseTime / baseline;
      let fatigueIndex = slowdownFactor * (1 - hitRate);
      const basePause = 10;
      let breakTime = basePause * fatigueIndex;
      return Math.max(5, Math.min(breakTime, 300));
    }
    let pauseRemaining = 0;
    let pauseInterval = null;
    let confettiShown = false;
    let pauseDuration = 0;
    function updatePauseProgress() {
      const progressBar = document.getElementById("pauseProgress");
      const timeDisplay = document.getElementById("pauseTime");
      if (progressBar && pauseDuration > 0) {
        const percent = ((pauseDuration - pauseRemaining) / pauseDuration) * 100;
        progressBar.style.width = percent + "%";
        if (timeDisplay) {
          const m = Math.floor(pauseRemaining / 60);
          const s = pauseRemaining % 60;
          timeDisplay.textContent = (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
        }
      }
    }
      function updatePauseTiles() {
        const container = document.getElementById("pauseTiles");
        if (!container) return;

        // Berechne App‚ÄëZeit
        const totalTimeSec = Math.floor((Date.now() - appStartTime) / 1000);
        const h = Math.floor(totalTimeSec / 3600);
        const m = Math.floor((totalTimeSec % 3600) / 60);
        const s = totalTimeSec % 60;
        const appTime = (h > 0 ? (h + "h ") : "") + m + "m " + s + "s";

        // Berechne Prozent richtiger Noten
        const correctPercent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;

        // Durchschnittliche Bearbeitungszeit (in Sekunden)
        const avgTimeSec = responseTimes.length
          ? (responseTimes.reduce((acc, t) => acc + t, 0) / responseTimes.length / 1000).toFixed(2)
          : "N/A";

        container.innerHTML = `
          <div class="tile">
            <div class="tileIcon">‚è∞</div>
            <div class="tileTitle">App‚ÄëZeit</div>
            <div class="tileValue">${appTime}</div>
          </div>
          <div class="tile">
            <div class="tileIcon">‚úÖ</div>
            <div class="tileTitle">Richtige Noten</div>
            <div class="tileValue">${correctPercent}%</div>
          </div>
          <div class="tile">
            <div class="tileTitle">Wann √ºbst du am meisten?</div>
            <div class="barChart">
               ${generateBarChartHTML()}
            </div>
          </div>
          ${ generateLearningQualityGraphTile() }
          <div class="tile">
            <div class="tileTitle">Session</div>
            <div class="tileValue">${sessionCount}</div>
          </div>
          <div class="tile span-2">
            <div class="tileIcon">${handOptions[currentHandIndex].symbol} √ò ${avgTimeSec} s/Note</div>
            <div class="tileTitle">Lieblingshand</div>
          </div>
        `;
      }
      
      function getLastThreeSessions() {
        // Beispiel: Session-Daten als Array von Objekten mit responseTimes (ms), errorCount, totalAttempts und sessionTime (in sec)
        const sessions = JSON.parse(localStorage.getItem("sessionData") || "[]");
        return sessions.slice(-3);
      }

      function calculateQuality(session) {
        // Durchschnittliche Antwortzeit in Sekunden (niedriger ist besser)
        const avgResponse = session.responseTimes.length
          ? session.responseTimes.reduce((a, b) => a + b, 0) / session.responseTimes.length / 1000
          : 0;
        // Fehlerquote (niedriger ist besser)
        const errorRate = session.totalAttempts ? (session.errorCount / session.totalAttempts) : 0;
        // Die Session-Dauer in Sekunden ‚Äì l√§ngere Sessions k√∂nnen auf mehr Engagement hinweisen
        const learningTime = session.sessionTime || 0;
        // Beispielhafte Gewichtung: Wir wollen, dass niedrigere Antwortzeiten und Fehlerquoten zu h√∂heren Qualit√§tswerten f√ºhren.
        // Hier eine einfache Rechnung, die in den meisten F√§llen einen Wert zwischen 0 und 100 liefert.
        let quality = 100 - (avgResponse * 10) - (errorRate * 100) + (learningTime / 60);
        return Math.max(0, Math.min(quality, 100));
      }
      
      function drawLearningQualityGraph(canvas, sessions) {
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // Berechne die Qualit√§tswerte
        const qualities = sessions.map(calculateQuality);

        // Wir erwarten Werte zwischen 0 und 100, also skalieren wir den y-Wert entsprechend.
        ctx.beginPath();
        for (let i = 0; i < qualities.length; i++) {
          const x = (i / (qualities.length - 1)) * width;
          // H√∂here Qualit√§t => niedrigere y-Koordinate (oben ist 0)
          const y = height - (qualities[i] / 100 * height);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          // Optional: Zeichne einen kleinen Kreis als Punkt
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fillStyle = "#007aff";
          ctx.fill();
          ctx.beginPath(); // Beginne neuen Pfad f√ºr die Linie
          if(i === 0) {
            ctx.moveTo(x,y);
          }
        }
        ctx.strokeStyle = "#007aff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      function generateLearningQualityGraphTile() {
        // Erstelle einen Container (div) f√ºr die Kachel ‚Äì hier nutzen wir span-2, um sie breit anzuzeigen.
        const container = document.createElement("div");
        container.className = "tile span-2";
        
        const title = document.createElement("div");
        title.className = "tileTitle";
        title.textContent = "Lernqualit√§t";
        container.appendChild(title);
        
        // Erstelle ein Canvas f√ºr den Graphen
        const canvas = document.createElement("canvas");
        canvas.width = 280;  // Passe die Gr√∂√üe an die Kachel an
        canvas.height = 100;
        container.appendChild(canvas);
        
        // Hole die letzten drei Sessions und zeichne den Graph
        const sessions = getLastThreeSessions();
        drawLearningQualityGraph(canvas, sessions);
        
        // Berechne den durchschnittlichen Qualit√§tswert zur zus√§tzlichen Anzeige
        let avgQuality = sessions.length ? (sessions.map(calculateQuality).reduce((a, b) => a + b, 0) / sessions.length).toFixed(2) : "N/A";
        const qualityText = document.createElement("div");
        qualityText.className = "tileValue";
        qualityText.textContent = `√ò ${avgQuality} / 100`;
        container.appendChild(qualityText);
        
        return container.outerHTML;
      }
                                            
function generateBarChartHTML() {
  // Standardwerte: Jeder Tag wird initial auf 0 gesetzt.
  const dayCounts = { Mo: 0, Di: 0, Mi: 0, Do: 0, Fr: 0, Sa: 0, So: 0 };
  
  // Z√§hle √ñffnungszeiten
  const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
  openTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  // Z√§hle Session-Zeitpunkte
  const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
  sessionTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  const days = ["Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"];
  const maxVal = Math.max(...Object.values(dayCounts), 1);
  
  // Erstelle Container als Flex-Layout f√ºr das Balkendiagramm
  const container = document.createElement("div");
  container.className = "bar-chart-container";
  
  days.forEach(day => {
    const val = dayCounts[day] || 0;
    const barItem = document.createElement("div");
    barItem.className = "bar-item";
    
    const bar = document.createElement("div");
    bar.className = "bar";
    const height = Math.round((val / maxVal) * 100);
    bar.style.height = `${height}px`;
    
    const label = document.createElement("div");
    label.className = "bar-label";
    label.textContent = day;
    
    barItem.appendChild(bar);
    barItem.appendChild(label);
    container.appendChild(barItem);
  });
  
  return container.outerHTML;
}
      
      
    const startPauseCountdown = () => {
            logSessionStart(); // Neuen Session-Zeitstempel speichern
      sessionPaused = true;
      sessionCount++;
      const hitRate = totalAttempts > 0 ? (correctAnswers / totalAttempts) : 1;
      pauseRemaining = Math.floor(calculateAdaptiveBreakTime(responseTimes, hitRate) * 2 + 300);
      pauseDuration = pauseRemaining;
      document.getElementById("mainContent").style.display = "none";
      document.getElementById("timerContainer").style.display = "none";
      document.getElementById("settingsPanel").style.display = "none";
      const pauseOverlay = document.getElementById("pauseOverlay");
      pauseOverlay.style.display = "flex";
      updatePauseProgress();
      updatePauseTiles();
      const msgInterval = setInterval(() => { updatePauseTiles(); }, 3000);
      pauseInterval = setInterval(() => {
        pauseRemaining--;
        updatePauseProgress();
        if (pauseRemaining <= 0) {
          clearInterval(pauseInterval);
          clearInterval(msgInterval);
          endPause();
        }
      }, 1000);
    };
      
      // Erstelle ein Audio-Objekt f√ºr den Gong
      const gongSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/gong-2-232435.mp3");
      
      // In deiner Funktion, die das Pausenfenster beendet, rufe den Sound ab:
      const endPause = () => {
        document.getElementById("pauseOverlay").style.display = "none";
        document.getElementById("mainContent").style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        sessionPaused = false;
        // Setze den Sound zur√ºck und spiele ihn ab
        gongSound.currentTime = 0;
        gongSound.play();
        resetGame();
      };
    let gameOver = false;
    const endGame = () => {
      gameOver = true;
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      gameOverOverlay.textContent = "Game Over!";
      gameOverOverlay.style.display = "block";
      if (!scoreRecorded) recordScore();
      setTimeout(resetGame, 5000);
    };
    const recordScore = () => {
      if (totalAttempts <= 0) return;
      const durationMs = Date.now() - appStartTime;
      const secondsTotal = Math.floor(durationMs / 1000);
      const minutes = Math.floor(secondsTotal / 60);
      const seconds = secondsTotal % 60;
      const durationStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
      const accuracy = Math.round((correctAnswers / totalAttempts) * 100);
      const now = new Date();
      let dd = now.getDate();
      let mm = now.getMonth() + 1;
      dd = dd < 10 ? "0" + dd : dd;
      mm = mm < 10 ? "0" + mm : mm;
      const dateStr = dd + "." + mm;
      const scoreObj = { date: dateStr, accuracy: accuracy, duration: durationStr, seconds: secondsTotal, mode: randomMode ? "random" : selectedMode };
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      highScores.push(scoreObj);
      highScores.sort((a, b) => (b.accuracy !== a.accuracy ? b.accuracy - a.accuracy : a.seconds - b.seconds));
      highScores = highScores.slice(0, 5);
      localStorage.setItem("highScores", JSON.stringify(highScores));
      scoreRecorded = true;
    };
    const updateScoreboard = () => {
      const allScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const filtered = allScores.filter(score => score.mode === (randomMode ? "random" : selectedMode));
      let html = "HIGHSCORES (" + (randomMode ? "random" : selectedMode) + ")\n";
      filtered.forEach((score, index) => {
        html += (index + 1) + ". " + score.date + " \t " + score.accuracy + "% " + score.duration + "\n";
      });
      document.getElementById("scoreboardOverlay").textContent = html;
    };
    const toggleScoreboard = () => {
      const overlay = document.getElementById("scoreboardOverlay");
      overlay.classList.toggle("hidden");
      if (!overlay.classList.contains("hidden")) updateScoreboard();
    };
    const autoSelectMode = () => {
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const leftScores = highScores.filter(score => score.mode === "left");
      const rightScores = highScores.filter(score => score.mode === "right");
      const bestLeft = leftScores.length ? Math.max(...leftScores.map(s => s.accuracy)) : 0;
      const bestRight = rightScores.length ? Math.max(...rightScores.map(s => s.accuracy)) : 0;
      if (bestLeft < bestRight) {
        selectedMode = "left";
        currentHandIndex = 0;
      } else {
        selectedMode = "left";
        currentHandIndex = 0;
      }
      const handToggle = document.getElementById("handToggle");
      if (handToggle) {
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      }
    };
    const cycleRange = () => {
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
      updateHeartsDisplay();
    };
    const toggleDarkMode = () => {
      document.body.classList.toggle("dark-mode");
    };
    // Passive Listener f√ºr Touch-Events in setupFadeOnHover
    const setupFadeOnHover = (element) => {
      element.addEventListener("mouseenter", () => element.classList.remove("faded"));
      element.addEventListener("mouseleave", () => element.classList.add("faded"));
      element.addEventListener("touchstart", () => element.classList.remove("faded"), {passive: true});
      element.addEventListener("touchend", () => element.classList.add("faded"), {passive: true});
    };
    let redrawQueued = false;
    const queueRedraw = () => {
      if (!redrawQueued) {
        redrawQueued = true;
        requestAnimationFrame(() => {
          drawSeries();
          redrawQueued = false;
        });
      }
    };
    /* Animation (Hintergrund-Kreise) */
    let circles = [];
    const gradients = {
      "green": ["rgba(0,255,0,1)", "rgba(0,255,0,0.3)", "rgba(255,255,255,0)"],
      "blue": ["rgba(0,0,255,1)", "rgba(0,0,255,0.3)", "rgba(255,255,255,0)"],
      "pink": ["rgba(255,105,180,1)", "rgba(255,105,180,0.3)", "rgba(255,255,255,0)"],
      "yellow": ["rgba(255,255,0,1)", "rgba(255,255,0,0.3)", "rgba(255,255,255,0)"],
      "red": ["rgba(255,0,0,1)", "rgba(255,0,0,0.3)", "rgba(255,255,255,0)"],
      "violet": ["rgba(238,130,238,1)", "rgba(238,130,238,0.3)", "rgba(255,255,255,0)"],
      "gray": ["rgba(128,128,128,1)", "rgba(128,128,128,0.3)", "rgba(255,255,255,0)"],
      "black": ["rgba(0,0,0,1)", "rgba(0,0,0,0.3)", "rgba(255,255,255,0)"]
    };
    const positiveColors = ["green", "blue", "pink", "yellow"];
    const negativeColors = ["orange", "violet", "crimson"];
    function addCircle(type) {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = type === "positive" ? positiveColors : negativeColors;
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
    }
    /* Intro-Animation */
    function spawnIntroBlobs() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const positions = [
        { x: cw - 500, y: 100 },
        { x: cw - 30, y: ch - 30 },
        { x: 50, y: ch / 2 }
      ];
      const colors = ["yellow", "pink", "blue"];
      positions.forEach((pos, index) => {
        const targetRadius = Math.random() * 1000 + 1000;
        const duration = 5000;
        circles.push({
          x: pos.x,
          y: pos.y,
          initialRadius: targetRadius,
          radius: targetRadius,
          color: colors[index % colors.length],
          creationTime: Date.now(),
          duration: duration
        });
      });
    }
    function animateCircles() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const now = Date.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      circles = circles.filter(circle => {
        const t = now - circle.creationTime;
        if (t >= circle.duration) return false;
        let opacity = 0;
        if (t < 500) { opacity = t / 500; }
        else if (t < 1500) { opacity = 1; }
        else { opacity = (circle.duration - t) / 500; }
        let currentRadius = circle.radius;
        const gradColors = gradients[circle.color] || [circle.color, circle.color, "rgba(255,255,255,0)"];
        const grad = ctx.createRadialGradient(circle.x, circle.y, 0, circle.x, circle.y, currentRadius);
        grad.addColorStop(0, gradColors[0]);
        grad.addColorStop(0.7, gradColors[1]);
        grad.addColorStop(1, gradColors[2]);
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, currentRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 1;
        return true;
      });
      requestAnimationFrame(animateCircles);
    }
    function resetInactivityTimer() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(spawnInactivityBlob, 180000);
    }
    function spawnInactivityBlob() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = ["green", "blue", "pink", "yellow"];
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
      resetInactivityTimer();
    }
    document.addEventListener("DOMContentLoaded", () => {
      let canvas = document.getElementById("animationCanvas");
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = "animationCanvas";
        document.body.appendChild(canvas);
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      animateCircles();
      resetInactivityTimer();
      spawnIntroBlobs();
      document.getElementById("welcomeMessage").textContent = "Sch√∂n, dass du da bist!";
      setTimeout(proceedToMainScreen, 5000);
      
      const settingsPanel = document.getElementById("settingsPanel");
      // Handtoggle
      const handToggle = document.createElement("span");
      handToggle.id = "handToggle";
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      settingsPanel.appendChild(handToggle);
      handToggle.addEventListener("click", () => {
        if (!randomMode) {
          currentHandIndex = (currentHandIndex + 1) % handOptions.length;
          selectedMode = handOptions[currentHandIndex].mode;
          handToggle.textContent = handOptions[currentHandIndex].symbol;
          handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
          generateSeries();
        }
      });
      // Randomtoggle
      const randomToggle = document.createElement("span");
      randomToggle.id = "randomToggle";
      randomToggle.textContent = "üêá";
      settingsPanel.appendChild(randomToggle);
      randomToggle.addEventListener("click", () => {
        randomMode = !randomMode;
        randomToggle.style.opacity = randomMode ? "1" : "0.5";
        generateSeries();
      });
      
      
      // Pausen-Button
      function blinkGreenBackground() {
        // Urspr√ºngliche Hintergrundfarbe speichern (falls gesetzt, sonst Standardwert)
        const originalBg = document.body.style.backgroundColor || "";
        // Setze den Hintergrund auf den bekannten Gr√ºnton
        document.body.style.backgroundColor = "LightBlue"; // hier den gew√ºnschten Gr√ºnton anpassen
        // Nach 300 Millisekunden wieder zur√ºcksetzen
        setTimeout(function() {
          document.body.style.backgroundColor = originalBg;
        }, 300);
      }
      
      pauseButton.addEventListener("click", () => {
        if (!sessionPaused) {
          saveStatistics();
          saveButtonEffect();
          console.log("Statistiken gespeichert und gr√ºner Farbtupfer ausgel√∂st.");
        }
      });
      
      
      
      // Metronom-Toggle
      const metronomeToggle = document.createElement("span");
      metronomeToggle.id = "metronomeToggle";
      metronomeToggle.textContent = "‚è≤Ô∏è";
      metronomeToggle.style.opacity = "0.5"; // an/off Anzeige: 0.5 = aus, 1 = an
      settingsPanel.appendChild(metronomeToggle);
      metronomeToggle.addEventListener("click", () => {
              if (!metronomeOn) {
                const bpmInput = customPrompt("Bitte gib die BPM-Zahl f√ºr das Metronom ein:");
               const bpm = Number(bpmInput);
                if (bpm > 0) {
                  metronomeOn = true;
                  metronomeBPM = bpm;
                  metronomeInterval = 60000 / bpm;
                  startMetronome();
                  metronomeToggle.style.opacity = "1";
                }
              } else {
                metronomeOn = false;
                stopMetronome();
                metronomeToggle.style.opacity = "0.5";
              }
            });
      
      document.getElementById("timerContainer").addEventListener("click", () => {
              const input = customPrompt("Bitte gib die Anzahl der zu lernenden Noten ein:");
              const num = parseInt(input, 10);
              if (!isNaN(num) && num > 0) {
                sessionCounter = num;
                updateTimer();
              }
            });
      
      // DarkMode-Toggle
      const darkModeToggle = document.createElement("span");
      darkModeToggle.id = "darkModeToggle";
      darkModeToggle.textContent = "üåô";
      settingsPanel.appendChild(darkModeToggle);
      darkModeToggle.addEventListener("click", toggleDarkMode);
      // Scoreboard-Toggle
      
      autoSelectMode();
      generateSeries();
      updateHeartsDisplay();
      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") { handleMIDIMessage(144, 60, 127); }
      });
      document.getElementById("scoreboardOverlay").addEventListener("click", toggleScoreboard);
    });
                                            
                            
    const generateSeries = () => {
  seriesCounter = 0;
  correctNoteCount = 0;
  nextMotivationThreshold = getRandomThreshold();
  document.getElementById("noteNameDisplay").textContent = "";
  
  let seriesClef;
  if (randomMode) {
      seriesClef = Math.random() < 0.5 ? "bass" : "treble";
      let oldRange = currentRange;
      if (typeof alternatingRanges !== 'undefined' && alternatingRanges.length > 0) {
          currentRange = alternatingRanges[Math.floor(Math.random() * alternatingRanges.length)];
      }
      if (oldRange !== currentRange) {
          // Kurzer Dong, wenn die Lage wechselt
          gongSound.currentTime = 0;
          gongSound.play();
          var clefTitle = document.getElementById("clefTitle");
          clefTitle.textContent = currentRange + "-Lage";
          // Rahmen des Lagenbuttons kurz rot aufblinken lassen
          clefTitle.style.border = "3px solid red";
          setTimeout(() => {
              // Originalfarbe abh√§ngig vom Dark-Mode
              if (document.body.classList.contains("dark-mode")) {
                  clefTitle.style.border = "3px solid #fff";
              } else {
                  clefTitle.style.border = "3px solid #000";
              }
          }, 300);
      }
  } else {
      seriesClef = (selectedMode === "left") ? "bass" : "treble";
  }
      
  const chooseNote = () => {
    if (errorNotes.length > 0 && Math.random() < 0.6) {
      const idx = errorNotes.findIndex(note => note.clef === seriesClef);
      if (idx !== -1) { return errorNotes.splice(idx, 1)[0]; }
    }
    let availableNotes;
    if (currentRange === "MC") {
      availableNotes = seriesClef === "bass" ? ["f", "g", "a", "b", "c"] : ["c", "d", "e", "f", "g"];
    } else {
      availableNotes = rangeNotes[currentRange];
    }
    const randomIndex = Math.floor(Math.random() * availableNotes.length);
    const chosenNote = availableNotes[randomIndex];
    let noteOctave;
    if (currentRange === "MC") {
      noteOctave = seriesClef === "bass" ? (chosenNote === "c" ? 4 : 3) : 4;
    } else {
      noteOctave = seriesClef === "bass" ? 3 : 4;
    }
    // F√ºr die Lagen D, F und G: Falls der gew√§hlte Notenname accidentals enth√§lt,
    // setze die Eigenschaft accidental entsprechend.
    let accidental = undefined;
    if (["D", "F", "G"].includes(currentRange)) {
      if (currentRange === "D" && chosenNote.includes("#")) {
        accidental = "#";
      } else if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
        accidental = chosenNote; // z.B. "bb"
      } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
        accidental = chosenNote;
      }
    }
    return { note: chosenNote, octave: noteOctave, clef: seriesClef, color: "black", accidental: accidental };
  };

  currentSeriesSingle = [];
  for (let i = 0; i < seriesLength; i++) {
    currentSeriesSingle.push(chooseNote());
  }
  drawSeries();
};
                                            
                                            
const drawSeries = () => {
  const notationDiv = document.getElementById("notation");
  const baseWidth = 800;
  const ratio = window.devicePixelRatio || 1;
  const height = 300 * ratio;
  notationDiv.style.display = "block";
  notationDiv.innerHTML = "";
  
  // Erzeuge den Renderer und passe Gr√∂√üe an
  const renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
  renderer.resize(baseWidth * ratio, height);
  const svg = notationDiv.querySelector("svg");
  if (svg) {
    svg.setAttribute("width", baseWidth);
    svg.setAttribute("height", 300);
  }
  const context = renderer.getContext();
  
  // Erzeuge den Stave
  const stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
  if (currentSeriesSingle.length) {
    stave.addClef(currentSeriesSingle[0].clef);
  }
  
  // F√ºge Key Signature (Vorzeichen) hinzu, je nach aktueller Lage
  if (currentRange === "D") {
    // In D-Lage wird in der Regel ein Kreuz (F#) ben√∂tigt ‚Äì "G" erzeugt eine Key Signature mit einem Kreuz.
    stave.addKeySignature("G");
  } else if (currentRange === "F") {
    // In F-Lage wird typischerweise ein b ben√∂tigt ‚Äì "F" erzeugt eine Key Signature mit einem b.
    stave.addKeySignature("F");
  } else if (currentRange === "G") {
    // Je nach Anforderung: In G-Dur gibt es normalerweise ein Kreuz (F#).
    stave.addKeySignature("G");
  }
  
  stave.setContext(context).draw();
  
  // Erzeuge die StaveNotes f√ºr die Serie (Notennamen bleiben unver√§ndert, da die Vorzeichen √ºber die Key Signature definiert werden)
  const staveNotes = currentSeriesSingle.map(item => {
    let noteName = item.note.toLowerCase();
    // Falls wir nicht in den speziellen Lagen arbeiten, ersetze Unicode-Vorzeichen durch ASCII
    if (!(["D", "F", "G"].includes(currentRange))) {
      noteName = noteName.replace(/‚ôØ/g, "#").replace(/‚ô≠/g, "b");
    }
    const key = noteName + "/" + item.octave;
    const staveNote = new Vex.Flow.StaveNote({
      clef: item.clef,
      keys: [key],
      duration: "q"
    });
    staveNote.setStyle({ fillStyle: item.color, strokeStyle: item.color });
    return staveNote;
  });
  
  const voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
  staveNotes.forEach(note => voice.addTickable(note));
  new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
  voice.draw(context, stave);
};
    
    const isNoteCorrect = (midiInfo) => {
      const expected = currentSeriesSingle[seriesCounter];
      if (!expected) return false;
      const playedNote = midiInfo.note.toLowerCase();
      const expectedNote = expected.note.toLowerCase();
      return playedNote === expectedNote && midiInfo.octave === expected.octave;
    };
    const removeFromErrorNotes = (noteObj) => {
      errorNotes = errorNotes.filter(n => !(n.note === noteObj.note && n.octave === noteObj.octave && n.clef === noteObj.clef));
    };
    const handleMIDIMessage = (status, data1, data2) => {
      if (sessionPaused) return;
      resetInactivityTimer();
      if ((status & 0xf0) === 0x90 && data2 > 0) {
        if (seriesCounter >= currentSeriesSingle.length) return;
        let currentTime = Date.now();
        let responseTime = currentTime - lastNoteTimestamp;
        responseTimes.push(responseTime);
        lastNoteTimestamp = currentTime;
        const midiInfo = (() => {
          const noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
          const octave = Math.floor(data1 / 12) - 1;
          return { note: noteNames[data1 % 12], octave: octave };
        })();
        const playedNoteDisplay = (midiInfo.note === "b" ? "h" : midiInfo.note) + midiInfo.octave;
        const noteDisplay = document.getElementById("noteNameDisplay");
        totalAttempts++;
        
        if (isNoteCorrect(midiInfo)) {
                  // Falls das Metronom an ist, √ºberpr√ºfe das Timing
                  if (metronomeOn) {
                    const currentTime = Date.now();
                    const actualInterval = currentTime - lastTickTime;
                    const tolerance = metronomeInterval * 0.3;
                    if (actualInterval < metronomeInterval - tolerance) {
                         showMotivation("Zu schnell! Langsamer spielen.");
                    } else if (actualInterval > metronomeInterval + tolerance) {
                         showMotivation("Zu langsam! Schneller spielen.");
                    } else {
                         clearMotivation();
                    }
                  } else {
                    showMotivation("Super! Weiter so!");
                  }
                  correctAnswers++;
                  correctNoteCount++;
                  removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
                  sessionCounter--;
                  addCircle("positive");
                  if (noteDisplay) {
                    noteDisplay.innerHTML = '<span style="color:' + currentSeriesSingle[seriesCounter].color + ';">' + playedNoteDisplay + '</span>';
              }
                  if (sessionCounter <= 0) {
                    sessionCounter = 0;
                    startPauseCountdown();
                    updateTimer();
                    return;
                  }
                } else {
                  currentSeriesSingle[seriesCounter].color = "red";
                  errorNotes.push(currentSeriesSingle[seriesCounter]);
                  addCircle("negative");
                  if (noteDisplay) {
                    const correctRaw = currentSeriesSingle[seriesCounter].note;
                    const correctDisplay = (correctRaw === "b" ? "h" : correctRaw) + currentSeriesSingle[seriesCounter].octave;
                    noteDisplay.innerHTML = '<span style="color:red;">' + playedNoteDisplay + '</span> <span style="color:green;">' + correctDisplay + '</span>';
                  }
                  if (!unlimitedLives) {
                    hearts--;
                    updateHeartsDisplay();
                    if (hearts <= 0) { endGame(); return; }
                  }
                }
        
        seriesCounter++;
        if (seriesCounter >= seriesLength) {
          queueRedraw();
          setTimeout(generateSeries, 300);
        } else { queueRedraw(); }
        updateTimer();
      }
    };
    const resetGame = () => {
      sessionCounter = 1000;
      hearts = unlimitedLives ? Infinity : 4;
      gameOver = false;
      seriesCounter = 0;
      totalAttempts = 0;
      correctAnswers = 0;
      correctNoteCount = 0;
      nextMotivationThreshold = getRandomThreshold();
      sessionPaused = false;
      confettiShown = false;
      errorNotes = [];
      document.getElementById("pauseOverlay").style.display = "none";
      scoreRecorded = false;
      generateSeries();
      updateHeartsDisplay();
    };
                                            

  // Funktion, die den Hintergrund f√ºr kurze Zeit gr√ºn f√§rbt und danach wieder zur√ºcksetzt
  
  function checkOrientation() {
    const settingsPanel = document.getElementById("settingsPanel");
    if (!settingsPanel) return; // Falls das Element nicht existiert, beende die Funktion
    if (window.innerWidth > window.innerHeight) {
         // Querformat (Landscape): Men√º rechts, horizontal ausgerichtet
         settingsPanel.style.top = "29%";
         settingsPanel.style.right = "20px";
         settingsPanel.style.left = "";
         settingsPanel.style.transform = "";
         settingsPanel.style.flexDirection = "row";
    } else {
         // Hochformat (Portrait): Men√º oben mittig, vertikal ausgerichtet
         settingsPanel.style.top = "10px";
         settingsPanel.style.left = "50%";
         settingsPanel.style.right = "";
         settingsPanel.style.transform = "translateX(-50%)";
         settingsPanel.style.flexDirection = "column";
    }
}
  window.addEventListener("resize", checkOrientation);
  checkOrientation();
  
  </script>
<script>
  // Initialisiere MIDI-Zugriff (Web MIDI API)
  function initMIDIAccess() {
    if (navigator.requestMIDIAccess) {
      navigator.requestMIDIAccess({ sysex: true })
        .then(onMIDISuccess, onMIDIFailure);
    } else {
      console.log("Web MIDI API wird in diesem Browser nicht unterst√ºtzt.");
    }
  }
  
  function onMIDISuccess(midiAccess) {
    // Alle vorhandenen MIDI-Eing√§nge initialisieren
    midiAccess.inputs.forEach(function(input) {
      input.onmidimessage = handleMIDIMessage;
    });
    // Auf √Ñnderungen (z.‚ÄØB. Ger√§te an- oder abstecken) reagieren
    midiAccess.onstatechange = function(e) {
      console.log("MIDI-Ger√§testatus hat sich ge√§ndert:", e.port.name, e.port.state);
      if (e.port.state === "connected" && e.port.type === "input") {
        e.port.onmidimessage = handleMIDIMessage;
      }
    };
  }
  
  function onMIDIFailure(error) {
    console.error("Zugriff auf MIDI-Ger√§te fehlgeschlagen:", error);
  }
  
  document.addEventListener("DOMContentLoaded", function() {
    initMIDIAccess();
  });
  </script>
<script>
  // Versuche, Web Bluetooth zu initialisieren, falls verf√ºgbar und Web MIDI nicht unterst√ºtzt wird
  async function initBluetoothMIDIAccess() {
    if (!navigator.bluetooth) {
      console.log("Web Bluetooth API wird in diesem Browser nicht unterst√ºtzt.");
      return;
    }
    try {
      console.log("Suche nach Bluetooth MIDI Ger√§ten...");
      const device = await navigator.bluetooth.requestDevice({
        filters: [{ services: ['03B80E5A-EDE8-4B33-A751-6CE34EC4C700'] }]
      });
      const server = await device.gatt.connect();
      const service = await server.getPrimaryService('03B80E5A-EDE8-4B33-A751-6CE34EC4C700');
      const characteristic = await service.getCharacteristic('7772E5DB-3868-4112-A1A9-F2669D106BF3');
      // Starte Benachrichtigungen, um eingehende MIDI-Daten zu empfangen
      await characteristic.startNotifications();
      characteristic.addEventListener('characteristicvaluechanged', event => {
        let data = new Uint8Array(event.target.value.buffer);
        console.log("Bluetooth MIDI Nachricht empfangen:", data);
        // Hier kannst du den empfangenen MIDI-Daten verarbeiten und z.B. an handleMIDIMessage weiterleiten
        // Ein Beispielaufruf (bitte an dein Format anpassen):
        // handleMIDIMessage(data[0], data[1], data[2]);
      });
      console.log("Bluetooth MIDI Ger√§t verbunden.");
    } catch (error) {
      console.error("Fehler beim Verbinden mit Bluetooth MIDI Ger√§t:", error);
    }
  }

  // Wenn die Web MIDI API nicht verf√ºgbar ist, versuche stattdessen Bluetooth MIDI zu initialisieren
  document.addEventListener("DOMContentLoaded", function() {
    if (!navigator.requestMIDIAccess && navigator.bluetooth) {
      initBluetoothMIDIAccess();
    }
  });
</script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    console.log("--- Schnittstellen-√úberpr√ºfung ---");
    console.log("Web MIDI API: " + (navigator.requestMIDIAccess ? "verf√ºgbar" : "nicht verf√ºgbar"));
    console.log("Web Bluetooth API: " + (navigator.bluetooth ? "verf√ºgbar" : "nicht verf√ºgbar"));
    // Optional: Weitere Schnittstellen k√∂nnen hier hinzugef√ºgt werden
    console.log("Custom Prompt (window.webkit.messageHandlers.customPrompt): " + (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt ? "verf√ºgbar" : "nicht verf√ºgbar"));
    console.log("---------------------------------");
  });
</script>
</head>
<body>
    <div id="streakDisplay"></div>
  <!-- Canvas f√ºr Animation (Hintergrund) -->
  <canvas id="animationCanvas"></canvas>
  <!-- Audio-Element -->
  <audio id="backgroundSound" autoplay>
    <source src="https://raw.githubusercontent.com/JP0024/piano.github.io/3d35e0a8d4eb3e018151018e36e225dc7a856ecd/mixkit-relaxing-harp-sweep-2628.wav" type="audio/wav">
    Dein Browser unterst√ºtzt das Audio-Element nicht.
  </audio>
  <!-- Pause-Overlay -->
  <div id="pauseOverlay">
    <div id="pauseInfo">
      <div id="pauseHeader">SESSION PAUSIERT</div>
      <div id="pauseProgressContainer">
        <div id="pauseProgress"></div>
        <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
      </div>
    </div>
    <!-- Kachelwand -->
    <div id="pauseTiles"></div>
  </div>
  <!-- Welcome Overlay -->
  <div id="welcomeOverlay">
    <div id="welcomeMessage"><br>Sch√∂n, dass du da bist!<br></div>
  </div>
  <!-- Game Over Overlay -->
  <div id="gameOverOverlay"></div>
  <!-- Scoreboard Overlay -->
  <div id="scoreboardOverlay" class="hidden"></div>
  <!-- Motivationsfenster -->
  <div id="motivationOverlay"></div>
  <!-- Timer Container -->
  <div id="timerContainer"></div>
  <!-- Hauptinhalt -->
  <div id="mainContent">
    <div id="notation"></div>
    <div id="noteNameDisplay" style="position: fixed; left:50%; bottom:110px; transform: translateX(-50%); font-size:5em; text-transform: uppercase;"></div>
    <div id="buttonContainer">
      <div id="clefTitle" onclick="cycleRange()">C-Lage</div>
      <div id="heartsContainer" style="margin-left:10px;"></div>
    </div>
  </div>
  <!-- Einstellungen-Men√º -->
  <div id="settingsPanel"></div>
  <script>
    /* Falls im Pause-Modus: Aktualisiere Fortschrittsbalken und verbleibende Zeit (mm:ss) */
    function updatePauseProgress() {
      const progressBar = document.getElementById("pauseProgress");
      const timeDisplay = document.getElementById("pauseTime");
      if (progressBar && pauseDuration > 0) {
        const percent = ((pauseDuration - pauseRemaining) / pauseDuration) * 100;
        progressBar.style.width = percent + "%";
        if (timeDisplay) {
          const m = Math.floor(pauseRemaining / 60);
          const s = pauseRemaining % 60;
          timeDisplay.textContent = (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
        }
      }
    }
   
  </script>
  
  <!-- PWA Installations-Button (immer sichtbar) -->
  <div id="pwaInstallContainer" style="display: block; position: fixed; bottom: 20px; right: 20px; z-index: 100;">
    <button id="pwaInstallButton" style="padding: 10px 20px; background: #007aff; color: #fff; border: none; border-radius: 4px; cursor: pointer;">
      App als PWA installieren
    </button>
  </div>
  <script>
    let deferredPrompt;
    // Abfangen des beforeinstallprompt-Events (ohne Anzeige-Bedingung)
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      console.log('beforeinstallprompt Event empfangen');
    });
    // Wenn die App installiert wurde, verstecke den Installationsbereich
    window.addEventListener('appinstalled', () => {
      document.getElementById('pwaInstallContainer').style.display = 'none';
    });
    // Beim Klick auf den Button den Installations-Prompt ausl√∂sen
    document.getElementById('pwaInstallButton').addEventListener('click', () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the PWA install prompt');
          } else {
            console.log('User dismissed the PWA install prompt');
          }
          deferredPrompt = null;
          document.getElementById('pwaInstallContainer').style.display = 'none';
        });
      } else {
        console.log('PWA Installations-Prompt is not available');
      }
    });
  </script>
  
</body>
</html>
