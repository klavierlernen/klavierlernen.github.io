
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Klavierlern‚ÄëApp</title>
  <style>
    /* Blinker-Cursor f√ºr Chat-Intro */
    .cursor-dot {
      display: inline-block;
      width: 0.6rem;
      height: 0.6rem;
      background-color: #000;
      border-radius: 50%;
      margin-left: 0.2rem;
      animation: blink 1s step-start infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    /* Chat-Zeilen f√ºr Intro und allgemeine Chat-Zeilen */
    .chat-line {
      margin: 0.3rem 0;
      transition: opacity 0.4s, max-height 0.4s, margin 0.4s, transform 0.4s;
      max-height: 100px;
      overflow: hidden;
    }
    .faded-line {
      opacity: 0.5;
    }
    .active-line {
      opacity: 1;
    }

    /* Grundlegendes Layout und Typografie */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
      background-color: #ffffff;
      color: #000000;
    }

    /* Begr√º√üungs‚ÄëOverlay */
    #intro {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: #ffffff;
      z-index: 999;
      padding: 2rem;
      font-size: 5rem;
      box-sizing: border-box;
    }
    #intro.hidden {
      display: none;
    }
    #messages {
      margin-bottom: 1rem;
      font-size: 2.2rem;
      font-weight: bold;
      line-height: 1.4;
    }
    .chat-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
      max-width: 800px;
    }
    #name-input {
      visibility: hidden;
      border: none;
      outline: none;
      background: transparent;
      font-size: 2.2rem;
      font-weight: bold;
      color: #000;
      line-height: 1.4;
      margin: 0;
      vertical-align: baseline;
      display: inline-block;
      padding: 0;
      height: auto;
      font-family: inherit;
      min-width: auto;
      flex: none;
      box-sizing: content-box;
      transition: width 0.2s ease;
    }

      .input-line {
        display: inline-flex;
        align-items: center;   /* statt baseline */
        width: auto;
      }

      #intro button {
        background-color: #000;
        color: #fff;
        border: none;
        border-radius: 2rem;
        padding: 0.5rem 1rem;
        margin-left: 0.5rem;
        cursor: pointer;
        font-size: 1rem;     /* etwas n√§her an der Input-Schriftgr√∂√üe */
        line-height: 1.4;
        transition: background 0.15s, color 0.15s;
        align-items: center;   /* <- Semikolon nicht vergessen */
      }
    #intro button:hover,
    #intro button:focus {
      background-color: #222;
      color: #fff;
    }

    /* Hauptbereich */
    #main {
      display: none;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 1rem;
      
    }
    #greeting {
      font-size: 5.2rem;
      font-weight: bold;
    }

    /* Notationsbereich */
    #notation-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      box-sizing: border-box;
    }
    #notation {
      width: 100%;
      max-width: 600px;
      height: 200px;
    }

    /* Steuerungsbuttons */
    #controls {
      padding: 1rem;
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      border-top: 1px solid #e0e0e0;
    }
    button.position-btn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      background-color: transparent;
      border: 1px solid #000;
      cursor: pointer;
    }
    button.position-btn.active {
      background-color: #000;
      color: #fff;
    }
    button.position-btn:hover,
    button.position-btn:focus {
      background-color: #fff;
      color: #000;
    }
    #status-message {
      text-align: center;
      padding: 0.5rem;
      font-size: 0.9rem;
      min-height: 1.5rem;
    }
      
      .chat-line {
        margin: 0.3rem 0;
        max-height: 100px;
        overflow: hidden;
        transition: transform 0.4s ease, opacity 0.4s ease;
      }

      /* Neue Animation f√ºr nach oben rutschen */
      .shift-up {
        transform: translateY(-120%);
        opacity: 0;
      }
      
      #notation {
          width: 80vw;
        max-width: 80%;
        height: auto;
        transform: scale(1.2); /* 120% Zoom */
        transform-origin: center;
      }
      #notation svg {
        width: 100%;
        height: auto;
      }
      
      #position-selector {
        display: flex;
        justify-content: center;
        gap: 1rem;
        padding: 1rem;
      }

      .pos-btn {
        position: relative;
        width: 20px;
        height: 20px;
        background: #000;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      /* Aktiver Button zeigt Buchstaben in der Pille */
      .pos-btn.active::before {
        content: attr(data-pos);
        color: #fff;
        font-size: 0.9rem;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
      }

      /* Aktiver Button = gestreckte Linie */
      .pos-btn.active {
        width: 60px;
        border-radius: 1rem;
      }

      /* Plus-Button bleibt immer ein Kreis mit zentriertem Plus */
      .plus-btn {
        width: 20px !important;
        height: 20px !important;
        border-radius: 50% !important;
        font-size: 1rem;
        font-weight: bold;
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .plus-btn.active {
        width: 20px !important;
        border-radius: 50% !important;
      }
      .plus-btn::before {
        content: none; /* verhindert Anzeige von data-pos im Inneren */
      }
      
      .note-range {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        gap: 1rem;
      }
      .note-control {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .note-control button.arrow {
        background: none;
        border: none;
        font-size: 1.2rem;
        cursor: pointer;
      }
      
      </style>
</head>
<body>
  <!-- Begr√º√üungs‚ÄëOverlay -->
  <div id="intro">
    <div class="chat-container">
      <div id="messages"></div>
      <div class="input-line">
        <input id="name-input" type="text" placeholder="Name" />
        <button id="name-ok" style="display:none;">OK</button>
      </div>
      <div id="tutorial-choice" style="display:none;"></div>
    </div>
  </div>

  <!-- Hauptbereich -->
  <div id="main">
    <div id="header">
      <div id="greeting"></div>
      <!-- Skill-Meter entfernt -->
    </div>
    <div id="notation-container">
      <div id="notation"></div>
      <div id="range-selector" style="display:none; text-align:center;">
        <div class="note-range">
          <div class="note-control">
            <button class="arrow up" data-target="low">‚ñ≤</button>
            <div id="low-note">C2</div>
            <button class="arrow down" data-target="low">‚ñº</button>
          </div>
          <span> - </span>
          <div class="note-control">
            <button class="arrow up" data-target="high">‚ñ≤</button>
            <div id="high-note">C4</div>
            <button class="arrow down" data-target="high">‚ñº</button>
          </div>
        </div>
        <button id="range-ok" style="margin-top:1rem; padding:0.5rem 1rem; border-radius:2rem; background:black; color:white;">OK</button>
      </div>
    </div>
    <div id="status-message"></div>
    <div id="log-output" style="font-size:0.8rem; padding:0.5rem; border-top:1px solid #ccc; height:100px; overflow-y:auto; background:#f9f9f9; color:#333;"></div>
    <div id="position-selector">
      <button class="pos-btn" data-pos="C"></button>
      <button class="pos-btn" data-pos="G"></button>
      <button class="pos-btn" data-pos="F"></button>
      <button class="pos-btn" data-pos="D"></button>
      <button class="pos-btn" data-pos="M"></button>
      <button class="pos-btn plus-btn" data-pos="+">+</button>
    </div>
  </div>

  <!-- VexFlow Bibliothek
       Zur Laufzeit soll VexFlow m√∂glichst offline verf√ºgbar sein. Anstatt die
       Bibliothek von einem CDN zu laden, greifen wir auf die lokale
       Installation in node_modules zu. Dadurch k√∂nnen Browser, die das
       Laden externer Skripte von file://-URLs blockieren, den Code ohne
       Netzwerkzugriff ausf√ºhren. -->
  <!-- Hinweis: der Pfad beginnt mit ./ damit der Browser die Datei relativ zur
       HTML‚ÄëDatei findet. Ohne das Pr√§fix kann Chromium bei file://‚ÄëURLs
       Schwierigkeiten haben, das Skript zu laden. -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <script>
    // Log-Ausgabe-Funktion und √úberschreiben von console.log/error
    function logMessage(msg) {
      const logEl = document.getElementById('log-output');
      if (!logEl) return;
      const p = document.createElement('div');
      p.textContent = msg;
      logEl.appendChild(p);
      logEl.scrollTop = logEl.scrollHeight;
    }
    const origLog = console.log;
    console.log = function(...args) {
      origLog.apply(console, args);
      logMessage(args.join(' '));
    };
    const origError = console.error;
    console.error = function(...args) {
      origError.apply(console, args);
      logMessage("‚ùå " + args.join(' '));
    };
    (() => {
      // ----------------------------------------------
      // Utility‚ÄëFunktionen f√ºr Positionen und Notennamen
      // ----------------------------------------------
      const POSITIONS = {
        C: {
          name: 'C-Lage',
          notes: ['C4', 'D4', 'E4', 'F4', 'G4'],
        },
        G: {
          name: 'G-Lage',
          notes: ['G4', 'A4', 'B4', 'C5', 'D5'],
        },
        F: {
          name: 'F-Lage',
          notes: ['F4', 'G4', 'A4', 'Bb4', 'C5'],
        },
        D: {
          name: 'D-Lage',
          notes: ['D4', 'E4', 'F#4', 'G4', 'A4'],
        },
        M: {
          name: 'Mittlere C-Lage',
          notes: ['C4', 'D4', 'E4', 'F4', 'G4'],
        },
      };

      // Erzeuge Notennamen aus MIDI‚ÄëZahl
      function midiToNoteName(noteNumber) {
        const name = NOTE_NAMES[noteNumber % 12];
        const octave = Math.floor(noteNumber / 12) - 1;
        return `${name}${octave}`;
      }

      // Lade gespeicherten Namen und Skill‚ÄëDaten aus localStorage
      function getStoredName() {
        try {
          return localStorage.getItem('username');
        } catch (e) {
          return null;
        }
      }
      function setStoredName(name) {
        try {
          localStorage.setItem('username', name);
        } catch (e) {}
      }

      // Tutorial-√úbung Steuerung
      let tutorialExerciseActive = false;
      let expectedSequence = [];
      let sequenceIndex = 0;

      // Aktuelle Lage und aktuell angezeigte Note
      let currentPosition = 'C';
      let currentNote = null;

      // VexFlow Objekte
      let vfFactory;
      let vfScore;
      
      let currentStaveNote = null;
      let currentNotes = [];
      let currentExpected = [];
      let currentNoteIndex = 0;
      
      // --- Notenbereich f√ºr Range-Selector ---
      const NOTES = [];
      const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      for (let midi = 21; midi <= 108; midi++) {
        const name = NOTE_NAMES[midi % 12] + (Math.floor(midi / 12) - 1);
        NOTES.push({ midi, name });
      }
      let lowIndex = NOTES.findIndex(n => n.name === "C2");
      let highIndex = NOTES.findIndex(n => n.name === "C4");

      // DOM‚ÄëElemente
      const introEl = document.getElementById('intro');
      const messagesEl = document.getElementById('messages');
      const nameInputEl = document.getElementById('name-input');
      const nameOkBtn = document.getElementById('name-ok');
      const tutorialChoiceEl = document.getElementById('tutorial-choice');
      const mainEl = document.getElementById('main');
      const greetingEl = document.getElementById('greeting');
      const skillMeterEl = document.getElementById('skill-meter');
      const notationEl = document.getElementById('notation');
      const statusMessageEl = document.getElementById('status-message');
      
      function markNoteColorByIndex(noteIndex, color) {
        const svgNotes = notationEl.querySelectorAll("svg g.vf-stavenote");
        if (!svgNotes[noteIndex]) return;

        svgNotes[noteIndex].querySelectorAll("path, circle, ellipse").forEach(shape => {
          shape.setAttribute("fill", color);
          shape.setAttribute("stroke", color);
        });
      }
      

      // Zuf√§llige Note aus der aktuellen Lage ausw√§hlen
      function generateRandomNote() {
        const notes = POSITIONS[currentPosition].notes;
        const index = Math.floor(Math.random() * notes.length);
        return notes[index];
      }

      // Einzelne Note rendern
      function renderNote(note) {
        const notationEl = document.getElementById('notation');
        // Canvas/Div zur√ºcksetzen
        notationEl.innerHTML = '';
        // Neue Factory erstellen
        const VF = window.VexFlow || (window.Vex ? window.Vex.Flow : null);
        // Wenn die Bibliothek nicht verf√ºgbar ist, informiere den Benutzer und brich ab
        if (!VF) {
          notationEl.textContent = 'VexFlow konnte nicht geladen werden.';
          return;
        }
        vfFactory = new VF.Factory({
          renderer: { elementId: 'notation', width: 500, height: 200 },
        });
        vfScore = vfFactory.EasyScore();
        const system = vfFactory.System();
        // Notenstring vorbereiten (viertel Note)
        const notesStr = `${note}/q, B4/h/r.`; // eine Note und dann eine halbe Pause als Platzhalter
        const voice = vfScore.voice(vfScore.notes(notesStr));
        system
          .addStave({ voices: [voice] })
          .addClef('treble')
          .addTimeSignature('4/4');
        vfFactory.draw();
      }

      // Neue Note generieren und rendern
      function nextExercise() {
        currentNote = generateRandomNote();
        renderNote(currentNote);
      }

      // Note vergleichen und Skill aktualisieren
      function handleUserNote(noteName) {
        // Falls wir im Tutorial sind ‚Üí alte Logik
        if (tutorialExerciseActive) {
          const expected = expectedSequence[sequenceIndex];
          const userBase = noteName.replace(/\d/, '');
          const expectedBase = expected.replace(/\d/, '');

          if (userBase === expectedBase) {
            sequenceIndex++;
            statusMessageEl.textContent = `Richtig: ${noteName}`;
            if (sequenceIndex >= expectedSequence.length) {
              statusMessageEl.textContent = "√úbung abgeschlossen!";
              tutorialExerciseActive = false;
            }
          } else {
            statusMessageEl.textContent = `Falsch, erwartet: ${expected}`;
          }
          return;
        }

        // Hauptscreen-Logik
        if (!currentExpected.length) return;

        const expectedName = currentExpected[currentNoteIndex];
        const userBase = noteName.replace(/\d/, '');
        const expectedBase = expectedName.replace(/\d/, '');

        if (userBase === expectedBase) {
          // Richtige Eingabe ‚Üí gr√ºn einf√§rben und n√§chste Note
          markNoteColorByIndex(currentNoteIndex, 'green');
          currentNoteIndex++;

          if (currentNoteIndex >= currentNotes.length) {
            setTimeout(renderInitialStaff, 1000);
          }
        } else {
          // Falsch ‚Üí rot einf√§rben, aber Index nicht erh√∂hen
          markNoteColorByIndex(currentNoteIndex, 'red');
        }
      }

      // ----------------------------
      // MIDI-Quellenerkennung und Initialisierung (robust, WebMIDI vs. Swift-Bridge)
      // ----------------------------
      document.addEventListener("DOMContentLoaded", () => {
        let midiSource = "MIDI (Unknown)";
        if (window.webkit?.messageHandlers?.customPrompt) {
          midiSource = "MIDI iOS (Swift Bridge)";
          console.log("üì± MIDI-Quelle:", midiSource);
        } else if (navigator.requestMIDIAccess) {
          midiSource = "MIDI Web (Browser)";
          console.log("üåê MIDI-Quelle:", midiSource);
        } else {
          midiSource = "MIDI (Nicht unterst√ºtzt)";
          console.warn("‚ùå MIDI-Quelle:", midiSource);
        }
      });

      // MIDI-Initialisierung: unterscheidet WebMIDI vs. Swift-Bridge
      function initMIDI() {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt) {
          // Swift-Bridge: MIDI kommt √ºber receiveMIDIFromSwift
          console.log("üì± MIDI: Warte auf Eingaben von der Swift-App (iOS Bridge).");
          // Keine weitere Initialisierung n√∂tig, Swift ruft receiveMIDIFromSwift auf
        } else if (navigator.requestMIDIAccess) {
          // WebMIDI verf√ºgbar
          navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
        } else {
          // Kein MIDI verf√ºgbar
          console.warn("‚ùå Weder WebMIDI noch Swift-Bridge verf√ºgbar.");
        }
      }

      function onMIDISuccess(midiAccess) {
        console.log("‚úÖ MIDI Zugriff erfolgreich.");
        // Alle Eing√§nge √ºberwachen
        for (let input of midiAccess.inputs.values()) {
          console.log("üéπ MIDI Ger√§t gefunden:", input.name);
          input.onmidimessage = handleMIDIMessage;
        }
        // Auf neue Ger√§te reagieren (z. B. Keyboard sp√§ter eingesteckt)
        midiAccess.onstatechange = (event) => {
          if (event.port.type === "input" && event.port.state === "connected") {
            console.log("üîå Neues MIDI Ger√§t verbunden:", event.port.name);
            event.port.onmidimessage = handleMIDIMessage;
          }
        };
      }

      function onMIDIFailure() {
        console.error("‚ùå Zugriff auf MIDI-Ger√§te verweigert oder nicht m√∂glich.");
      }

      // Hilfsfunktion: MIDI Note Number ‚Üí Name (beibehalten)
      function midiNoteToName(noteNumber) {
        const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        const octave = Math.floor(noteNumber / 12) - 1;
        return names[noteNumber % 12] + octave;
      }

      // Zentrale Verarbeitung f√ºr MIDI-Ereignisse (WebMIDI & Swift-Bridge)
      function handleMIDIMessage(arg1, arg2, arg3) {
        let status, noteNumber, velocity;
        if (typeof arg1 === "object" && arg1.data) {
          // WebMIDI Event
          [status, noteNumber, velocity] = arg1.data;
        } else {
          // Swift-Bridge Event (drei Zahlen)
          status = arg1;
          noteNumber = arg2;
          velocity = arg3;
        }

        // Logging f√ºr Debug
        console.log("üì• MIDI Event:", status, noteNumber, velocity);

        // Kanal unabh√§ngig machen
        const command = status & 0xf0; // maskiert den Kanal
        if (command === 0x90 && velocity > 0) {
          // Note On
          const noteName = midiNoteToName(noteNumber);
          console.log("üéµ Note pressed:", noteName);
          handleUserNote(noteName);
        } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
          // Note Off
          console.log("üîà Note released:", midiNoteToName(noteNumber));
        } else {
          // Andere MIDI-Kommandos ignorieren, aber loggen
          console.log("‚ÑπÔ∏è Anderes MIDI-Kommando:", command.toString(16));
        }
      }
      
     

      
      

      

      // Lage wechseln, Buttons aktualisieren
      function setPosition(pos) {
        currentPosition = pos;

        // Button-Styles aktualisieren
        document.querySelectorAll('button.pos-btn').forEach(btn => {
          btn.classList.toggle('active', btn.getAttribute('data-pos') === pos);
        });

        // Nur bei echten Lagen das Notensystem neu zeichnen
        if (POSITIONS[pos]) {
          renderInitialStaff();
        }
      }

      // Chat‚Äë√§hnliche Begr√º√üung
      const introMessages = [
        'Hallo! Ich bin Finn',
        'Ich unterst√ºtze dich beim Lernen der Noten',
        'Wie hei√üt du?'
      ];
      let introIndex = 0;
      function typeMessage(message, callback, withCursorDot = true) {
        let i = 0;
        // Vor neuer Zeile: alle bisherigen Zeilen ausblenden (50%)
        Array.from(messagesEl.children).forEach(child => {
          child.classList.remove('active-line');
          child.classList.add('faded-line');
        });
        // Neue Zeile f√ºr die Nachricht
        const lineDiv = document.createElement('div');
        lineDiv.classList.add('chat-line', 'active-line');
        // Cursor-Element erzeugen
        let cursor = null;
        // Cursor-dot immer zu Beginn sichtbar, wenn gew√ºnscht
        if (withCursorDot) {
          cursor = document.createElement('span');
          cursor.className = 'cursor-dot';
          lineDiv.appendChild(cursor); // Erstmal nur Cursor, Text wird hinzugef√ºgt
        }
        messagesEl.appendChild(lineDiv);
        // Setze Text dynamisch vor dem Cursor
        const interval = setInterval(() => {
          // F√ºge n√§chsten Buchstaben vor dem Cursor ein
          if (cursor) {
            cursor.before(document.createTextNode(message.charAt(i)));
          } else {
            lineDiv.appendChild(document.createTextNode(message.charAt(i)));
          }
          i++;
          if (i >= message.length) {
            clearInterval(interval);
            // Cursor-dot IMMER nach Tipp-Ende entfernen, egal ob withCursorDot true oder false
            if (cursor) {
              cursor.remove();
            }
            // Neue Logik: Chat-Zeilen-Begrenzung nach vollst√§ndigem Schreiben
            enforceMaxChatLines();
            setTimeout(() => callback && callback(), 600);
          }
        }, 40);
      }

      // Begrenzung der Chat-Zeilen: entfernt die erste Zeile mit Fade-Out-Animation, sobald mehr als max Zeilen vorhanden sind
      function enforceMaxChatLines(max = 4) {
        if (messagesEl.children.length > max) {
          const first = messagesEl.firstElementChild;
          if (first) {
            first.classList.add('shift-up');
            first.addEventListener('transitionend', () => {
              if (first.parentElement === messagesEl) {
                messagesEl.removeChild(first);
              }
            }, { once: true });
          }
        }
      }

      // Funktion moveCursorDotToInput entfernt, da Cursor-Dot nicht mehr zu Input verschoben wird

      function runIntro() {
        if (introIndex < introMessages.length) {
          const msg = introMessages[introIndex];
          introIndex++;
          // Nur f√ºr reine Chat-Nachrichten (ohne Buttons/Input): withCursorDot true
          // Bei der letzten Nachricht (vor Input) KEIN cursor-dot mehr, da danach Input erscheint
          if (introIndex === introMessages.length) {
            // Letzte Zeile vor Input: KEIN cursor-dot
            typeMessage(msg, runIntro, false);
          } else {
            typeMessage(msg, runIntro, true);
          }
        } else {
          // Nach der letzten Nachricht das Eingabefeld und OK-Button anzeigen, OHNE cursor-dot verschieben
          nameInputEl.style.visibility = 'visible';
          nameOkBtn.style.display = 'inline-block';
          nameInputEl.addEventListener('input', function() {
            const len = Math.max(nameInputEl.value.length, nameInputEl.placeholder.length);
            nameInputEl.style.width = len + 'ch';
          });
        }
      }

      // Tutorial-Choice anzeigen
      function showTutorialChoice(name) {
        // Neue Chat-Nachricht: M√∂chtest du ein Tutorial ansehen? (ohne cursor-dot, da Buttons erscheinen)
        typeMessage(`${name}, sollen wir dir zeigen, wie die App funktioniert?`, () => {
          tutorialChoiceEl.style.display = 'block';
          tutorialChoiceEl.innerHTML = `
            <button id="tutorial-yes">Gerne!</button>
            <button id="tutorial-no">Ich war schon mal hier.</button>
          `;
          // Event-Listener f√ºr Ja/Nein
          document.getElementById('tutorial-yes').addEventListener('click', () => {
            tutorialChoiceEl.style.display = 'none';
            runTutorial(name);
          });
          document.getElementById('tutorial-no').addEventListener('click', () => {
            tutorialChoiceEl.style.display = 'none';
            enterMain(name);
          });
        }, false);
      }

      // Tutorial-Funktion
      function runTutorial(name, index = 0) {
        const tutorialMessages = [
          "Alles klar! Das Prinzip ist ganz einfach",
          "Im Notensystem erscheint jeweils eine Note, die du auf deinem Keyboard spielen sollst.",
          "Du erh√§ltst umgehend Feedback",
          "Be√ºben kannst du alle festen Lagen, den Quintenzirkel und mehr.",
          "Viel Spa√ü beim Ausprobieren!"
        ];
        if (index < tutorialMessages.length - 2) {
          typeMessage(tutorialMessages[index], () => runTutorial(name, index + 1), false);
        } else if (index === 3) {
          // Nach dieser Nachricht: √úbungsfunktion starten, dann mit n√§chster Nachricht fortfahren
          typeMessage(tutorialMessages[index], () => {
            startTutorialExercise();
            runTutorial(name, index + 1);
          }, false);
        } else if (index === tutorialMessages.length - 1) {
          // Letzte Tutorial-Nachricht, dann Button anzeigen
          typeMessage(tutorialMessages[index], () => {
            tutorialChoiceEl.style.display = 'block';
            tutorialChoiceEl.innerHTML = `
              <button id="tutorial-finish">love it!</button>
            `;
            document.getElementById('tutorial-finish').addEventListener('click', () => {
              tutorialChoiceEl.style.display = 'none';
              enterMain(name);
            });
          }, false);
        }
      }

      function startTutorialExercise() {
        expectedSequence = ['C4','D4','E4','C4'];
        sequenceIndex = 0;
        tutorialExerciseActive = true;

        // Notensystem mit C, D, E, F anzeigen
        notationEl.innerHTML = '';
        const VF = window.VexFlow || (window.Vex ? window.Vex.Flow : null);
        if (!VF) {
          notationEl.textContent = 'VexFlow konnte nicht geladen werden.';
          return;
        }

        const vf = new VF.Factory({renderer: {elementId: 'notation', width: 500, height: 200}});
        const score = vf.EasyScore();
        const system = vf.System();
        const notes = score.notes('C4/q, D4/q, E4/q, F4/q');
        const voice = score.voice(notes);
        system.addStave({voices:[voice]}).addClef('treble').addTimeSignature('4/4');
        vf.draw();

        statusMessageEl.textContent = "Spiele C, D, E und dann nochmal C!";
      }

      function enterMain(name) {
        introEl.classList.add('hidden');
        mainEl.style.display = 'flex';
        // greetingEl.textContent = `Hallo, ${name}!`; // Begr√º√üungstext entfernt
        setPosition(currentPosition);
        renderInitialStaff();
        initMIDI();
      }

      // Initialisieren
      function init() {
        const storedName = getStoredName();
        if (storedName) {
          // Name vorhanden: Zeige Begr√º√üung mit Tipp-Animation und gehe dann automatisch in den Hauptbereich
          introEl.classList.remove('hidden');
          mainEl.style.display = 'none';
          messagesEl.innerHTML = '';
          // Input und Buttons ausblenden
          nameInputEl.style.display = 'none';
          nameOkBtn.style.display = 'none';
          tutorialChoiceEl.style.display = 'none';
          // Begr√º√üung mit Animation in zwei getrennten Nachrichten
          typeMessage(`Hallo, ${storedName}.`, () => {
            typeMessage(`Willkommen zur√ºck! (v1.4)`, () => {
              setTimeout(() => enterMain(storedName), 700);
            }, false);
          }, false);
        } else {
          // Begr√º√üung anzeigen und Intro starten
          introEl.classList.remove('hidden');
          runIntro();
        }
      }

      // Event‚ÄëListener f√ºr Namenseingabe
      function handleNameInput() {
        const name = nameInputEl.value.trim();
        if (name) {
          setStoredName(name);
          // Blende Input und OK aus
          nameInputEl.style.display = 'none';
          nameOkBtn.style.display = 'none';
          // Cursor-Dot ggf. entfernen
          const inputContainer = nameInputEl.parentElement;
          const cursorDot = inputContainer.querySelector('.cursor-dot');
          if (cursorDot) cursorDot.remove();
          showTutorialChoice(name);
        }
      }

      nameInputEl.addEventListener('keypress', function (evt) {
        if (evt.key === 'Enter') {
          handleNameInput();
        }
      });
      nameOkBtn.addEventListener('click', function () {
        handleNameInput();
      });

      // Event‚ÄëListener f√ºr Positionsbuttons
      document.querySelectorAll('button.pos-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const pos = btn.getAttribute('data-pos');
          if (pos === 'plus') {
            // Notensystem ausblenden, Range-Selector einblenden
            document.getElementById('notation').style.display = 'none';
            document.getElementById('range-selector').style.display = 'block';
          } else {
            setPosition(pos);
          }
        });
      });

      // Violinenschl√ºssel-Notensystem mit 4 zuf√§lligen Noten aus der aktuellen Lage zeichnen
      function renderInitialStaff() {
        const notationEl = document.getElementById('notation');
        notationEl.innerHTML = '';
        const VF = window.VexFlow || (window.Vex ? window.Vex.Flow : null);
        if (!VF) {
          notationEl.textContent = 'VexFlow konnte nicht geladen werden.';
          return;
        }
        const width = notationEl.clientWidth || 500;
        const height = notationEl.clientHeight || 200;
        vfFactory = new VF.Factory({
          renderer: { elementId: 'notation', width: width, height: height }
        });
        vfScore = vfFactory.EasyScore();
        const system = vfFactory.System({ x: 10, y: 40, width: width - 20, spaceBetweenStaves: 10 });

        // Zuf√§llig 4 Noten aus der aktuellen Position w√§hlen und als echte StaveNotes erzeugen
        const available = POSITIONS[currentPosition].notes;
        currentNotes = [];
        currentExpected = [];
        for (let i = 0; i < 4; i++) {
          const noteName = available[Math.floor(Math.random() * available.length)];
          const key = noteName.replace(/(\d)/, "/$1").toLowerCase();
          const staveNote = new VF.StaveNote({ keys: [key], duration: "q" });
          // Standardfarbe explizit setzen (schwarz), damit sp√§tere Farb√§nderungen funktionieren
          staveNote.setKeyStyle(0, { fillStyle: "black", strokeStyle: "black" });
          staveNote.setStemStyle({ fillStyle: "black", strokeStyle: "black" });
          currentNotes.push(staveNote);
          currentExpected.push(noteName);
        }
        currentNoteIndex = 0;

        const voice = vfScore.voice(currentNotes);
        system.addStave({ voices: [voice] }).addClef('treble').addTimeSignature('4/4');
        vfFactory.draw();
      }

      // Starten
      init();
      // Bei Gr√∂√üen√§nderung das Notensystem neu rendern
      window.addEventListener('resize', renderInitialStaff);
    })();
      
      // Die folgende Logik f√ºr .pos-btn ist nun nicht mehr n√∂tig, da die Event-Listener oben und setPosition() alles erledigen.
      
      // Range W√§hler
      
      function midiToNoteName(noteNumber) {
        const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        const octave = Math.floor(noteNumber / 12) - 1;
        return names[noteNumber % 12] + octave;
      }
      
      // Range-Selector-Pfeile: Notenbereich durch echte Notennamen iterieren
      document.querySelectorAll('#range-selector .arrow').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.target;
          if (target === "low") {
            if (btn.classList.contains("up") && lowIndex < highIndex - 1) lowIndex++;
            if (btn.classList.contains("down") && lowIndex > 0) lowIndex--;
            document.getElementById("low-note").textContent = NOTES[lowIndex].name;
          } else {
            if (btn.classList.contains("up") && highIndex < NOTES.length - 1) highIndex++;
            if (btn.classList.contains("down") && highIndex > lowIndex + 1) highIndex--;
            document.getElementById("high-note").textContent = NOTES[highIndex].name;
          }
        });
      });
      
      
      function renderCustomStaff(low, high) {
        const notationEl = document.getElementById('notation');
        notationEl.innerHTML = '';
        const VF = window.VexFlow || (window.Vex ? window.Vex.Flow : null);
        if (!VF) {
          notationEl.textContent = 'VexFlow konnte nicht geladen werden.';
          return;
        }

        vfFactory = new VF.Factory({ renderer: { elementId: 'notation', width: 500, height: 200 } });
        vfScore = vfFactory.EasyScore();
        const system = vfFactory.System({ x: 10, y: 40, width: 480 });

        // m√∂gliche Noten berechnen
        const notesInRange = [];
        for (let i = low; i <= high; i++) {
          notesInRange.push(midiToNoteName(i));
        }

        // 4 zuf√§llige Noten aus dem Bereich
        currentNotes = [];
        currentExpected = [];
        for (let i = 0; i < 4; i++) {
          const noteName = notesInRange[Math.floor(Math.random() * notesInRange.length)];
          const key = noteName.replace(/(\d)/, "/$1").toLowerCase();
          const staveNote = new VF.StaveNote({ keys: [key], duration: "q" });
          staveNote.setKeyStyle(0, { fillStyle: "black", strokeStyle: "black" });
          staveNote.setStemStyle({ fillStyle: "black", strokeStyle: "black" });
          currentNotes.push(staveNote);
          currentExpected.push(noteName);
        }
        currentNoteIndex = 0;

        const voice = vfScore.voice(currentNotes);
        system.addStave({ voices: [voice] }).addClef('treble').addTimeSignature('4/4');
        vfFactory.draw();
      }
      
      // Nur ein Event-Listener-Block f√ºr .pos-btn, der data-pos="+" speziell behandelt
      document.querySelectorAll('button.pos-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const pos = btn.getAttribute('data-pos');
          if (pos === '+') {
            const notationEl = document.getElementById('notation');
            notationEl.style.display = 'none';
            document.getElementById('range-selector').style.display = 'block';
          } else {
            setPosition(pos);
          }
        });
      });
      
      document.querySelectorAll('#range-selector .arrow').forEach(btn => {
        btn.addEventListener('click', () => {
          const target = btn.dataset.target;
          if (target === "low") {
            if (btn.classList.contains("up")) lowIndex++;
            if (btn.classList.contains("down")) lowIndex--;
            if (lowIndex >= highIndex) lowIndex = highIndex - 1;
            document.getElementById("low-note").textContent = midiToNoteName(lowIndex);
          } else {
            if (btn.classList.contains("up")) highIndex++;
            if (btn.classList.contains("down")) highIndex--;
            if (highIndex <= lowIndex) highIndex = lowIndex + 1;
            document.getElementById("high-note").textContent = midiToNoteName(highIndex);
          }
        });
      });
      
      document.getElementById('range-ok').addEventListener('click', () => {
        document.getElementById('range-selector').style.display = 'none';
        document.getElementById('notation').style.display = 'block';
        renderCustomStaff(NOTES[lowIndex].midi, NOTES[highIndex].midi);
      });

      function renderCustomStaff(lowMidi, highMidi) {
        const notationEl = document.getElementById('notation');
        notationEl.innerHTML = '';
        const VF = window.VexFlow;
        if (!VF) {
          notationEl.textContent = 'VexFlow konnte nicht geladen werden.';
          return;
        }

        const width = notationEl.clientWidth || 500;
        const height = notationEl.clientHeight || 200;
        vfFactory = new VF.Factory({ renderer: { elementId: 'notation', width, height } });
        vfScore = vfFactory.EasyScore();
        const system = vfFactory.System({ x: 10, y: 40, width: width - 20 });

        // Noten im Bereich berechnen
        const notesInRange = NOTES.filter(n => n.midi >= lowMidi && n.midi <= highMidi).map(n => n.name);

        currentNotes = [];
        currentExpected = [];
        for (let i = 0; i < 4; i++) {
          const noteName = notesInRange[Math.floor(Math.random() * notesInRange.length)];
          const key = noteName.replace(/(\d)/, "/$1").toLowerCase();
          const staveNote = new VF.StaveNote({ keys: [key], duration: "q" });
          staveNote.setKeyStyle(0, { fillStyle: "black", strokeStyle: "black" });
          staveNote.setStemStyle({ fillStyle: "black", strokeStyle: "black" });
          currentNotes.push(staveNote);
          currentExpected.push(noteName);
        }
        currentNoteIndex = 0;

        const voice = vfScore.voice(currentNotes);
        system.addStave({ voices: [voice] }).addClef('treble').addTimeSignature('4/4');
        vfFactory.draw();
      }
  </script>
</body>
</html>

     
