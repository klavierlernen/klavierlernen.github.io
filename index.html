<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Notentraining - Anpassung</title>
  <!-- VexFlow laden -->
  <link rel="manifest" href="https://raw.githubusercontent.com/JP0024/piano.github.io/main/manifest.json">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="icon-192.png">
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <!-- canvas-confetti laden -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    /* Grundlayout */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #F8F8FF;
      font-family: sans-serif;
      text-align: center;
      transition: background-color 0.3s, color 0.3s;
      overflow: hidden;
    }

    body.dark-mode {
      background-color: #0A0A0A;
      color: #e0e0e0;
    }
    /* Vollbild-Canvas f√ºr Animation (Hintergrund) */
    #animationCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5; /* niedriger als Men√ºs */
      filter: blur(20px);
      opacity: 0.2;
      pointer-events: none;
    }
    /* Einhand-Notation (normaler Modus) */
    #notation {
      display: none;
      position: fixed;
      top: 80%;
      left: 65%;
      transform: translate(-50%, -50%);
      width: 100%;
      max-width: calc(100% - 10px);
      padding: 10px;
      box-sizing: border-box;
      z-index: 1;
    }
    #notation svg {
      width: 100%;
      height: auto;
      shape-rendering: crispEdges;
      display: block;
      margin: 0 auto;
    }
    #notation svg * {
      vector-effect: non-scaling-stroke;
    }
    body.dark-mode #notation svg * {
      stroke: #fff;
      fill: #fff;
    }
    /* Motivationsfenster */
    #motivationOverlay {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      font-size: 2em;
      color: #000;
      text-shadow: none;
    }
    @keyframes floatFade {
      0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
    }
    .animate-motivation {
      animation: floatFade 2.5s ease-out forwards;
    }
    /* Pause-Overlay */
    #pauseOverlay {
      position: fixed;
      top: 15px;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      z-index: 1000;
      display: none;
      flex-direction: column;
    }
    /* Obere Info-Leiste im Pausenmodus */
    #pauseInfo {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }
    #pauseHeader {
      font-size: 2em;
      font-weight: bold;
      color: #000;
      white-space: nowrap;
    }
    /* Fortschrittsbalken */
    #pauseProgressContainer {
      flex-grow: 1;
      height: 20px;
      border: 3px solid #000;
      border-radius: 20px;
      position: relative;
      background: #fff;
    }
    #pauseProgress {
      height: 100%;
      width: 0%;
      background: red;
      border-radius: 20px;
      transition: width 1s linear;
    }
    /* Verbleibende Zeit im Format mm:ss */
    #pauseTime {
      font-size: 14px;
      color: #000;
      white-space: nowrap;
      margin-left: 10px;
    }
    /* Kachelwand im Pausenmodus ‚Äì F√ºllt den restlichen Raum wie eine Tapete */
    #pauseTiles {
      flex-grow: 1;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      grid-auto-rows: 230px;
      gap: 12px;
      overflow-y: auto;
    }
    /* Variierende Kacheln (Mauerstein-Effekt) */
    .tile:nth-child(3n) {
      grid-row: span 2;
    }
    .tile:nth-child(4n) {
      grid-column: span 2;
    }
    .tile {
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 15px;
      font-size: 14px;
      color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }
    .tileIcon {
      font-size: 5em;
      margin-bottom: 8px;
    }
    .tileTitle {
      font-size: 3em;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .tileValue {
      font-size: 2.5em;
      font-weight: normal;
    }
    .barChart {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      width: 100%;
      margin-top: 5px;
      gap: 5px;
    }
    .bar {
      width: 10%;
      background-color: #007aff;
      border-radius: 4px 4px 0 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      color: #fff;
      font-size: 0.8em;
    }
    /* Game Over Overlay */
    #gameOverOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: none;
    }
    body.dark-mode #gameOverOverlay {
      border: 3px solid #fff;
    }
    /* Scoreboard Overlay */
    #scoreboardOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: block;
    }
    .hidden {
      display: none !important;
    }
    /* Timer Container */
    /* Timer Container */
        #timerContainer {
          position: fixed;
          right: 10px;
          bottom: 30px;
          font-size: 1.5em;
          z-index: 100;
          display: flex; /* Versteckt, bis der Intro-Modus beendet ist */
          align-items: center;
          justify-content: center;
          cursor: pointer;
          background: rgba(255, 255, 255, 0.8);
          padding: 5px 10px;
          border-radius: 5px;
        }
    /* Hauptinhalt */
    #mainContent {
      display: none;
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease-in;
      padding-bottom: 50px;
    }
    /* Einstellungen-Men√º */
    #settingsPanel {
      /* Behalte deine Positionierung bei */
      position: fixed;
      top: 150%;
      right: 20px;
      display: none; /* wird sp√§ter per JS auf 'flex' gesetzt */
      flex-direction: column;
      align-items: center;
      z-index: 10;
      border-radius: 10px;
      width: 60px;

      /* 3D-Optik */
      background: white;               /* Heller Pastellton */
      border: 2px solid black;         /* Passender Randton */
      border-radius: 10px;
      box-shadow:
        0 6px 0 black,                 /* ‚Äûfester‚Äú Schatten f√ºr die 3D-Kante */
        0 6px 6px rgba(0, 0, 0, 0.2);    /* Weicher Schlagschatten */
      padding: 15px 24px;                /* Innenabstand */
      margin: 8px;                       /* Au√üenabstand */
      font-size: 1.2em;                  /* Schriftgr√∂√üe */
      text-align: center;
      color: black;
      box-sizing: border-box;

      /* Animation/√úberg√§nge beim Dr√ºcken */
      transition: transform 0.2s, box-shadow 0.2s, opacity 0.5s ease;
    }
    #settingsPanel:active {
      transform: translateY(6px);
      box-shadow:
        0 0 0 #abc9ab,
        0 6px 6px rgba(0,0,0,0.2);
    }

    /* ================================= */
    /* 3D-Stil f√ºr das Lagen-Rechteck    */
    /* ================================= */
    #clefTitle {
      background: #d0e8d0;
      border: 2px solid #b7d3b7;
      border-radius: 8px;
      box-shadow:
        0 6px 0 black,
        0 6px 6px rgba(0, 0, 0, 0.2);
      padding: 16px 24px;
      margin: 8px;
      font-size: 1.2em;
      text-align: center;
      color: #333;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #clefTitle:active {
      transform: translateY(6px);
      box-shadow:
        0 0 0 #abc9ab,
        0 6px 6px rgba(0, 0, 0, 0.2);
    }
    body.dark-mode #settingsPanel {
      background: #000;
      border-color: #fff;
    }
    #settingsPanel span {
      display: block;
      cursor: pointer;
      font-size: 1.8em;
      margin: 8px 0;
      padding: 2px;
      text-align: center;
      background: none;
      border: none;
      transition: background 0.2s, opacity 0.2s;
    }
    #settingsPanel span:hover {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
      100% { transform: translateY(0); }
    }
    
    /* Lagewechsel-Button */
    #clefTitle {
      display: inline-block;
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
      animation: float 3s ease-in-out infinite;
    }
    body.dark-mode #clefTitle {
      background: #000;
      border-color: #fff;
      color: #fff;
    }
    /* Neuer Pausen-Button im Men√º */
    #pauseButton {
      display: inline-block;
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
      margin-top: 10px;
    }
    body.dark-mode #pauseButton {
      background: #000;
      border-color: #fff;
      color: #fff;
    }
    /* Container f√ºr Button & Herzen */
    #buttonContainer {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      z-index: 50;
    }
    #heartsContainer {
      display: inline-block;
      margin-left: 10px;
      vertical-align: middle;
      font-size: 1.5em;
    }
    /* Notenname-Anzeige (normaler Modus) */
    #noteNameDisplay {
      margin-top: 10px;
      font-size: 24px;
      color: #000;
      text-transform: uppercase;
    }
    body.dark-mode #noteNameDisplay { color: #e0e0e0; }
    /* Welcome Overlay */
    #welcomeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
      background-color: transparent;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #welcomeMessage {
      font-size: 2.5em;
      color: #000;
      margin-bottom: 20px;
      font-weight: bold;
    }
    body.dark-mode #welcomeMessage { color: #e0e0e0; }
    
    .bar-chart-container {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      width: 100%;
      padding: 10px;
      height: 120px; /* Gesamth√∂he inkl. Label */
    }

    .bar-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .bar {
      width: 100%;
      background: linear-gradient(to top, black, grey);
      border-radius: 4px 4px 0 0;
      transition: height 0.5s ease-in-out;
    }

    .bar-label {
      margin-top: 4px;
      font-size: 0.9em;
      text-align: center;
      color: #000;
    }
      
      /* Beispiel: Klasse f√ºr eine breite, aber nur 1 Zeile hohe Kachel */
      .tile.span-2 {
        grid-column: span 2;
        /* Falls eine andere Regel (nth-child(3n)) sie hochskalieren w√ºrde, √ºberschreiben wir das: */
        grid-row: span 1 !important;
      }
      
      body.dark-mode #pauseOverlay {
        background: #121212; /* dunkler Hintergrund */
      }

      body.dark-mode #pauseHeader,
      body.dark-mode #pauseTime {
        color: white; /* helle Schrift */
      }

      body.dark-mode #pauseProgressContainer {
        background: black; /* evtl. noch dunklerer Hintergrund f√ºr den Fortschrittsbalken */
        border-color: white;
      }
      
      .tile.span-2 {
        grid-column: span 2;
        grid-row: span 1 !important;
      }
      
      #streakDisplay {
        position: fixed;
        left: 20px;
        bottom: 30px;
        font-size: 1.5em;
        z-index: 50;
      }
      
@media screen and (max-width: 600px) {
  
  /* Notensystem k√ºrzen: Notation-Container anpassen */
  #notation {
    top: 60%;
    max-width: 90%;
    padding: 5px;
  }
  
  /* Passe die Notenanzeige an (falls n√∂tig) */
  #noteNameDisplay {
    font-size: 3em;
    bottom: 80px; /* leicht nach oben verschieben, wenn n√∂tig */
  }
  
  /* Optional: Passe den Button-Container an, falls er zu gro√ü ist */
  #buttonContainer {
    flex-direction: column;
    bottom: 20px;
  }
}

     
     /* Custom Mode Modal Styles */
     #customModeModal {
         position: fixed;
         top: 35%;
         right: 90px; /* ca. 10px links vom Men√º */
         width: 300px;
         background: white;
         border: 2px solid black;
         border-radius: 10px;
         padding: 20px;
         z-index: 150;
     }
     #customModeModal h2 {
         margin-top: 0;
         text-align: center;
     }
     .custom-mode-row {
         display: flex;
         justify-content: space-around;
         margin-bottom: 15px;
         flex-wrap: wrap;
     }
     .custom-mode-clef-container, .custom-mode-range-container, .custom-mode-note-set {
         display: flex;
         gap: 5px;
     }
.custom-mode-clef-option, .custom-mode-range-option, .custom-mode-note-option {
    padding: 5px 10px;
    border: none;
    background: none;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.3s;
    font-weight: bold;
}
     .custom-mode-clef-option.active, .custom-mode-range-option.active, .custom-mode-note-option.active {
         opacity: 1;
     }
     .custom-mode-hand-label {
         align-self: center;
         margin-right: 10px;
         font-weight: bold;
     }
     .custom-mode-save {
         text-align: center;
         margin-top: 20px;
     }
     
     .custom-mode-save button {
         background: white;
         border: 2px solid black;
         border-radius: 8px;
         padding: 10px 20px;
         font-weight: bold;
         cursor: pointer;
         font-size: 1em;
         color: #000;
         transition: transform 0.2s, box-shadow 0.2s;
     }
     
     .custom-mode-save button:active {
         transform: translateY(6px);
         box-shadow:
           0 0 0 #abc9ab,
           0 6px 6px rgba(0,0,0,0.2);
     }
     .hidden {
         display: none !important;
     }
      
  </style>
  <script>
      
      document.addEventListener("DOMContentLoaded", () => {
        const timerElem = document.getElementById("timerContainer");
        // Beispiel: Direkt eine Info setzen
        timerElem.textContent = `${sessionCounter} Noten, vsl. 00:00 min verbleibend`;
        // Oder den Timer sofort updaten, falls du eine Funktion hast:
        updateTimer();
      });
      let elapsedTimer = 0;
      let cachedUserRank = null;
      
      function updateUserPlacement(valueElem, data) {
        const sorted = data.sort((a, b) => {
          const qA = parseInt(a.quote || 0), qB = parseInt(b.quote || 0);
          const sA = parseInt(a.speed || 9999), sB = parseInt(b.speed || 9999);
          if (qB !== qA) return qB - qA;
          return sA - sB;
        });
        const rank = sorted.findIndex((e) => e.user === userID) + 1;
        const text = rank > 0 ? `Platz ${rank}` : "Nicht gefunden";
        cachedUserRank = text;
        valueElem.textContent = text;
      }
      
      function showMotivation(message) {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = message;
          overlay.style.opacity = "1";
          overlay.classList.add("animate-motivation");
          setTimeout(() => {
               overlay.style.opacity = "0";
               overlay.classList.remove("animate-motivation");
          }, 2000);
      }

      function clearMotivation() {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = "";
      }
      
    /************** Funktionen, die vor der Verwendung deklariert sein m√ºssen **************/
    // Eigene Prompt-Funktion, die in Swift-Umgebungen den Message-Handler nutzt
      function customPrompt(message) {
    if (typeof prompt === 'function') {
          return prompt(message);
    } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt) {
          // Sende die Nachricht an Swift; Swift muss dann eine Antwort zur√ºckliefern,
          // z. B. indem es window.customPromptResponse setzt.
          window.webkit.messageHandlers.customPrompt.postMessage(message);
          // Hier nehmen wir an, dass Swift synchron oder zeitnah eine Antwort liefert und
          // diese in window.customPromptResponse speichert. (Alternativ muss hier asynchron vorgegangen werden.)
          return window.customPromptResponse || "";
        } else {
          console.log("Kein Prompt verf√ºgbar.");
          return "";
        }
      }
      
    // Metronom-Variablen und Funktionen
      let metronomeOn =false;
      let metronomeBPM = 0;
      let metronomeInterval = 0;
      let metronomeTimer = null;
      let lastTickTime = 0;
      // Tick-Sound (bitte ggf. die URL anpassen)
      const tickSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/tick.mp3");
    
      function startMetronome() {
        lastTickTime = Date.now();
        tickSound.currentTime = 0;
        tickSound.play();
        metronomeTimer = setInterval(() => {
          tickSound.currentTime = 0;
          tickSound.play();
          lastTickTime = Date.now();
        }, metronomeInterval);
      }
    
      function stopMetronome() {
        clearInterval(metronomeTimer);
      }

      function showPauseScreen() {
        sessionPaused = true;
        document.getElementById("mainContent").style.display = "none";
        document.getElementById("timerContainer").style.display = "none";
        document.getElementById("settingsPanel").style.display = "none";
        document.getElementById("pauseOverlay").style.display = "flex";
      }
      
    // Neue Funktion, die einen gr√ºnen Farbtupfer erzeugt
    function saveButtonEffect() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      
      // Hole die Position des Men√ºs (settingsPanel)
      const settingsPanel = document.getElementById("settingsPanel");
      let x, y;
      if (settingsPanel) {
        const rect = settingsPanel.getBoundingClientRect();
        // Tupfer soll in der Mitte des Men√ºs erscheinen
        x = rect.left + rect.width / 2;
        y = rect.top + rect.height / 2;
      } else {
        // Fallback: Mitte des Canvas
        x = canvas.width / 2;
        y = canvas.height / 2;
      }
      
      // Definiere Parameter f√ºr den Tupfer
      const radius = Math.random() * 200 + 200; // Gr√∂√üe anpassen
      const creationTime = Date.now();
      const duration = 1500; // Dauer in Millisekunden
      
      // Erzeuge den Tupfer (Farbtupfer wird zur globalen circles-Array hinzugef√ºgt)
      circles.push({ x, y, radius, color: "green", creationTime, duration });
    }
      
    function updateStreak() {
      // Hole den bisherigen Streak (falls vorhanden)
      let streak = Number(localStorage.getItem("streak")) || 0;
      // Hole das Datum der letzten Lernsession, falls vorhanden
      let lastDateStr = localStorage.getItem("lastLearnDate");
      // Bestimme heute (ohne Uhrzeit)
      let today = new Date();
      today.setHours(0,0,0,0);
      
      if (lastDateStr) {
        let lastDate = new Date(lastDateStr);
        lastDate.setHours(0,0,0,0);
        // Berechne den Unterschied in Tagen
        let diffDays = (today - lastDate) / (1000 * 60 * 60 * 24);
        if (diffDays === 1) {
          // Konsekutiver Tag: Erh√∂he den Streak
          streak++;
        } else if (diffDays > 1) {
          // Mehr als ein Tag Pause: Streak zur√ºcksetzen
          streak = 1;
        }
        // Falls diffDays === 0: wir sind noch am gleichen Tag; der Streak bleibt unver√§ndert
      } else {
        streak = 1;
      }
      
      // Speichere das heutige Datum und den aktuellen Streak
      localStorage.setItem("lastLearnDate", today.toISOString());
      localStorage.setItem("streak", streak);
      
      return streak;
    }
      
      document.addEventListener("DOMContentLoaded", () => {
        // Aktualisiere und zeige den Streak an:
        const currentStreak = updateStreak();
        const streakDisplay = document.getElementById("streakDisplay");
        streakDisplay.textContent = "üî• " + currentStreak;
        streakDisplay.style.cursor = "pointer";
        streakDisplay.addEventListener("click", () => {
          sessionCounter = 0;
          updateTimer();
          startPauseCountdown();
        });

        // ... restlicher Initialisierungscode
      });
      
    function logSessionStart() {
      const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
      sessionTimes.push(new Date().toISOString());
      localStorage.setItem("sessionTimes", JSON.stringify(sessionTimes));
    }
      
    // Speichert die relevanten Statistiken im localStorage
    function saveStatistics() {
      const stats = {
        totalAttempts: totalAttempts,
        correctAnswers: correctAnswers,
        correctNoteCount: correctNoteCount,
        responseTimes: responseTimes,
        sessionCount: sessionCount,
        hearts: hearts,
        errorNotes: errorNotes,
        // Du kannst hier auch weitere Variablen eintragen, z.B. openTimes, appStartTime etc.
        appStartTime: appStartTime
      };
      localStorage.setItem("appStatistics", JSON.stringify(stats));
    }

    // L√§dt die Statistiken aus dem localStorage und weist sie den globalen Variablen zu
    function loadStatistics() {
      const statsStr = localStorage.getItem("appStatistics");
      if (statsStr) {
        const stats = JSON.parse(statsStr);
        totalAttempts = stats.totalAttempts || 0;
        correctAnswers = stats.correctAnswers || 0;
        correctNoteCount = stats.correctNoteCount || 0;
        responseTimes = stats.responseTimes || [];
        sessionCount = stats.sessionCount || 0;
        hearts = stats.hearts || (unlimitedLives ? Infinity : 4);
        errorNotes = stats.errorNotes || [];
        appStartTime = stats.appStartTime || Date.now();
      }
    }

    // Optional: Speichern der Statistiken, wenn die Seite geschlossen wird
    window.addEventListener("beforeunload", saveStatistics);

    // Beim Laden der Seite die Statistiken laden
    document.addEventListener("DOMContentLoaded", loadStatistics);
    
    function proceedToMainScreen() {
      const audio = document.getElementById("backgroundSound");
      if (audio) { audio.pause(); }
      appStartTime = Date.now();
      const welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.opacity = "0";
      setTimeout(() => {
        welcomeOverlay.classList.add("hidden");
        const mainContent = document.getElementById("mainContent");
        mainContent.style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        setTimeout(() => { mainContent.style.opacity = "1"; }, 10);
      }, 500);
    }
    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      const settingsPanel = document.getElementById("settingsPanel");
      const pauseButton = document.createElement("span");
      pauseButton.id = "pauseButton";
      pauseButton.textContent = "üõü";
      settingsPanel.appendChild(pauseButton);

      pauseButton.addEventListener("click", () => {
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.openLink) {
          window.webkit.messageHandlers.openLink.postMessage("https://github.com/jp0024/piano.github.io/wiki");
        } else {
          window.open("https://github.com/jp0024/piano.github.io/wiki", "_blank");
        }
      });
    });
      
    /************** Globale Variablen & Konstanten **************/
    // Handoptionen
    const handOptions = [
      { mode: "left", symbol: "‚úã" },
      { mode: "right", symbol: "‚úã", flip: true }
    ];
    let currentHandIndex = 0;
    let selectedMode = handOptions[currentHandIndex].mode;
    let randomMode = false;
    
    // Verf√ºgbare Lagen
    const rangeArray = ["C", "D", "F", "G", "MC"];
    const alternatingRanges = ["C", "D", "MC"]; // Vordefinierte Lagen, die im Hasenmodus alternieren sollen
    let currentRangeIndex = 0;
    let currentRange = rangeArray[currentRangeIndex];
    
    // Wichtig: Definition der rangeNotes ‚Äì Zuordnung von Lage zu Noten
    const rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    let currentSeriesSingle = [];
    let seriesCounter = 1000;
    const seriesLength = 5;
    let totalAttempts = 0;
    let correctAnswers = 0;
    let correctNoteCount = 0;
    let nextMotivationThreshold = getRandomThreshold();
    let errorNotes = [];
    let responseTimes = [];
    let lastNoteTimestamp = Date.now();
    let appStartTime = Date.now();
    let sessionCounter = 1000; // 5 korrekte Noten erforderlich
    let sessionPaused = false;
    let scoreRecorded = false;
    let sessionCount = 0;
    let unlimitedLives = true;
    let hearts = unlimitedLives ? Infinity : 4;
    let inactivityTimeout = null;
    
    // Beim Laden der Seite oder zu Beginn eines Trainings:
    const saveOpenTime = () => {
      const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
      openTimes.push(new Date().toISOString());
      localStorage.setItem("openTimes", JSON.stringify(openTimes));
    };

    document.addEventListener("DOMContentLoaded", saveOpenTime);
    
    const updateHeartsDisplay = () => {
      const heartsElem = document.getElementById("heartsContainer");
      heartsElem.textContent = unlimitedLives ? "" : "‚ù§Ô∏è".repeat(hearts);
    };
      const updateTimer = () => {
        const timerElem = document.getElementById("timerContainer");
        
        // Berechne den durchschnittlichen Bearbeitungszeit (in ms), Standard: 1000 ms falls noch keine Werte vorhanden
        let avgResponse = responseTimes.length > 0
          ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
          : 1000;
        
        // Berechne die Fehlerquote: Anteil der Fehlversuche
        let errorRate = totalAttempts > 0
          ? (totalAttempts - correctAnswers) / totalAttempts
          : 0;
        
        // Voraussichtliche Zeit (in Sekunden) = Anzahl verbleibender Noten * (durchschnittliche Bearbeitungszeit in s) * (1 + Fehlerquote)
        let predictedTimeSec = sessionCounter * (avgResponse / 1000) * (1 + errorRate);
        
        // Formatiere in mm:ss
        let minutes = Math.floor(predictedTimeSec / 60);
        let seconds = Math.floor(predictedTimeSec % 60);
        let timeStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
        
        timerElem.textContent = `${sessionCounter} Noten, vsl. ${timeStr} min verbleibend`;
      };
      
      function updatePauseTiles() {
        const container = document.getElementById("pauseTiles");
        if (!container) return;

        // Berechne App‚ÄëZeit
        const totalTimeSec = Math.floor((Date.now() - appStartTime) / 1000);
        const h = Math.floor(totalTimeSec / 3600);
        const m = Math.floor((totalTimeSec % 3600) / 60);
        const s = totalTimeSec % 60;
        const appTime = (h > 0 ? (h + "h ") : "") + m + "m " + s + "s";

        // Berechne Prozent richtiger Noten
        const correctPercent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;

        // Durchschnittliche Bearbeitungszeit (in Sekunden)
        const avgTimeSec = responseTimes.length
          ? (responseTimes.reduce((acc, t) => acc + t, 0) / responseTimes.length / 1000).toFixed(2)
          : "N/A";

        container.innerHTML = `
          <div class="tile">
            <div class="tileIcon">‚è∞</div>
            <div class="tileTitle">App‚ÄëZeit</div>
            <div class="tileValue">${appTime}</div>
          </div>
          <div class="tile">
            <div class="tileIcon">‚úÖ</div>
            <div class="tileTitle">Richtige Noten</div>
            <div class="tileValue">${correctPercent}%</div>
          </div>
          <div class="tile">
            <div class="tileTitle">Wann √ºbst du am meisten?</div>
            <div class="barChart">
               ${generateBarChartHTML()}
            </div>
          </div>
          ${ generateLearningQualityGraphTile() }
          <div class="tile">
            <div class="tileTitle">Session</div>
            <div class="tileValue">${sessionCount}</div>
          </div>
          ${generateTrophyTile()}
        `;
      }
      
      function getLastThreeSessions() {
        // Beispiel: Session-Daten als Array von Objekten mit responseTimes (ms), errorCount, totalAttempts und sessionTime (in sec)
        const sessions = JSON.parse(localStorage.getItem("sessionData") || "[]");
        return sessions.slice(-3);
      }

      function calculateQuality(session) {
        // Durchschnittliche Antwortzeit in Sekunden (niedriger ist besser)
        const avgResponse = session.responseTimes.length
          ? session.responseTimes.reduce((a, b) => a + b, 0) / session.responseTimes.length / 1000
          : 0;
        // Fehlerquote (niedriger ist besser)
        const errorRate = session.totalAttempts ? (session.errorCount / session.totalAttempts) : 0;
        // Die Session-Dauer in Sekunden ‚Äì l√§ngere Sessions k√∂nnen auf mehr Engagement hinweisen
        const learningTime = session.sessionTime || 0;
        // Beispielhafte Gewichtung: Wir wollen, dass niedrigere Antwortzeiten und Fehlerquoten zu h√∂heren Qualit√§tswerten f√ºhren.
        // Hier eine einfache Rechnung, die in den meisten F√§llen einen Wert zwischen 0 und 100 liefert.
        let quality = 100 - (avgResponse * 10) - (errorRate * 100) + (learningTime / 60);
        return Math.max(0, Math.min(quality, 100));
      }
      
      function drawLearningQualityGraph(canvas, sessions) {
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // Berechne die Qualit√§tswerte
        const qualities = sessions.map(calculateQuality);

        // Wir erwarten Werte zwischen 0 und 100, also skalieren wir den y-Wert entsprechend.
        ctx.beginPath();
        for (let i = 0; i < qualities.length; i++) {
          const x = (i / (qualities.length - 1)) * width;
          // H√∂here Qualit√§t => niedrigere y-Koordinate (oben ist 0)
          const y = height - (qualities[i] / 100 * height);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          // Optional: Zeichne einen kleinen Kreis als Punkt
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fillStyle = "#007aff";
          ctx.fill();
          ctx.beginPath(); // Beginne neuen Pfad f√ºr die Linie
          if(i === 0) {
            ctx.moveTo(x,y);
          }
        }
        ctx.strokeStyle = "#007aff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      function generateLearningQualityGraphTile() {
        const container = document.createElement("div");
        container.className = "tile span-2";

        const title = document.createElement("div");
        title.className = "tileTitle";
        title.textContent = "üèÖ Platzierung";
        container.appendChild(title);

        const value = document.createElement("div");
        value.className = "tileValue";
        value.textContent = cachedUserRank || "Wird geladen...";
        container.appendChild(value);

        if (userID && !window.cachedScoreboardData) {
          fetch(SHEET_BASE)
            .then((res) => res.json())
            .then((data) => {
              window.cachedScoreboardData = data;
              updateUserPlacement(value, data);
            })
            .catch(() => {
              value.textContent = "Fehler beim Laden";
            });
        } else if (window.cachedScoreboardData && cachedUserRank === null) {
          updateUserPlacement(value, window.cachedScoreboardData);
        }

        return container.outerHTML;
      }

      function generateTrophyTile() {
        const tile = document.createElement("div");
        tile.className = "tile span-2";
        tile.style.display = "flex";
        tile.style.flexDirection = "row";
        tile.style.alignItems = "center";
        tile.style.justifyContent = "space-between";
        const title = document.createElement("div");
        title.className = "tileTitle";
        title.style.flex = "1";
        title.style.display = "flex";
        title.style.flexDirection = "column";
        title.style.justifyContent = "center";
        title.style.alignItems = "center";
        title.innerHTML = "üèÜ Troph√§en                 <span id='resetTrophiesBtn' style='cursor:pointer;' title='Reset'>üóëÔ∏è</span>";
        tile.appendChild(title);

        const trophyGrid = document.createElement("div");
        const wrapper = document.createElement("div");
        wrapper.style.display = "flex";
        wrapper.style.flexDirection = "column";
        wrapper.style.alignItems = "flex-start";
        wrapper.style.flex = "2";
        trophyGrid.style.display = "grid";
        trophyGrid.style.gridTemplateColumns = "repeat(10, 1fr)";
        trophyGrid.style.gridGap = "5px";
        trophyGrid.style.fontSize = "2em";
    trophyGrid.style.marginTop = "10px";
    
    const descriptionBox = document.createElement("div");
    descriptionBox.id = "trophyDescriptionBox";
    descriptionBox.style.marginTop = "10px";
    descriptionBox.style.fontSize = "1em";
    descriptionBox.style.color = "#333";
    descriptionBox.style.minHeight = "2em";
    descriptionBox.style.marginLeft = "20px";
    descriptionBox.style.textAlign = "left";
    descriptionBox.style.maxWidth = "200px";

        const allTrophies = [
          "üê¢","üêå","üö∂‚Äç‚ôÇÔ∏è","üèÉ","‚ö°",
          "üéº","üéπ","üé∫","ü™ï","ü™ó",
          "üå±","üåø","üåª","üå≤","üéÑ","üî•","üöÄ","ü™ê","üåû","üëë",
          "üîÄ","üåÄ","üîÅ","‚è©","‚öôÔ∏è",
          "üìè","üìê","üß≠","üéØ","üèÅ"
        ];

        const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
        const justUnlocked = [];

        allTrophies.forEach((emoji, index) => {
          const span = document.createElement("span");
          span.textContent = emoji;
          span.title = getTrophyDescription(index);
          span.style.cursor = "pointer";
          span.addEventListener("click", () => {
            descriptionBox.textContent = getTrophyDescription(index);
          });
          if (unlockedTrophies.includes(index)) {
            span.style.opacity = "1";
          } else {
            const shouldUnlock = checkTrophyCondition(index);
            if (shouldUnlock) {
              unlockedTrophies.push(index);
              justUnlocked.push(span);
              span.style.opacity = "0";
              setTimeout(() => {
                span.style.transition = "opacity 1s";
                span.style.opacity = "1";
                confetti({ particleCount: 50, spread: 50, origin: { x: 0.5, y: 0.5 } });
              }, 100);
            } else {
              span.style.opacity = "0.5";
            }
          }
          trophyGrid.appendChild(span);
        });

        localStorage.setItem("unlockedTrophies", JSON.stringify(unlockedTrophies));
        wrapper.appendChild(trophyGrid);
        wrapper.appendChild(descriptionBox);
        tile.appendChild(wrapper);
        setTimeout(() => {
          const resetBtn = document.getElementById("resetTrophiesBtn");
          if (resetBtn) {
            resetBtn.addEventListener("click", () => {
              localStorage.removeItem("unlockedTrophies");
              updatePauseTiles();
            });
          }
        }, 0);
        return tile.outerHTML;
      }

      function checkTrophyCondition(index) {
        const avg = responseTimes.length ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
        if (index === 0) return avg < 1500;
        if (index === 1) return avg < 1000;
        if (index === 2) return avg < 900;
        if (index === 3) return avg < 800;
        if (index === 4) return avg < 400;

        if (index >= 5 && index <= 9) {
          const ranges = ["C", "D", "F", "G", "MC"];
          const range = ranges[index - 5];
          return rangeNotes[range].every(note => !errorNotes.some(e => e.note === note));
        }

        const streak = Number(localStorage.getItem("streak") || 0);
        const thresholds = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
        if (index >= 10 && index <= 19) return streak >= thresholds[index - 10];

        if (index >= 20 && index <= 24) {
          const avgSwitch = responseTimes.length > 10 ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
          return avgSwitch < (1500 - (index - 20) * 200);
        }

        if (index >= 25 && index <= 29) {
          if (!metronomeOn) return false;
          const maxDev = Math.max(...responseTimes.map(t => Math.abs(t - metronomeInterval)));
          const devPercent = maxDev / metronomeInterval;
          const limits = [0.3, 0.2, 0.15, 0.1, 0.05];
          return devPercent < limits[index - 25];
        }

        return false;
      }
function getTrophyDescription(index) {
  const descriptions = [
    "Durchschnittliche Reaktionszeit unter 1,5 Sekunden",
    "Durchschnittliche Reaktionszeit unter 1 Sekunde",
    "Durchschnittliche Reaktionszeit unter 0,9 Sekunden",
    "Durchschnittliche Reaktionszeit unter 0,8 Sekunden",
    "Durchschnittliche Reaktionszeit unter 0,4 Sekunden",
    "Fehlerfrei in der C-Lage",
    "Fehlerfrei in der D-Lage",
    "Fehlerfrei in der F-Lage",
    "Fehlerfrei in der G-Lage",
    "Fehlerfrei in der MC-Lage",
    "Streak von mindestens 2 Tagen",
    "Streak von mindestens 3 Tagen",
    "Streak von mindestens 5 Tagen",
    "Streak von mindestens 8 Tagen",
    "Streak von mindestens 13 Tagen",
    "Streak von mindestens 21 Tagen",
    "Streak von mindestens 34 Tagen",
    "Streak von mindestens 55 Tagen",
    "Streak von mindestens 89 Tagen",
    "Streak von mindestens 144 Tagen",
    "Schneller Lagenwechsel (Stufe 1)",
    "Schneller Lagenwechsel (Stufe 2)",
    "Schneller Lagenwechsel (Stufe 3)",
    "Schneller Lagenwechsel (Stufe 4)",
    "Schneller Lagenwechsel (Stufe 5)",
    "Taktgef√ºhl: Abweichung <30%",
    "Taktgef√ºhl: Abweichung <20%",
    "Taktgef√ºhl: Abweichung <15%",
    "Taktgef√ºhl: Abweichung <10%",
    "Taktgef√ºhl: Abweichung <5%"
  ];
  return descriptions[index] || "";
}
                                            
function generateBarChartHTML() {
  // Standardwerte: Jeder Tag wird initial auf 0 gesetzt.
  const dayCounts = { Mo: 0, Di: 0, Mi: 0, Do: 0, Fr: 0, Sa: 0, So: 0 };
  
  // Z√§hle √ñffnungszeiten
  const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
  openTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  // Z√§hle Session-Zeitpunkte
  const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
  sessionTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  const days = ["Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"];
  const maxVal = Math.max(...Object.values(dayCounts), 1);
  
  // Erstelle Container als Flex-Layout f√ºr das Balkendiagramm
  const container = document.createElement("div");
  container.className = "bar-chart-container";
  
  days.forEach(day => {
    const val = dayCounts[day] || 0;
    const barItem = document.createElement("div");
    barItem.className = "bar-item";
    
    const bar = document.createElement("div");
    bar.className = "bar";
    const height = Math.round((val / maxVal) * 100);
    bar.style.height = `${height}px`;
    
    const label = document.createElement("div");
    label.className = "bar-label";
    label.textContent = day;
    
    barItem.appendChild(bar);
    barItem.appendChild(label);
    container.appendChild(barItem);
  });
  
  return container.outerHTML;
}
      
      
let userID = null;
const SHEET_BASE = "https://sheetdb.io/api/v1/yi2z9wznv5tpc"; // <-- HIER SheetDB-Link einsetzen

function calculateAdaptiveBreakTime(responseTimes, hitRate) {
  // Berechne die durchschnittliche Antwortzeit in Millisekunden
  let avgResponse = responseTimes.length > 0
    ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
    : 1000;
  // Verwende hitRate (Erfolgsquote), um die Pausendauer anzupassen:
  // Eine niedrigere Erfolgsquote (mehr Fehler) f√ºhrt zu l√§ngeren Pausen.
  return avgResponse * (1 + (1 - hitRate));
}
      
    const startPauseCountdown = () => {
  logSessionStart(); // Neuen Session-Zeitstempel speichern
  const quote = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
  const speed = responseTimes.length > 0
    ? Math.round(responseTimes.reduce((a, b) => a + b) / responseTimes.length)
    : 0;
  if (!userID) {
    console.error("Keine userID gesetzt! Abbruch.");
    return;
  }
  console.log("User ID f√ºr Suche:", userID);
  fetch(`${SHEET_BASE}/search?user=${userID}`)
        .then(res => res.json())
        .then(([entry]) => {
          if (entry) {
            console.log("Antwort von SheetDB:", entry);
            fetch(`${SHEET_BASE}/user/user=${userID}`, {
              method: "PATCH",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ data: { quote, speed } })
            })
            .then(res => {
              if (res.status === 404) {
                console.warn("PATCH fehlgeschlagen, versuche POST...");
                return fetch(`${SHEET_BASE}`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ data: { user: userID, quote, speed } })
                });
              }
              return res;
            })
            .then(() => {
              return fetch(SHEET_BASE)
                .then(res => res.json())
                .then(data => {
                  window.cachedScoreboardData = data;
                  cachedUserRank = null;
                  updatePauseTiles();
                });
            });
          }
        });
      stopMetronome();
      sessionPaused = true;
      sessionCount++;
      const hitRate = totalAttempts > 0 ? (correctAnswers / totalAttempts) : 1;
      pauseRemaining = Math.floor(calculateAdaptiveBreakTime(responseTimes, hitRate) * 2 + 300);
      pauseDuration = pauseRemaining;

      const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
      const previousTrophies = JSON.parse(sessionStorage.getItem("previousUnlockedTrophies") || "[]");
      
      const justUnlocked = unlockedTrophies.filter(index => !previousTrophies.includes(index));
      const justLost = previousTrophies.filter(index => !unlockedTrophies.includes(index));
      
      sessionStorage.setItem("justUnlockedTrophies", JSON.stringify(justUnlocked));
      sessionStorage.setItem("justLostTrophies", JSON.stringify(justLost));
      sessionStorage.setItem("previousUnlockedTrophies", JSON.stringify(unlockedTrophies));
      
      const pauseOverlay = document.getElementById("pauseOverlay");
      pauseOverlay.innerHTML = `
          <div id="pauseInfo">
            <div id="pauseHeader">SESSION PAUSIERT</div>
            <div id="pauseProgressContainer">
              <div id="pauseProgress"></div>
              <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
            </div>
          </div>
          <div id="pauseTiles"></div>
        `;
      document.getElementById("mainContent").style.display = "none";
      document.getElementById("timerContainer").style.display = "none";
      document.getElementById("settingsPanel").style.display = "none";
      pauseOverlay.style.display = "flex";
      confetti({
        particleCount: 150,
        spread: 70,
        origin: { x: 0.5, y: 0.5 }
      });
      updatePauseProgress();
      updatePauseTiles();
      const msgInterval = setInterval(() => { updatePauseTiles(); }, 3000);
      pauseInterval = setInterval(() => {
        pauseRemaining--;
        updatePauseProgress();
        if (pauseRemaining <= 0) {
          clearInterval(pauseInterval);
          clearInterval(msgInterval);
          endPause();
        }
      }, 1000);
    };
      
      // Erstelle ein Audio-Objekt f√ºr den Gong
      const gongSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/gong-2-232435.mp3");
      
      // In deiner Funktion, die das Pausenfenster beendet, rufe den Sound ab:
      const endPause = () => {
        document.getElementById("pauseOverlay").style.display = "none";
        document.getElementById("mainContent").style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        sessionPaused = false;
        // Setze den Sound zur√ºck und spiele ihn ab
        gongSound.currentTime = 0;
        gongSound.play();
        resetGame();
      };
    let gameOver = false;
    const endGame = () => {
      gameOver = true;
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      gameOverOverlay.textContent = "Game Over!";
      gameOverOverlay.style.display = "block";
      if (!scoreRecorded) recordScore();
      setTimeout(resetGame, 5000);
    };
    const recordScore = () => {
      if (totalAttempts <= 0) return;
      const durationMs = Date.now() - appStartTime;
      const secondsTotal = Math.floor(durationMs / 1000);
      const minutes = Math.floor(secondsTotal / 60);
      const seconds = secondsTotal % 60;
      const durationStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
      const accuracy = Math.round((correctAnswers / totalAttempts) * 100);
      const now = new Date();
      let dd = now.getDate();
      let mm = now.getMonth() + 1;
      dd = dd < 10 ? "0" + dd : dd;
      mm = mm < 10 ? "0" + mm : mm;
      const dateStr = dd + "." + mm;
      const scoreObj = { date: dateStr, accuracy: accuracy, duration: durationStr, seconds: secondsTotal, mode: randomMode ? "random" : selectedMode };
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      highScores.push(scoreObj);
      highScores.sort((a, b) => (b.accuracy !== a.accuracy ? b.accuracy - a.accuracy : a.seconds - b.seconds));
      highScores = highScores.slice(0, 5);
      localStorage.setItem("highScores", JSON.stringify(highScores));
      scoreRecorded = true;
    };
    const updateScoreboard = () => {
      const allScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const filtered = allScores.filter(score => score.mode === (randomMode ? "random" : selectedMode));
      let html = "HIGHSCORES (" + (randomMode ? "random" : selectedMode) + ")\n";
      filtered.forEach((score, index) => {
        html += (index + 1) + ". " + score.date + " \t " + score.accuracy + "% " + score.duration + "\n";
      });
      document.getElementById("scoreboardOverlay").textContent = html;
    };
    const toggleScoreboard = () => {
      const overlay = document.getElementById("scoreboardOverlay");
      overlay.classList.toggle("hidden");
      if (!overlay.classList.contains("hidden")) updateScoreboard();
    };
    const autoSelectMode = () => {
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const leftScores = highScores.filter(score => score.mode === "left");
      const rightScores = highScores.filter(score => score.mode === "right");
      const bestLeft = leftScores.length ? Math.max(...leftScores.map(s => s.accuracy)) : 0;
      const bestRight = rightScores.length ? Math.max(...rightScores.map(s => s.accuracy)) : 0;
      if (bestLeft < bestRight) {
        selectedMode = "left";
        currentHandIndex = 0;
      } else {
        selectedMode = "left";
        currentHandIndex = 0;
      }
      const handToggle = document.getElementById("handToggle");
      if (handToggle) {
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      }
    };
    const cycleRange = () => {
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
      updateHeartsDisplay();
    };
    const toggleDarkMode = () => {
      document.body.classList.toggle("dark-mode");
    };
    // Passive Listener f√ºr Touch-Events in setupFadeOnHover
    const setupFadeOnHover = (element) => {
      element.addEventListener("mouseenter", () => element.classList.remove("faded"));
      element.addEventListener("mouseleave", () => element.classList.add("faded"));
      element.addEventListener("touchstart", () => element.classList.remove("faded"), {passive: true});
      element.addEventListener("touchend", () => element.classList.add("faded"), {passive: true});
    };
    let redrawQueued = false;
    const queueRedraw = () => {
      if (!redrawQueued) {
        redrawQueued = true;
        requestAnimationFrame(() => {
          drawSeries();
          redrawQueued = false;
        });
      }
    };
    /* Animation (Hintergrund-Kreise) */
    let circles = [];
    const gradients = {
      "green": ["rgba(0,255,0,1)", "rgba(0,255,0,0.3)", "rgba(255,255,255,0)"],
      "blue": ["rgba(0,0,255,1)", "rgba(0,0,255,0.3)", "rgba(255,255,255,0)"],
      "pink": ["rgba(255,105,180,1)", "rgba(255,105,180,0.3)", "rgba(255,255,255,0)"],
      "yellow": ["rgba(255,255,0,1)", "rgba(255,255,0,0.3)", "rgba(255,255,255,0)"],
      "red": ["rgba(255,0,0,1)", "rgba(255,0,0,0.3)", "rgba(255,255,255,0)"],
      "violet": ["rgba(238,130,238,1)", "rgba(238,130,238,0.3)", "rgba(255,255,255,0)"],
      "gray": ["rgba(128,128,128,1)", "rgba(128,128,128,0.3)", "rgba(255,255,255,0)"],
      "black": ["rgba(0,0,0,1)", "rgba(0,0,0,0.3)", "rgba(255,255,255,0)"]
    };
    const positiveColors = ["green", "blue", "pink", "yellow"];
    const negativeColors = ["orange", "violet", "crimson"];
    function addCircle(type) {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = type === "positive" ? positiveColors : negativeColors;
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
    }
    /* Intro-Animation */
    function spawnIntroBlobs() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const positions = [
        { x: cw - 500, y: 100 },
        { x: cw - 30, y: ch - 30 },
        { x: 50, y: ch / 2 }
      ];
      const colors = ["yellow", "pink", "blue"];
      positions.forEach((pos, index) => {
        const targetRadius = Math.random() * 1000 + 1000;
        const duration = 5000;
        circles.push({
          x: pos.x,
          y: pos.y,
          initialRadius: targetRadius,
          radius: targetRadius,
          color: colors[index % colors.length],
          creationTime: Date.now(),
          duration: duration
        });
      });
    }
    function animateCircles() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const now = Date.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      circles = circles.filter(circle => {
        const t = now - circle.creationTime;
        if (t >= circle.duration) return false;
        let opacity = 0;
        if (t < 500) { opacity = t / 500; }
        else if (t < 1500) { opacity = 1; }
        else { opacity = (circle.duration - t) / 500; }
        let currentRadius = circle.radius;
        const gradColors = gradients[circle.color] || [circle.color, circle.color, "rgba(255,255,255,0)"];
        const grad = ctx.createRadialGradient(circle.x, circle.y, 0, circle.x, circle.y, currentRadius);
        grad.addColorStop(0, gradColors[0]);
        grad.addColorStop(0.7, gradColors[1]);
        grad.addColorStop(1, gradColors[2]);
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, currentRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 1;
        return true;
      });
      requestAnimationFrame(animateCircles);
    }
    function resetInactivityTimer() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(spawnInactivityBlob, 180000);
    }
    function spawnInactivityBlob() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = ["green", "blue", "pink", "yellow"];
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
      resetInactivityTimer();
    }
    document.addEventListener("DOMContentLoaded", () => {
      let canvas = document.getElementById("animationCanvas");
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = "animationCanvas";
        document.body.appendChild(canvas);
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      animateCircles();
      resetInactivityTimer();
      spawnIntroBlobs();
      const now = new Date();
      const hour = now.getHours();
      let greeting;
      if (hour >= 6 && hour < 12) {
        greeting = "Guten Morgen!";
      } else if (hour >= 12 && hour < 17) {
        greeting = "Guten Tag!";
      } else {
        greeting = "Guten Abend!";
      }
      document.getElementById("welcomeMessage").innerHTML = greeting + "<br>Sch√∂n, dass du da bist!";
      setTimeout(proceedToMainScreen, 5000);
      
      const settingsPanel = document.getElementById("settingsPanel");
      // Handtoggle
      const handToggle = document.createElement("span");
      handToggle.id = "handToggle";
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      settingsPanel.appendChild(handToggle);
      handToggle.addEventListener("click", () => {
        if (!randomMode) {
          currentHandIndex = (currentHandIndex + 1) % handOptions.length;
          selectedMode = handOptions[currentHandIndex].mode;
          handToggle.textContent = handOptions[currentHandIndex].symbol;
          handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
          generateSeries();
        }
      });
      // Randomtoggle
      const randomToggle = document.createElement("span");
      randomToggle.id = "randomToggle";
      randomToggle.textContent = "üêá";
      settingsPanel.appendChild(randomToggle);
      randomToggle.addEventListener("click", () => {
        randomMode = !randomMode;
        randomToggle.style.opacity = randomMode ? "1" : "0.5";
        generateSeries();
      });
      
      
      // Pausen-Button
      function blinkGreenBackground() {
        // Urspr√ºngliche Hintergrundfarbe speichern (falls gesetzt, sonst Standardwert)
        const originalBg = document.body.style.backgroundColor || "";
        // Setze den Hintergrund auf den bekannten Gr√ºnton
        document.body.style.backgroundColor = "LightBlue"; // hier den gew√ºnschten Gr√ºnton anpassen
        // Nach 300 Millisekunden wieder zur√ºcksetzen
        setTimeout(function() {
          document.body.style.backgroundColor = originalBg;
        }, 300);
      }
      
      pauseButton.addEventListener("click", () => {
        if (!sessionPaused) {
          saveStatistics();
          saveButtonEffect();
          console.log("Statistiken gespeichert und gr√ºner Farbtupfer ausgel√∂st.");
        }
      });
      
      
      
      // Metronom-Toggle
      const metronomeToggle = document.createElement("span");
      metronomeToggle.id = "metronomeToggle";
      metronomeToggle.textContent = "‚è≤Ô∏è";
      metronomeToggle.style.opacity = "0.5"; // an/off Anzeige: 0.5 = aus, 1 = an
      settingsPanel.appendChild(metronomeToggle);
metronomeToggle.addEventListener("click", () => {
  if (metronomeOn) {
    stopMetronome();
    metronomeOn = false;
    metronomeToggle.style.opacity = "0.5";
  } else {
    let existingInput = document.getElementById("bpmInput");
    if (!existingInput) {
      let input = document.createElement("input");
      input.id = "bpmInput";
      input.type = "number";
      input.min = "1";
      input.placeholder = metronomeBPM > 0 ? metronomeBPM : "";
      input.style.backgroundColor = "white";
      input.style.border = "1px solid #000";
      input.style.width = "60px";
      input.style.fontSize = "1em";
      input.style.borderRadius = "5px";
      input.style.outline = "none";
      input.style.marginLeft = "5px";

      metronomeToggle.parentElement.appendChild(input);
      input.focus();

      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const bpm = Number(input.value);
          if (bpm > 0) {
            metronomeBPM = bpm;
            metronomeInterval = 60000 / bpm;
            startMetronome();
            metronomeToggle.style.opacity = "1";
            metronomeOn = true;
          }
          input.remove();
        }
      });

      input.addEventListener("blur", () => {
        input.remove();
      });
    }
  }
});


      const customModeToggle = document.createElement("span");
      customModeToggle.id = "customModeToggle";
      customModeToggle.textContent = "üñçÔ∏è";
      customModeToggle.style.cursor = "pointer";
      customModeToggle.style.marginTop = "10px";
      settingsPanel.appendChild(customModeToggle);
      customModeToggle.addEventListener("click", () => {
        document.getElementById("customModeModal").classList.remove("hidden");
      });
      
document.getElementById("timerContainer").addEventListener("click", () => {
  let existingInput = document.getElementById("counterInput");
  if (!existingInput) {
    let timerContainer = document.getElementById("timerContainer");
    let input = document.createElement("input");
    input.id = "counterInput";
    input.type = "number";
    input.min = "1";
    input.placeholder = sessionCounter;
    input.value = sessionCounter;
    input.style.backgroundColor = "white";
    input.style.border = "1px solid #000";
      input.style.width = "150px";
      input.style.fontSize = "2em";
    input.style.textAlign = "center";
    input.style.borderRadius = "5px";
    input.style.outline = "none";

    timerContainer.innerHTML = "";
    timerContainer.appendChild(input);
    input.focus();

    let confirmed = false;

    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        confirmed = true;
        const num = parseInt(input.value, 10);
        if (!isNaN(num) && num > 0) {
          sessionCounter = num;
          updateTimer();
          if (sessionCounter === 0 && !sessionPaused) {
            startPauseCountdown();
          }
        }
        timerContainer.innerHTML = sessionCounter;
      }
    });

    input.addEventListener("blur", () => {
      if (!confirmed) {
        input.focus(); // Bleibe im Feld, bis best√§tigt
      }
    });
  }
});
      
      // DarkMode-Toggle
      const darkModeToggle = document.createElement("span");
      darkModeToggle.id = "darkModeToggle";
      darkModeToggle.textContent = "üåô";
      settingsPanel.appendChild(darkModeToggle);
      darkModeToggle.addEventListener("click", toggleDarkMode);
      // Scoreboard-Toggle
      
      autoSelectMode();
      generateSeries();
      const storedID = localStorage.getItem("storedUserID");
      if (storedID) {
        userID = storedID;
        document.getElementById("userIDInput").value = userID;
        document.getElementById("userIDIcon").textContent = "üîí";
        document.getElementById("createNewID").style.display = "none";
      }
      
      document.getElementById("createNewID").addEventListener("click", async () => {
        let exists = true, newID;
        while (exists) {
          newID = Math.floor(1000 + Math.random() * 9000).toString(); // vierstellige Zufallszahl
          const r = await fetch(`${SHEET_BASE}/search?user=${newID}`);
          const data = await r.json();
          exists = data.length > 0;
        }

        await fetch(SHEET_BASE, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ data: [{ user: newID, quote: 0, speed: 0 }] })
        });

        userID = newID;
        localStorage.setItem("storedUserID", newID);
        document.getElementById("userIDInput").value = newID;
        document.getElementById("userIDIcon").textContent = "üîí";
        document.getElementById("createNewID").style.display = "none";
        document.getElementById("userIDStatus").textContent = "Gespeichert.";
      });
      
      updateHeartsDisplay();
      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") { handleMIDIMessage(144, 60, 127); }
      });
      document.getElementById("scoreboardOverlay").addEventListener("click", toggleScoreboard);
      
      document.getElementById("userIDIcon").addEventListener("click", () => {
        if (document.getElementById("userIDIcon").textContent === "üîí") {
          localStorage.removeItem("storedUserID");
          document.getElementById("userIDInput").value = "";
          document.getElementById("userIDInput").focus();
          document.getElementById("userIDIcon").textContent = "üñçÔ∏è";
          document.getElementById("createNewID").style.display = "inline";
          document.getElementById("userIDStatus").textContent = "";
        }
      });
    });
                  
let melodyContext = {
  lastNote: null,
  direction: 1, // 1 = aufw√§rts, -1 = abw√§rts
  scale: ["c", "d", "e", "f", "g", "a", "b"], // C-Dur
};
// F√ºge am Anfang des Skripts (z.‚ÄØB. direkt vor der Funktion generateSeries) hinzu:
let notesInCurrentPhase = 0;
function generateNextMelodicNote(notesPool) {
  const scale = melodyContext.scale;
  const lastNote = melodyContext.lastNote;
  const direction = melodyContext.direction;

  if (!lastNote) {
    const randIndex = Math.floor(Math.random() * notesPool.length);
    const chosen = notesPool[randIndex];
    melodyContext.lastNote = chosen;
    return chosen;
  }

  const idx = scale.indexOf(lastNote);
  let nextIdx = idx + direction;

  if (nextIdx >= scale.length || nextIdx < 0) {
    melodyContext.direction *= -1;
    nextIdx = idx + melodyContext.direction;
    if (nextIdx < 0 || nextIdx >= scale.length) {
      nextIdx = idx;
    }
  }

  const nextNote = scale[nextIdx];
  melodyContext.lastNote = nextNote;
  return nextNote;
}
                                            
const generateSeries = () => {
  seriesCounter = 0;
  correctNoteCount = 0;
  nextMotivationThreshold = getRandomThreshold();
  document.getElementById("noteNameDisplay").textContent = "";

  let seriesClef, chooseNote;

  // Pr√ºfe, ob benutzerdefinierte Einstellungen aktiv sind
  if (window.customModeSettings && window.customModeSettings.clef && window.customModeSettings.range) {
    // Verwende die benutzerdefinierten Einstellungen
    seriesClef = window.customModeSettings.clef; // z.B. 'treble' oder 'bass'
    currentRange = window.customModeSettings.range; // Aktualisiere die globale Lage
    // W√§hle die Noten basierend auf der ausgew√§hlten Hand (left/right)
    let customNotes = (selectedMode === "left") ? window.customModeSettings.leftNotes : window.customModeSettings.rightNotes;
    // Fallback, falls keine Noten ausgew√§hlt wurden
    if (!customNotes || customNotes.length === 0) {
      if (currentRange === "MC") {
        customNotes = seriesClef === "bass" ? ["f", "g", "a", "b", "c"] : ["c", "d", "e", "f", "g"];
      } else if (currentRange === "D") {
        customNotes = ["d", "e", "f#", "g", "a"];
      } else {
        customNotes = rangeNotes[currentRange];
      }
    }
    
    chooseNote = () => {
      if (errorNotes.length > 0 && Math.random() < 0.6) {
        const idx = errorNotes.findIndex(note => note.clef === seriesClef);
        if (idx !== -1) {
          return errorNotes.splice(idx, 1)[0];
        }
      }
      const randomIndex = Math.floor(Math.random() * customNotes.length);
      const chosenNote = customNotes[randomIndex];
      let noteOctave;
      if (currentRange === "MC") {
        noteOctave = seriesClef === "bass" ? (chosenNote === "c" ? 4 : 3) : 4;
      } else {
        noteOctave = seriesClef === "bass" ? 3 : 4;
      }
      let accidental = undefined;
      if (["F", "G"].includes(currentRange)) {
        if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
          accidental = chosenNote;
        } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
          accidental = chosenNote;
        }
      }
      return { note: chosenNote, octave: noteOctave, clef: seriesClef, color: "black", accidental: accidental };
    };

  } else {
    // Bestehendes Verhalten, wenn kein Custom Mode aktiv ist
    if (randomMode) {
      seriesClef = Math.random() < 0.5 ? "bass" : "treble";
      notesInCurrentPhase += seriesLength;
      if (notesInCurrentPhase >= 20) {
        let oldRange = currentRange;
        if (typeof alternatingRanges !== 'undefined' && alternatingRanges.length > 0) {
          currentRange = alternatingRanges[Math.floor(Math.random() * alternatingRanges.length)];
        }
        if (oldRange !== currentRange) {
          gongSound.currentTime = 0;
          gongSound.play();
          var clefTitle = document.getElementById("clefTitle");
          clefTitle.textContent = currentRange + "-Lage";
          clefTitle.style.border = "3px solid red";
          setTimeout(() => {
            if (document.body.classList.contains("dark-mode")) {
              clefTitle.style.border = "3px solid #fff";
            } else {
              clefTitle.style.border = "3px solid #000";
            }
          }, 300);
        }
        notesInCurrentPhase = 0;
      }
    } else {
      seriesClef = (selectedMode === "left") ? "bass" : "treble";
    }

    chooseNote = () => {
      if (errorNotes.length > 0 && Math.random() < 0.6) {
        const idx = errorNotes.findIndex(note => note.clef === seriesClef);
        if (idx !== -1) {
          return errorNotes.splice(idx, 1)[0];
        }
      }
      let defaultNotes;
      if (currentRange === "MC") {
        defaultNotes = seriesClef === "bass" ? ["f", "g", "a", "b", "c"] : ["c", "d", "e", "f", "g"];
      } else if (currentRange === "D") {
        defaultNotes = ["d", "e", "f#", "g", "a"];
      } else {
        defaultNotes = rangeNotes[currentRange];
      }
      const chosenNote = generateNextMelodicNote(defaultNotes);
      let noteOctave;
      if (currentRange === "MC") {
        noteOctave = seriesClef === "bass" ? (chosenNote === "c" ? 4 : 3) : 4;
      } else {
        noteOctave = seriesClef === "bass" ? 3 : 4;
      }
      let accidental = undefined;
      if (["F", "G"].includes(currentRange)) {
        if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
          accidental = chosenNote;
        } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
          accidental = chosenNote;
        }
      }
      return { note: chosenNote, octave: noteOctave, clef: seriesClef, color: "black", accidental: accidental };
    };
  }

  currentSeriesSingle = [];
  for (let i = 0; i < seriesLength; i++) {
    currentSeriesSingle.push(chooseNote());
  }
  drawSeries();
};
                                            
const drawSeries = () => {
  const notationDiv = document.getElementById("notation");
  const baseWidth = 600;
  const ratio = window.devicePixelRatio || 1;
  const height = 300 * ratio;
  notationDiv.style.display = "block";
  notationDiv.innerHTML = "";
  
  // Erzeuge den Renderer und passe Gr√∂√üe an
  const renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
  const zoomFactor = 1.4; // Zoom-Faktor anpassen
  renderer.resize(baseWidth * ratio * zoomFactor, height * zoomFactor);
  const svg = notationDiv.querySelector("svg");
  if (svg) {
    svg.setAttribute("width", baseWidth * zoomFactor);
    svg.setAttribute("height", 100 * zoomFactor);
    svg.style.transform = `scale(${zoomFactor})`;
    svg.style.transformOrigin = "top left";
  }
  const context = renderer.getContext();
  
  // Erzeuge den Stave
  const stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
  if (currentSeriesSingle.length) {
    stave.addClef(currentSeriesSingle[0].clef);
  }
  
  // F√ºge Key Signature (Vorzeichen) hinzu, je nach aktueller Lage
  if (currentRange === "D") {
    stave.addKeySignature("G");
  } else if (currentRange === "F") {
    stave.addKeySignature("F");
  } else if (currentRange === "G") {
    stave.addKeySignature("G");
  }
  
  stave.setContext(context).draw();
  
  // Definiere noteDuration aus den benutzerdefinierten Einstellungen (Standard: "q")
  const noteDuration = (window.customModeSettings && window.customModeSettings.noteValue) || "q";
  
  // Erzeuge die StaveNotes f√ºr die Serie (Notennamen bleiben unver√§ndert, da die Vorzeichen √ºber die Key Signature definiert werden)
  const noteOrder = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"];
  const staveNotes = currentSeriesSingle.map(item => {
    let noteName = item.note.toLowerCase();
    // Falls wir nicht in den speziellen Lagen arbeiten, ersetze Unicode-Vorzeichen durch ASCII
    if (!("D,F,G".includes(currentRange))) {
      noteName = noteName.replace(/‚ôØ/g, "#").replace(/‚ô≠/g, "b");
    }
    const key = noteName + "/" + item.octave;
    const staveNote = new Vex.Flow.StaveNote({
      clef: item.clef,
      keys: [key],
      duration: noteDuration
    });
    staveNote.setStyle({ fillStyle: item.color, strokeStyle: item.color });
  
    const noteIndex = noteOrder.indexOf(noteName);
    const midiNumber = (item.octave + 1) * 12 + noteIndex;
    let threshold;
    if (item.clef === "treble") {
      threshold = 71;
    } else if (item.clef === "bass") {
      threshold = 50;
    } else {
      threshold = 71;
    }
    if (midiNumber >= threshold) {
      staveNote.setStemDirection(-1);
    } else {
      staveNote.setStemDirection(1);
    }
  
    return staveNote;
  });
  
  // Erstelle den Voice und erlaube unvollst√§ndige Stimmen
  const voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
  voice.setStrict(false);
  staveNotes.forEach(note => voice.addTickable(note));
  new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
  voice.draw(context, stave);
  
  // Dreieck-Indikator f√ºr die aktuell abgefragte Note
  if (seriesCounter < staveNotes.length) {
    const activeNote = staveNotes[seriesCounter];
    if (activeNote && typeof activeNote.getBoundingBox === 'function') {
      const bbox = activeNote.getBoundingBox();
      if (bbox) {
        // Berechne die Mitte der Note
        const noteX = bbox.getX() + bbox.getW() / 2;
        const triangleHeight = 5;
        // Positioniere das Dreieck oberhalb des Notensystems mit ca. 20px Abstand
        const noteY = stave.getY() - 1 - triangleHeight;
        const triangleWidth = 10;
        const p1 = `${noteX - triangleWidth / 2},${noteY}`;
        const p2 = `${noteX + triangleWidth / 2},${noteY}`;
        const p3 = `${noteX},${noteY + triangleHeight}`;
        const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        triangle.setAttribute('points', `${p1} ${p2} ${p3}`);
        triangle.setAttribute('fill', 'black');
        svg.appendChild(triangle);
      }
    }
  }
  
  // Falls Achtelnoten gew√§hlt wurden, erzeugen wir Beams
  if (noteDuration === "8") {
    const beams = Vex.Flow.Beam.generateBeams(staveNotes);
    beams.forEach(beam => beam.setContext(context).draw());
  }
};
    
    const isNoteCorrect = (midiInfo) => {
      const expected = currentSeriesSingle[seriesCounter];
      if (!expected) return false;
      const playedNote = midiInfo.note.toLowerCase();
      const expectedNote = expected.note.toLowerCase();
      return playedNote === expectedNote && midiInfo.octave === expected.octave;
    };
    const removeFromErrorNotes = (noteObj) => {
      errorNotes = errorNotes.filter(n => !(n.note === noteObj.note && n.octave === noteObj.octave && n.clef === noteObj.clef));
    };
    const handleMIDIMessage = (status, data1, data2) => {
      if (sessionPaused) return;
      resetInactivityTimer();
      if ((status & 0xf0) === 0x90 && data2 > 0) {
        if (seriesCounter >= currentSeriesSingle.length) return;
        let currentTime = Date.now();
        let responseTime = currentTime - lastNoteTimestamp;
        responseTimes.push(responseTime);
        lastNoteTimestamp = currentTime;
        const midiInfo = (() => {
          const noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
          const octave = Math.floor(data1 / 12) - 1;
          return { note: noteNames[data1 % 12], octave: octave };
        })();
        const playedNoteDisplay = (midiInfo.note === "b" ? "h" : midiInfo.note) + midiInfo.octave;
        const noteDisplay = document.getElementById("noteNameDisplay");
        totalAttempts++;
        
        if (isNoteCorrect(midiInfo)) {
          // Standardfarbe f√ºr korrekte Noten: gr√ºn
          let displayColor = "green";
          if (metronomeOn) {
            const currentTime = Date.now();
            const actualInterval = currentTime - lastTickTime;
            const tolerance = metronomeInterval * 0.3;
            // Wenn zu schnell oder zu langsam gespielt wird, setze die Farbe auf gelb und zeige entsprechende Motivation
            if (actualInterval < metronomeInterval - tolerance) {
              displayColor = "orange";
              showMotivation("Zu schnell! Langsamer spielen.");
            } else if (actualInterval > metronomeInterval + tolerance) {
              displayColor = "orange";
              showMotivation("Zu langsam! Schneller spielen.");
            } else {
              clearMotivation();
              showMotivation("Super! Weiter so!");
            }
          } else {
            // Ohne Metronom: explizit gr√ºn
            clearMotivation();
            showMotivation("Super! Weiter so!");
            displayColor = "green";
          }
          // Setze die Farbe im Noten-Objekt, damit sie auch beim Zeichnen verwendet wird
          currentSeriesSingle[seriesCounter].color = displayColor;
          
          correctAnswers++;
          correctNoteCount++;
          removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
          sessionCounter--;
          addCircle("positive");
          if (noteDisplay) {
            noteDisplay.innerHTML = '<span style="color:' + displayColor + ';">' + playedNoteDisplay + '</span>';
          }
          if (sessionCounter <= 0 && !sessionPaused) {
            sessionCounter = 0;
            updateTimer();
            startPauseCountdown();
            return;
          }
        } else {
          // Falsche Note: rot markieren
          currentSeriesSingle[seriesCounter].color = "red";
          errorNotes.push(currentSeriesSingle[seriesCounter]);
          addCircle("negative");
          if (noteDisplay) {
            const correctRaw = currentSeriesSingle[seriesCounter].note;
            const correctDisplay = (correctRaw === "b" ? "h" : correctRaw) + currentSeriesSingle[seriesCounter].octave;
            noteDisplay.innerHTML = '<span style="color:red;">' + playedNoteDisplay + '</span> <span style="color:green;">' + correctDisplay + '</span>';
          }
          if (!unlimitedLives) {
            hearts--;
            updateHeartsDisplay();
            if (hearts <= 0) { endGame(); return; }
          }
        }
        
        seriesCounter++;
        if (seriesCounter >= seriesLength) {
          generateSeries();
        } else {
          queueRedraw();
        }
        updateTimer();
      }
    };
      const resetGame = () => {
        sessionCounter = 1000;      // Counter auf 1000
        totalAttempts = 0;          // Z√§hler f√ºr gespielte Noten auf 0
        elapsedTimer = 0;           // Timer auf 0
        gameOver = false;
        seriesCounter = 0;
        correctAnswers = 0;
        correctNoteCount = 0;
        nextMotivationThreshold = getRandomThreshold();
        sessionPaused = false;
        confettiShown = false;
        errorNotes = [];
        document.getElementById("pauseOverlay").style.display = "none";
        scoreRecorded = false;
        // Setze den Timer-Container (falls genutzt) auf 0
        document.getElementById("timerContainer").textContent = "0";
        generateSeries();
        updateHeartsDisplay();
      };
                                            

  // Funktion, die den Hintergrund f√ºr kurze Zeit gr√ºn f√§rbt und danach wieder zur√ºcksetzt
  
  function checkOrientation() {
    const settingsPanel = document.getElementById("settingsPanel");
    if (!settingsPanel) return; // Falls das Element nicht existiert, beende die Funktion
    if (window.innerWidth > window.innerHeight) {
         // Querformat (Landscape): Men√º rechts, horizontal ausgerichtet
         settingsPanel.style.top = "29%";
         settingsPanel.style.right = "20px";
         settingsPanel.style.left = "";
         settingsPanel.style.transform = "";
         settingsPanel.style.flexDirection = "row";
    } else {
         // Hochformat (Portrait): Men√º oben mittig, vertikal ausgerichtet
         settingsPanel.style.top = "10px";
         settingsPanel.style.left = "50%";
         settingsPanel.style.right = "";
         settingsPanel.style.transform = "translateX(-50%)";
         settingsPanel.style.flexDirection = "column";
    }
}
  window.addEventListener("resize", checkOrientation);
  checkOrientation();
  
  </script>
<script>
  // Initialisiere MIDI-Zugriff (Web MIDI API)
  function initMIDIAccess() {
    if (!navigator.requestMIDIAccess) {
      console.warn("Web MIDI API wird nicht unterst√ºtzt.");
      return;
    }

    navigator.requestMIDIAccess({ sysex: false }).then((midiAccess) => {
      console.log("‚úÖ MIDI Access erfolgreich.");
      midiAccess.inputs.forEach((input) => {
        console.log("üéπ Eingabeger√§t erkannt:", input.name);
        input.onmidimessage = ({ data }) => {
          const [status, data1, data2] = data;
          handleMIDIMessage(status, data1, data2);
        };
      });

      midiAccess.onstatechange = (event) => {
        const port = event.port;
        if (port.type === "input" && port.state === "connected") {
          console.log("üîå Neues Ger√§t verbunden:", port.name);
          port.onmidimessage = ({ data }) => {
            const [status, data1, data2] = data;
            handleMIDIMessage(status, data1, data2);
          };
        }
      };
    }).catch((err) => {
      console.error("‚ùå MIDI Zugriff fehlgeschlagen:", err);
    });
  }

  document.addEventListener("DOMContentLoaded", initMIDIAccess);
  
  function onMIDISuccess(midiAccess) {
    // Alle vorhandenen MIDI-Eing√§nge initialisieren
    midiAccess.inputs.forEach((input) => {
      input.onmidimessage = (msg) => {
        const [status, data1, data2] = msg.data;
        handleMIDIMessage(status, data1, data2);
      };
    });
    // Auf √Ñnderungen (z.‚ÄØB. Ger√§te an- oder abstecken) reagieren
    midiAccess.onstatechange = (event) => {
      const port = event.port;
      console.log("MIDI-Ger√§testatus hat sich ge√§ndert:", port.name, port.state);
      if (port.state === "connected" && port.type === "input") {
        port.onmidimessage = (msg) => {
          const [status, data1, data2] = msg.data;
          handleMIDIMessage(status, data1, data2);
        };
      }
    };
  }
  
  function onMIDIFailure(error) {
    console.error("Zugriff auf MIDI-Ger√§te fehlgeschlagen:", error);
  }
  
  document.addEventListener("DOMContentLoaded", function() {
    initMIDIAccess();
  });
  </script>
<script>
  // Versuche, Web Bluetooth zu initialisieren, falls verf√ºgbar und Web MIDI nicht unterst√ºtzt wird
  
</script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    console.log("--- Schnittstellen-√úberpr√ºfung ---");
    console.log("Web MIDI API: " + (navigator.requestMIDIAccess ? "verf√ºgbar" : "nicht verf√ºgbar"));
    console.log("Web Bluetooth API: " + (navigator.bluetooth ? "verf√ºgbar" : "nicht verf√ºgbar"));
    // Optional: Weitere Schnittstellen k√∂nnen hier hinzugef√ºgt werden
    console.log("Custom Prompt (window.webkit.messageHandlers.customPrompt): " + (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt ? "verf√ºgbar" : "nicht verf√ºgbar"));
    console.log("---------------------------------");
  });
</script>
</head>
<body>
    <div id="streakDisplay"></div>
    <!-- Canvas f√ºr Animation (Hintergrund) -->
    <canvas id="animationCanvas"></canvas>
    <!-- Audio-Element -->
    <audio id="backgroundSound" autoplay>
        <source src="https://raw.githubusercontent.com/JP0024/piano.github.io/3d35e0a8d4eb3e018151018e36e225dc7a856ecd/mixkit-relaxing-harp-sweep-2628.wav" type="audio/wav">
            Dein Browser unterst√ºtzt das Audio-Element nicht.
    </audio>
    <!-- Pause-Overlay -->
    <div id="pauseOverlay">
        <div id="pauseInfo">
            <div id="pauseHeader">SESSION PAUSIERT</div>
            <div id="pauseProgressContainer">
                <div id="pauseProgress"></div>
                <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
            </div>
        </div>
        <!-- Kachelwand -->
        <div id="pauseTiles"></div>
    </div>
    <!-- Welcome Overlay -->
    <div id="welcomeOverlay">
        <div id="welcomeMessage"><br>Sch√∂n, dass du da bist!<br></div>
    </div>
    <!-- Game Over Overlay -->
    <div id="gameOverOverlay"></div>
    <!-- Scoreboard Overlay -->
    <div id="scoreboardOverlay" class="hidden"></div>
    <!-- Motivationsfenster -->
    <div id="motivationOverlay"></div>
    <!-- Timer Container -->
    <div id="timerContainer"></div>
    <!-- Hauptinhalt -->
    <div id="settingsPanel" style="position: fixed; top: 20%; right: 10px; background: rgba(255,255,255,0.8); padding: 10px; border: 1px solid #000; z-index: 200;"></div>
    <div id="mainContent">
        <div id="userIDInputContainer" style="position: fixed; top: 30px; left: 10px; z-index: 200; display: flex; flex-direction: row; align-items: center; gap: 10px;">
            <span id="userIDIcon" style="font-size: 1em;">üñçÔ∏è</span>
            <input id="userIDInput" type="text" placeholder="ID"
                style="font-size: 1em; padding: 4px; width: 50px; height: 20px; text-align: center; border: none; background: none; outline: none; color: black;">
                <span id="createNewID" style="cursor:pointer; color:blue; text-decoration:underline; font-size:0.9em;">Neue ID erstellen</span>
                <div id="userIDStatus" style="margin-top:5px; font-size:0.9em; color:#000;"></div>
        </div>
        <div id="notation"></div>
        <div id="noteNameDisplay" style="position: fixed; left:50%; bottom:110px; transform: translateX(-50%); font-size:5em; text-transform: uppercase;"></div>
        <div id="buttonContainer">
            <div id="clefTitle" onclick="cycleRange()">C-Lage</div>
            <div id="heartsContainer" style="margin-left:10px;"></div>
        </div>
    </div>
    <!-- Einstellungen-Men√º -->
    
    <script>
        /* Falls im Pause-Modus: Aktualisiere Fortschrittsbalken und verbleibende Zeit (mm:ss) */
        function updatePauseProgress() {
            const progressBar = document.getElementById("pauseProgress");
            const timeDisplay = document.getElementById("pauseTime");
            if (progressBar && pauseDuration > 0) {
                const percent = ((pauseDuration - pauseRemaining) / pauseDuration) * 100;
                progressBar.style.width = percent + "%";
                if (timeDisplay) {
                    const m = Math.floor(pauseRemaining / 60);
                    const s = pauseRemaining % 60;
                    timeDisplay.textContent = (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
                }
            }
        }
        
    </script>
    
    <script>
        let deferredPrompt;
        // Abfangen des beforeinstallprompt-Events und automatisches Ausl√∂sen des Prompts
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('beforeinstallprompt Event empfangen');
            // Automatisch das Installations-Prompt ausl√∂sen
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the PWA install prompt');
                } else {
                    console.log('User dismissed the PWA install prompt');
                }
                deferredPrompt = null;
            });
        });
        
        // Falls die App installiert wurde, kann hier optional eine Logik implementiert werden
        window.addEventListener('appinstalled', () => {
            console.log('App wurde als PWA installiert');
        });
    </script>
    
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const settingsPanel = document.getElementById("settingsPanel");
            if (!settingsPanel) return;
            let fadeTimeout;
            const resetFadeTimer = () => {
                clearTimeout(fadeTimeout);
                // Setze sofort auf volle Opacity
                settingsPanel.style.opacity = "1";
                // Starte Timer: nach 10 Sekunden wird die Opacity auf 0.5 reduziert
                fadeTimeout = setTimeout(() => {
                    settingsPanel.style.opacity = "0.5";
                }, 10000);
            };
            // Initialer Timer-Start
            resetFadeTimer();
            // Bei Maus- oder Touch-Interaktion den Timer zur√ºcksetzen
            settingsPanel.addEventListener("mouseenter", resetFadeTimer);
            settingsPanel.addEventListener("touchstart", resetFadeTimer);
        });
        
        function getAllTrophies() {
            return [
                    "üê¢","üêå","üö∂‚Äç‚ôÇÔ∏è","üèÉ","‚ö°",
                    "üéº","üéπ","üé∫","ü™ï","ü™ó",
                    "üå±","üåø","üåª","üå≤","üéÑ","üî•","üöÄ","ü™ê","üåû","üëë",
                    "üîÄ","üåÄ","üîÅ","‚è©","‚öôÔ∏è",
                    "üìè","üìê","üß≠","üéØ","üèÅ"
                    ];
        }
        
        function showTrophyTransitionScreen(callback) {
            const overlay = document.getElementById("pauseOverlay");
            overlay.innerHTML = "";
            overlay.style.display = "flex";
            
            const trophyContainer = document.createElement("div");
            trophyContainer.style.display = "flex";
            trophyContainer.style.flexDirection = "column";
            trophyContainer.style.alignItems = "center";
            trophyContainer.style.justifyContent = "center";
            trophyContainer.style.opacity = "0";
            trophyContainer.style.transition = "opacity 1s";
            
            const newUnlocked = JSON.parse(sessionStorage.getItem("justUnlockedTrophies") || "[]");
            const justLost = JSON.parse(sessionStorage.getItem("justLostTrophies") || "[]");
            
            if (newUnlocked.length > 0) {
                const gainedTitle = document.createElement("h2");
                gainedTitle.textContent = isGerman ? "Neu freigeschaltet" : "Newly Unlocked";
                trophyContainer.appendChild(gainedTitle);
                
                newUnlocked.forEach(index => {
                    const emoji = getAllTrophies()[index];
                    const description = getTrophyDescription(index);
                    const block = document.createElement("div");
                    block.style.margin = "10px";
                    block.style.fontSize = "1.5em";
                    block.innerHTML = `<div>${emoji}</div><div style="font-size:0.8em">${description}</div>`;
                    trophyContainer.appendChild(block);
                });
            }
            
            if (justLost.length > 0) {
                const lostTitle = document.createElement("h2");
                lostTitle.textContent = isGerman ? "Verloren" : "Lost";
                trophyContainer.appendChild(lostTitle);
                
                justLost.forEach(index => {
                    const emoji = getAllTrophies()[index];
                    const description = getTrophyDescription(index);
                    const block = document.createElement("div");
                    block.style.margin = "10px";
                    block.style.opacity = "0.5";
                    block.style.fontSize = "1.5em";
                    block.innerHTML = `<div>${emoji}</div><div style="font-size:0.8em">${description}</div>`;
                    trophyContainer.appendChild(block);
                });
            }
            
            overlay.appendChild(trophyContainer);
            
            // Fade-in
            setTimeout(() => {
                trophyContainer.style.opacity = "1";
            }, 100);
            
            // Nach 3 Sekunden weiter zur Session-Pause
            setTimeout(() => {
                overlay.style.opacity = "0";
                setTimeout(() => {
                    overlay.style.display = "none";
                    overlay.style.opacity = "1";
                    callback();
                }, 1000);
            }, 3000);
        }
        
    </script>
    <script>
        document.getElementById("createNewID").addEventListener("click", async () => {
            let exists = true, newID;
            while (exists) {
                newID = Math.random().toString().slice(2, 6);
                const r = await fetch(`${SHEET_BASE}/search?user=${newID}`);
                const data = await r.json();
                exists = data.length > 0;
            }
            await fetch(SHEET_BASE, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ data: [{ user: newID, quote: 0, speed: 0 }] })
            });
            userID = newID;
            document.getElementById("createNewID").style.display = "none";
        });
        
        document.getElementById("userIDInput").addEventListener("keydown", async (e) => {
            if (e.key === "Enter") {
                const input = e.target.value.trim();
                if (input.length === 0) return;
                
                // √úberpr√ºfe die ID mit der API, aber nur wenn sie noch nicht gespeichert ist
                const response = await fetch(`${SHEET_BASE}/search?user=${input}`);
                const data = await response.json();
                if (data.length > 0) {
                    userID = input;
                    document.getElementById("userIDIcon").textContent = "üîí";
                    document.getElementById("createNewID").style.display = "none";
                    localStorage.setItem("storedUserID", userID);
                } else {
                    document.getElementById("userIDIcon").textContent = "‚ùå";
                }
            }
        });
        
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('customModeModal');
            if (!modal) return;
            
            let selectedCustomClef = null;
            let selectedCustomRange = null;
            
            // Eventlistener f√ºr Schl√ºsselauswahl
            document.querySelectorAll('.custom-mode-clef-option').forEach(el => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.custom-mode-clef-option').forEach(opt => opt.classList.remove('active'));
                    el.classList.add('active');
                    selectedCustomClef = el.getAttribute('data-clef');
                    populateCustomNotes();
                });
            });
            
            // Eventlistener f√ºr Lagen-Auswahl
            document.querySelectorAll('.custom-mode-range-option').forEach(el => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.custom-mode-range-option').forEach(opt => opt.classList.remove('active'));
                    el.classList.add('active');
                    selectedCustomRange = el.getAttribute('data-range');
                    populateCustomNotes();
                });
            });
            
            // Definition der Notenzuordnungen f√ºr linke und rechte Hand
            const customLeftNotesMapping = {
                "C": ["C", "D", "E", "F", "G", "A"],
                "D": ["D", "E", "F#", "G", "A", "B"],
                "F": ["F", "G", "A", "Bb", "C", "D"],
                "G": ["G", "A", "B", "C", "D", "E"],
                "MC": ["F", "G", "A", "H", "C"]
            };
            const customRightNotesMapping = {
                "C": ["C", "D", "E", "F", "G", "A"],
                "D": ["D", "E", "F#", "G", "A", "B"],
                "F": ["F", "G", "A", "Bb", "C", "D"],
                "G": ["G", "A", "B", "C", "D", "E"],
                "MC": ["F", "G", "A", "H", "C"]
            };
            
            // Funktion, die basierend auf der gew√§hlten Lage die Noten f√ºr linke und rechte Hand bef√ºllt
            function populateCustomNotes() {
                if (!selectedCustomRange) return;
                const leftContainer = document.getElementById('left-hand-notes');
                const rightContainer = document.getElementById('right-hand-notes');
                leftContainer.innerHTML = '';
                rightContainer.innerHTML = '';
                
                customLeftNotesMapping[selectedCustomRange].forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'custom-mode-note-option';
                    noteEl.textContent = note;
                    noteEl.setAttribute('data-note', note);
                    noteEl.addEventListener('click', () => {
                        noteEl.classList.toggle('active');
                    });
                    leftContainer.appendChild(noteEl);
                });
                
                customRightNotesMapping[selectedCustomRange].forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'custom-mode-note-option';
                    noteEl.textContent = note;
                    noteEl.setAttribute('data-note', note);
                    noteEl.addEventListener('click', () => {
                        noteEl.classList.toggle('active');
                    });
                    rightContainer.appendChild(noteEl);
                });
            }
            
            // Eventlistener f√ºr den Speichern-Button
            const saveButton = document.querySelector('.custom-mode-save button');
            if (saveButton) {
                saveButton.addEventListener('click', () => {
                    const activeClef = document.querySelector('.custom-mode-clef-option.active');
                    const activeRange = document.querySelector('.custom-mode-range-option.active');
                    const activeLeftNotes = document.querySelectorAll('#left-hand-notes .custom-mode-note-option.active');
                    const activeRightNotes = document.querySelectorAll('#right-hand-notes .custom-mode-note-option.active');
                    
                    const settings = {
                        clef: activeClef ? activeClef.getAttribute('data-clef') : null,
                        range: activeRange ? activeRange.getAttribute('data-range') : null,
                        leftNotes: Array.from(activeLeftNotes).map(el => el.getAttribute('data-note')),
                        rightNotes: Array.from(activeRightNotes).map(el => el.getAttribute('data-note'))
                    };
                    
                    console.log("Benutzerdefinierte Einstellungen:", settings);
                    window.customModeSettings = settings;
                    // Schlie√üe das Modal
                    modal.classList.add('hidden');
                });
            }
        });
    </script>
    
    <div id="customModeModal" class="hidden">
        <h2>Benutzerdefiniert</h2>
        <div class="custom-mode-row">
            <!-- Notenschl√ºssel & Lagen-Auswahl -->
            <div class="custom-mode-clef-container">
                <div class="custom-mode-clef-option" data-clef="treble">üéº</div>
                <div class="custom-mode-clef-option" data-clef="bass">ùÑ¢</div>
            </div>
            <div class="custom-mode-range-container">
                <div class="custom-mode-range-option" data-range="C">C</div>
                <div class="custom-mode-range-option" data-range="D">D</div>
                <div class="custom-mode-range-option" data-range="F">F</div>
                <div class="custom-mode-range-option" data-range="G">G</div>
                <div class="custom-mode-range-option" data-range="MC">MC</div>
            </div>
        </div>
        <div class="custom-mode-row">
            <div class="custom-mode-hand-label">Linke Hand</div>
            <div class="custom-mode-note-set" id="left-hand-notes">
                <!-- Noten werden dynamisch basierend auf der gew√§hlten Lage eingef√ºgt -->\n    </div>
        </div>
        <div class="custom-mode-row">
            <div class="custom-mode-hand-label">Rechte Hand</div>
            <div class="custom-mode-note-set" id="right-hand-notes">
                <!-- Noten werden dynamisch basierend auf der gew√§hlten Lage eingef√ºgt -->\n    </div>
        </div>
        <div class="custom-mode-row">
            <label for="noteValueCheckbox" style="font-weight: bold;">Wertvariation</label>
            <input type="checkbox" id="noteValueCheckbox" />
          </div>
        <div class="custom-mode-save">
            <button id="custom-mode-save-button">Speichern</button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('customModeModal');
            if (!modal) {
                console.error('Modal nicht gefunden.');
                return;
            }

            let selectedCustomClef = null;
            let selectedCustomRange = null;

            // Eventlistener f√ºr Schl√ºsselauswahl
            document.querySelectorAll('.custom-mode-clef-option').forEach(el => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.custom-mode-clef-option').forEach(opt => opt.classList.remove('active'));
                    el.classList.add('active');
                    selectedCustomClef = el.getAttribute('data-clef');
                    populateCustomNotes();
                });
            });

            // Eventlistener f√ºr Lagen-Auswahl
            document.querySelectorAll('.custom-mode-range-option').forEach(el => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.custom-mode-range-option').forEach(opt => opt.classList.remove('active'));
                    el.classList.add('active');
                    selectedCustomRange = el.getAttribute('data-range');
                    populateCustomNotes();
                });
            });

            // Notenzuordnungen f√ºr linke und rechte Hand
            const customLeftNotesMapping = {
                "C": ["C", "D", "E", "F", "G", "A"],
                "D": ["D", "E", "F#", "G", "A", "B"],
                "F": ["F", "G", "A", "Bb", "C", "D"],
                "G": ["G", "A", "B", "C", "D", "E"],
                "MC": ["F", "G", "A", "B", "C"]
            };
            const customRightNotesMapping = {
                "C": ["C", "D", "E", "F", "G", "A"],
                "D": ["D", "E", "F#", "G", "A", "B"],
                "F": ["F", "G", "A", "Bb", "C", "D"],
                "G": ["G", "A", "B", "C", "D", "E"],
                "MC": ["F", "G", "A", "B", "C"]
            };

            // Funktion, um basierend auf der ausgew√§hlten Lage die Noten f√ºr linke und rechte Hand zu bef√ºllen
            function populateCustomNotes() {
                if (!selectedCustomRange) return;
                const leftContainer = document.getElementById('left-hand-notes');
                const rightContainer = document.getElementById('right-hand-notes');
                if (!leftContainer || !rightContainer) {
                    console.error('Noten-Container nicht gefunden.');
                    return;
                }
                leftContainer.innerHTML = '';
                rightContainer.innerHTML = '';

                customLeftNotesMapping[selectedCustomRange].forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'custom-mode-note-option';
                    noteEl.textContent = note;
                    noteEl.setAttribute('data-note', note);
                    noteEl.addEventListener('click', () => {
                        noteEl.classList.toggle('active');
                    });
                    leftContainer.appendChild(noteEl);
                });

                customRightNotesMapping[selectedCustomRange].forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'custom-mode-note-option';
                    noteEl.textContent = note;
                    noteEl.setAttribute('data-note', note);
                    noteEl.addEventListener('click', () => {
                        noteEl.classList.toggle('active');
                    });
                    rightContainer.appendChild(noteEl);
                });
            }

            // Eventlistener f√ºr den Speichern-Button im Custom Mode Modal
            const saveButton = document.getElementById('custom-mode-save-button');
            if (saveButton) {
                saveButton.addEventListener('click', () => {
                    const activeClef = document.querySelector('.custom-mode-clef-option.active');
                    const activeRange = document.querySelector('.custom-mode-range-option.active');
                    const activeLeftNotes = document.querySelectorAll('#left-hand-notes .custom-mode-note-option.active');
                    const activeRightNotes = document.querySelectorAll('#right-hand-notes .custom-mode-note-option.active');
                    const noteValueCheckbox = document.getElementById('noteValueCheckbox');
                    const noteValue = noteValueCheckbox.checked ? "8" : "q";  // "8" f√ºr Achtelnoten, "q" als Standard (Viertelnoten)
                    
                    const settings = {
                        clef: activeClef ? activeClef.getAttribute('data-clef') : null,
                        range: activeRange ? activeRange.getAttribute('data-range') : null,
                        leftNotes: Array.from(activeLeftNotes).map(el => el.getAttribute('data-note')),
                        rightNotes: Array.from(activeRightNotes).map(el => el.getAttribute('data-note')),
                        noteValue: noteValue
                    };
                    
                    console.log("Benutzerdefinierte Einstellungen:", settings);
                    window.customModeSettings = settings;
                    modal.classList.add('hidden');
                    
                    // Aktualisiere den Lagen-Button (clefTitle)
                    const clefTitle = document.getElementById("clefTitle");
                    if (clefTitle && settings.range) {
                        clefTitle.textContent = settings.range + "-Lage";
                    }
                    
                    generateSeries();
                });
            } else {
                console.warn('Speichern-Button nicht gefunden.');
            }
        });
    </script>
    
</body>
</html>
