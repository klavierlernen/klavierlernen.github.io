<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Klavier</title>
  <!-- VexFlow laden -->
  <link rel="manifest" href="https://raw.githubusercontent.com/JP0024/piano.github.io/main/manifest.json">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="icon-192.png">
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
  <!-- canvas-confetti laden -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
      
      <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
      
  <style>
    /* Grundlayout */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #F8F8FF;
      font-family: "Inter", sans-serif;
      text-align: center;
      transition: background-color 0.3s, color 0.3s;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    body.dark-mode {
      background-color: #0A0A0A;
      color: #e0e0e0;
    }
    /* Vollbild-Canvas für Animation (Hintergrund) */
    #animationCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5; /* niedriger als Menüs */
      filter: blur(20px);
      opacity: 0.2;
      pointer-events: none;
    }
    /* Einhand-Notation (normaler Modus) */
    /* Absolute Mitte mit minimalen Rändern */
      #notation {
        display: none;              /* bleibt durch JS gesteuert */
        position: fixed;
        top: 85%;
        left: 65%;
        transform: translate(-50%, -50%);
        transform-origin: center center;
        width: auto;
        max-width: calc(100% - 10px); /* 5 px Rand links/rechts */
        padding: 0;
        margin: 0;
        box-sizing: border-box;
        z-index: 1;
      }

      @media screen and (max-width: 600px) {
        #notation {
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          max-width: 90%;   /* 5 % Rand mobil */
          padding: 0;
        }
      }
    #notation svg {
      width: 100%;
      height: auto;
      shape-rendering: crispEdges;
      display: block;
      margin: 0 auto;
    }
    #notation svg * {
      vector-effect: non-scaling-stroke;
    }
    body.dark-mode #notation svg * {
      stroke: #fff;
      fill: #fff;
    }
    /* Motivationsfenster */
    #motivationOverlay {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 15;
      pointer-events: none;
      opacity: 0;
      font-size: 2em;
      color: #000;
      text-shadow: none;
    }
    @keyframes floatFade {
      0% { transform: translate(-50%, -50%) translateY(20px); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { transform: translate(-50%, -50%) translateY(-20px); opacity: 0; }
    }
    .animate-motivation {
      animation: floatFade 2.5s ease-out forwards;
    }
    /* Pause-Overlay */
    #pauseOverlay {
      position: fixed;
      top: 15px;
      left: 0;
      width: 100%;
      height: 100%;
      background: #fff;
      z-index: 1000;
      display: none;
      flex-direction: column;
    }
    /* Obere Info-Leiste im Pausenmodus */
    #pauseInfo {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }
    #pauseHeader {
      font-size: 2em;
      font-weight: bold;
      color: #000;
      white-space: nowrap;
    }
    /* Fortschrittsbalken */
    #pauseProgressContainer {
      flex-grow: 1;
      height: 20px;
      border: 3px solid #000;
      border-radius: 20px;
      position: relative;
      background: #fff;
    }
    #pauseProgress {
      height: 100%;
      width: 0%;
      background: red;
      border-radius: 20px;
      transition: width 1s linear;
    }
    /* Verbleibende Zeit im Format mm:ss */
    #pauseTime {
      font-size: 14px;
      color: #000;
      white-space: nowrap;
      margin-left: 10px;
      font-weight: bold;
    }
    /* Kachelwand im Pausenmodus – Füllt den restlichen Raum wie eine Tapete */
    #pauseTiles {
      flex-grow: 1;
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      grid-auto-rows: 230px;
      gap: 12px;
      overflow-y: auto;
    }
    /* Variierende Kacheln (Mauerstein-Effekt) */
    .tile:nth-child(3n) {
      grid-row: span 2;
    }
    .tile:nth-child(4n) {
      grid-column: span 2;
    }
    .tile {
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 15px;
      font-size: 14px;
      color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }
    .tileIcon {
      font-size: 5em;
      margin-bottom: 8px;
    }
    .tileTitle {
      font-size: 3em;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .tileValue {
      font-size: 2.5em;
      font-weight: normal;
    }
    .barChart {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      width: 100%;
      margin-top: 5px;
      gap: 5px;
    }
    .bar {
      width: 10%;
      background-color: #007aff;
      border-radius: 4px 4px 0 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      color: #fff;
      font-size: 0.8em;
    }
    /* Game Over Overlay */
    #gameOverOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 20;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 30px;
      border-radius: 15px;
      font-size: 2em;
      white-space: pre-line;
      display: none;
    }
    body.dark-mode #gameOverOverlay {
      border: 3px solid #fff;
    }
    .hidden {
      display: none !important;
    }
    /* Timer Container */
    /* Timer Container */
        #timerContainer {
            font-weight: bold;
          position: fixed;
          right: 10px;
          bottom: 48px;
          font-size: 1.5em;
          z-index: 100;
          display: flex; /* Versteckt, bis der Intro-Modus beendet ist */
          align-items: center;
          justify-content: center;
          cursor: pointer;
          background: rgba(255, 255, 255, 0.8);
          padding: 5px 10px;
          border-radius: 5px;
        }
    /* Hauptinhalt */
    #mainContent {
      display: none;
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease-in;
      padding-bottom: 50px;
    }
    /* Einstellungen-Menü */
    #settingsPanel {
      /* Behalte deine Positionierung bei */
      position: fixed;
      top: 150%;
      right: 20px;
      display: none; /* wird später per JS auf 'flex' gesetzt */
      flex-direction: column;
      align-items: center;
      z-index: 10;
      border-radius: 10px;
      width: 60px;

      /* 3D-Optik */
      background: white;               /* Heller Pastellton */
      border: 2px solid black;         /* Passender Randton */
      border-radius: 10px;
      box-shadow:
        0 6px 0 black,                 /* „fester“ Schatten für die 3D-Kante */
        0 6px 6px rgba(0, 0, 0, 0.2);    /* Weicher Schlagschatten */
      padding: 15px 24px;                /* Innenabstand */
      margin: 8px;                       /* Außenabstand */
      font-size: 1.2em;                  /* Schriftgröße */
      text-align: center;
      color: black;
      box-sizing: border-box;

      /* Animation/Übergänge beim Drücken */
      transition: transform 0.2s, box-shadow 0.2s, opacity 0.5s ease;
    }

    /* ================================= */
    /* 3D-Stil für das Lagen-Rechteck    */
    /* ================================= */
    #clefTitle {
        text-transform: uppercase;
        font-weight: bold;
      background: #d0e8d0;
      border: 2px solid #b7d3b7;
      border-radius: 8px;
      box-shadow:
        0 6px 0 black,
        0 6px 6px rgba(0, 0, 0, 0.2);
      padding: 16px 24px;
      margin: 8px;
      font-size: 1.2em;
      text-align: center;
      color: #333;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    #clefTitle:active {
      transform: translateY(6px);
      box-shadow:
        0 0 0 #abc9ab,
        0 6px 6px rgba(0, 0, 0, 0.2);
    }
    body.dark-mode #settingsPanel {
      background: #000;
      border-color: #fff;
    }
    #settingsPanel span {
      display: block;
      cursor: pointer;
      font-size: 1.8em;
      margin: 8px 0;
      padding: 2px;
      text-align: center;
      background: none;
      border: none;
      transition: background 0.2s, opacity 0.2s;
    }
    #settingsPanel span:hover {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 10px;
    }
    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
      100% { transform: translateY(0); }
    }
    
    /* Lagewechsel-Button */
    #clefTitle {
      display: inline-block;
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
      animation: float 3s ease-in-out infinite;
    }
    body.dark-mode #clefTitle {
      background: #000;
      border-color: #fff;
      color: #fff;
    }
    /* Neuer Pausen-Button im Menü */
    #pauseButton {
      display: inline-block;
      background: #fff;
      border: 3px solid #000;
      border-radius: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      color: #000;
      cursor: pointer;
      transition: all 0.5s ease;
      margin-top: 10px;
    }
    body.dark-mode #pauseButton {
      background: #000;
      border-color: #fff;
      color: #fff;
    }
    /* Container für Button & Herzen */
    #buttonContainer {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      z-index: 50;
    }
    #heartsContainer {
      display: inline-block;
      margin-left: 10px;
      vertical-align: middle;
      font-size: 1.5em;
    }
    /* Notenname-Anzeige (normaler Modus) */
    #noteNameDisplay {
      margin-top: 10px;
      font-size: 24px;
      color: #000;
      text-transform: uppercase;
    }
    body.dark-mode #noteNameDisplay { color: #e0e0e0; }
    /* Welcome Overlay */
    #welcomeOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      transition: opacity 0.5s ease-out;
      background-color: transparent;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-image: url("https://raw.githubusercontent.com/jp0024/piano.github.io/main/hintergrund.svg");
      background-size: cover;
      background-position: center;
    }
    #welcomeMessage {
      font-size: 2.5em;
      color: white;
      margin-bottom: 20px;
      font-weight: bold;
    }
    body.dark-mode #welcomeMessage { color: #e0e0e0; }
    
    .bar-chart-container {
      display: flex;
      justify-content: space-between;
      gap: 4px;
      width: 100%;
      padding: 10px;
      height: 120px; /* Gesamthöhe inkl. Label */
    }

    .bar-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .bar {
      width: 100%;
      background: linear-gradient(to top, black, grey);
      border-radius: 4px 4px 0 0;
      transition: height 0.5s ease-in-out;
    }

    .bar-label {
      margin-top: 4px;
      font-size: 0.9em;
      text-align: center;
      color: #000;
    }
      
      /* Beispiel: Klasse für eine breite, aber nur 1 Zeile hohe Kachel */
      .tile.span-2 {
        grid-column: span 2;
        /* Falls eine andere Regel (nth-child(3n)) sie hochskalieren würde, überschreiben wir das: */
        grid-row: span 1 !important;
      }
      
      body.dark-mode #pauseOverlay {
        background: #121212; /* dunkler Hintergrund */
      }

      body.dark-mode #pauseHeader,
      body.dark-mode #pauseTime {
        color: white; /* helle Schrift */
      }

      body.dark-mode #pauseProgressContainer {
        background: black; /* evtl. noch dunklerer Hintergrund für den Fortschrittsbalken */
        border-color: white;
      }
      
      .tile.span-2 {
        grid-column: span 2;
        grid-row: span 1 !important;
      }
      
      #streakDisplay {
        position: fixed;
        left: 20px;
        bottom: 30px;
        font-size: 1.5em;
        z-index: 50;
      }
      
    @media screen and (max-width: 600px) {
  
  /* Notensystem kürzen: Notation-Container anpassen */
  #notation {
    top: 60%;
    max-width: 90%;
    padding: 5px;
  }
  
  /* Passe die Notenanzeige an (falls nötig) */
  #noteNameDisplay {
    font-size: 3em;
    bottom: 80px; /* leicht nach oben verschieben, wenn nötig */
  }
  
  /* Optional: Passe den Button-Container an, falls er zu groß ist */
  #buttonContainer {
    flex-direction: column;
    bottom: 20px;
  }
}

     
     /* Custom Mode Modal Styles */
     #customModeModal {
         position: fixed;
         top: 15%;
         right: 90px; /* ca. 10px links vom Menü */
         width: 400px;
         background: white;
         border: 2px solid black;
         border-radius: 10px;
         padding: 20px;
         z-index: 150;
     }
     #customModeModal h2 {
         margin-top: 0;
         text-align: center;
     }
     .custom-mode-row {
         display: flex;
         justify-content: space-around;
         margin-bottom: 15px;
         flex-wrap: wrap;
     }
     .custom-mode-clef-container, .custom-mode-range-container, .custom-mode-note-set {
         display: flex;
         gap: 5px;
     }
.custom-mode-clef-option, .custom-mode-range-option, .custom-mode-note-option {
    padding: 5px 10px;
    border: none;
    background: none;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.3s;
    font-weight: bold;
}
     .custom-mode-clef-option.active, .custom-mode-range-option.active, .custom-mode-note-option.active {
         opacity: 1;
     }
     .custom-mode-hand-label {
         align-self: center;
         margin-right: 10px;
         font-weight: bold;
     }
     .custom-mode-save {
         text-align: center;
         margin-top: 20px;
     }
     
     .custom-mode-save button {
         background: white;
         border: 2px solid black;
         border-radius: 8px;
         padding: 10px 20px;
         font-weight: bold;
         cursor: pointer;
         font-size: 1em;
         color: #000;
         transition: transform 0.2s, box-shadow 0.2s;
     }
     
     .custom-mode-save button:active {
         transform: translateY(6px);
         box-shadow:
           0 0 0 #abc9ab,
           0 6px 6px rgba(0,0,0,0.2);
     }
     .hidden {
         display: none !important;
     }
    /* Carousel Hint Speech Bubble */
    .speech-bubble {
      position: fixed;
      width: 180px;
      padding: 10px;
      background: #fff;
      border: 2px solid #000;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-size: 0.9em;
      z-index: 1001;
    }
    .speech-bubble::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 10px 10px 0;
      border-style: solid;
      border-color: #fff transparent;
    }
    .speech-bubble .close-btn {
      position: absolute;
      top: 2px;
      right: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    /* Carousel container and track */
    #carouselContainer {
      position: relative;
      width: 40px;
      height: 40px;
      overflow: hidden;
      margin: 0 auto;
    }
    #carouselTrack {
      display: flex;
      height: 100%;
      transition: transform 0.3s ease;
    }
    .carouselItem {
      flex: 0 0 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
      
      @keyframes flyOutRight {
        to { opacity: 0; transform: translateX(100%); }
      }
      @keyframes flyOutLeft {
        to { opacity: 0; transform: translateX(-100%); }
      }
      .fly-out-right {
        animation: flyOutRight 0.5s forwards;
      }
      .fly-out-left {
        animation: flyOutLeft 0.5s forwards;
        
      }
      
      #virtualKeyboard {
        position: fixed;
        top: 150%;
        left: 30px;
        right: 30px;
        width: auto;
        max-width: calc(100% - 60px);
        height: 100px;
        transform-origin: top center; /* Für skalierte Darstellung */
      }

      /* Real Piano Key Sizes */
      #virtualKeyboard .white-key, #virtualKeyboard .white {
        width: 23px !important;
        height: 560px !important;
      }

      #virtualKeyboard .black-key, #virtualKeyboard .black {
        width: 14px !important;
        height: 80px !important;
        margin-left: -7px;
        margin-right: -7px;
      }

      /* Nur Touch-Interaktionen für die virtuelle Klaviatur erlauben */
      @media (pointer: fine) {
        #virtualKeyboard {
          pointer-events: none;
        }
      }
      @media (pointer: coarse) {
        #virtualKeyboard {
          pointer-events: auto;
          margin: 0 20px; /* Abstand zu den Bildschirmrändern */
        }
      }
      
      /* Solange vk-active, behalten diese Elemente immer ihre Top-Position */
      body.vk-active #timerContainer,
      body.vk-active #streakDisplay,
      body.vk-active #buttonContainer {
        top: 30px !important;
        bottom: auto !important;
      }

      /* Fehler-/Korrektur-Overlay ebenfalls immer von oben einblenden */
      body.vk-active #pauseOverlay,
      body.vk-active .correction {
        top: 20px !important;
        bottom: auto !important;
      }
      
      #correctionBox {
        position: fixed;
        bottom: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: #fff;
        border: 3px solid #000;
        padding: 15px 30px;
        border-radius: 15px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      #correctionChoices {
        display: flex;
        gap: 10px;
        align-items: center;
        font-size: 2em;
      }

      #correctionChoices button,
      #confirmNoteBtn {
        font-size: 1.5em;
        padding: 5px 10px;
        cursor: pointer;
      }
      
      
        .correction-choice {
          opacity: 0.5;
          margin: 5px;
          cursor: pointer;
          display: inline-block;
          padding: 5px;
          border: 1px solid #000;
          border-radius: 4px;
        }
      
     
        #scaleSelector {
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 100;
          display: flex;
          gap: 10px;
        }
        .clef-button {
          font-size: 2em;
          padding: 5px 10px;
          background: white;
          border: 2px solid black;
          border-radius: 10px;
          cursor: pointer;
        }
        
        .selectable-note {
          font-size: 1.5em;
          padding: 8px 10px;
          border: 2px solid black;
          border-radius: 6px;
          background: white;
          cursor: pointer;
        }
        .selectable-note.selected {
          background: lightgreen;
        }
      
      .vf-note.selected path {
        stroke: green !important;
        fill: green !important;
      }
      
      #scaleSelector {
        display: none;
        margin: 10px 0;
        gap: 8px;
      }
      #scaleSelector button {
        cursor: pointer;
        padding: 4px 8px;
      }
    /* Metronome input: borderless, no spinner arrows */
    #metronomeInput {
      border: none;
      background: transparent;
      outline: none;
      -moz-appearance: textfield;
      -webkit-appearance: none;
      appearance: none;
    }
    #metronomeInput::-webkit-outer-spin-button,
    #metronomeInput::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
      
      /* 1) Settings-Panel beim Long-Press aufklappen */
      #settingsPanel.expanded {
        top: 0      !important;
        bottom: 0   !important;
        height: auto!important;
        display: flex!important;
        flex-direction: column;
        justify-content: flex-start;
        overflow-y: auto;
      }

      /* 2) Draggable Emojis gestalten */
      .settings-emoji {
        font-size: 2em;
        margin: 8px 0;
        cursor: grab;
        user-select: none;
        transition: border 0.2s;
      }
      .settings-emoji.drag-over {
        border: 2px dashed #333;
      }
  </style>
  <script>
      
      let twoHandMode = false;
      let seriesCounterLeft = 0;
      let seriesCounterRight = 0;
      let currentSeriesLeft = [];
      let currentSeriesRight = [];


      
      
      // (hwToggle click event listener will be added later in DOMContentLoaded after settingsPanel.appendChild(hwToggle))

      // Camera-based QR scanning
      async function openCameraScan() {
        let stream;
        try {
          stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
        } catch (err) {
          alert("Kamerazugriff fehlgeschlagen: " + err.message);
          return null;
        }
        // Create modal overlay
        const scanOverlay = document.createElement("div");
        scanOverlay.id = "scanOverlay";
        Object.assign(scanOverlay.style, {
          position: "fixed", top:0, left:0, width:"100%", height:"100%",
          background:"rgba(0,0,0,0.8)", display:"flex", alignItems:"center", justifyContent:"center", zIndex:"2000"
        });
        const video = document.createElement("video");
        video.style.maxWidth = "90%";
        video.style.maxHeight = "80%";
        video.autoplay = true;
        video.srcObject = stream;
        scanOverlay.appendChild(video);
        const captureBtn = document.createElement("button");
        captureBtn.textContent = "Scannen";
        Object.assign(captureBtn.style, { position:"absolute", bottom:"20px", fontSize:"1.2em", padding:"10px" });
        scanOverlay.appendChild(captureBtn);
        document.body.appendChild(scanOverlay);
        return new Promise(resolve => {
          captureBtn.addEventListener("click", () => {
            const canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext("2d").drawImage(video, 0, 0);
            const code = jsQR(canvas.getContext("2d").getImageData(0,0,canvas.width,canvas.height).data, canvas.width, canvas.height);
            stream.getTracks().forEach(t => t.stop());
            document.body.removeChild(scanOverlay);
            resolve(code);
          });
        });
      }
      
    // Disable any scrolling
    window.addEventListener('scroll', function(e) {
      e.preventDefault();
      window.scrollTo(0, 0);
    }, { passive: false });
  
  // Oben im Skript
  let customModeSettings = null;
  const octaveDefinitions = {
    grosse:   { notes: ["c","d","e","f","g","a","b"], baseOctave: 3 },
    kleine:   { notes: ["c","d","e","f","g","a","b"], baseOctave: 4 },
    eingestr: { notes: ["c","d","e","f","g","a","b"], baseOctave: 5 },
    zweigestr:{ notes: ["c","d","e","f","g","a","b"], baseOctave: 6 },
  };
  
let wizardMode = true;
   let correctionActive = false;
   let availableNotes = [];
   let selectedNoteIndex = 0;
   let expectedNote = "";
   
   
      
// === Touch‐based positioning for the notation crosshair ===
document.addEventListener('DOMContentLoaded', () => {
  const notation = document.getElementById('notation');
  if (!notation) return;

  // Load or set default transform
  let saved = localStorage.getItem('notationTransform');
  if (!saved) {
    saved = 'translate(-50%, -50%)';
    localStorage.setItem('notationTransform', saved);
  }
  notation.style.transform = saved;

  // Prepare variables for touch dragging
  let startX = 0, startY = 0;
  let initX = 0, initY = 0;
  let dragging = false;

  notation.addEventListener('touchstart', e => {
    // Only allow dragging if the Geodreieck-Button ("geometryToggle") is active
    const toggle = document.getElementById('geometryToggle');
    const isActive = toggle && (toggle.classList.contains('active') || toggle.dataset.active === 'true');
    if (!isActive) return;
    e.preventDefault();
    dragging = true;
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
    const style = window.getComputedStyle(notation);
    const matrix = new DOMMatrix(style.transform);
    initX = matrix.m41;
    initY = matrix.m42;
  }, { passive: false });

  notation.addEventListener('touchmove', e => {
    if (!dragging) return;
    e.preventDefault();
    const touch = e.touches[0];
    const dx = touch.clientX - startX;
    const dy = touch.clientY - startY;
    const newX = initX + dx;
    const newY = initY + dy;
    // Calculate the position of the center of notation in viewport
    // The transform is relative to (left:50%, top:50%)
    const newLeft = newX + window.innerWidth / 2;
    const newTop = newY + window.innerHeight / 2;
    if (
      newLeft > 0 &&
      newLeft < window.innerWidth &&
      newTop > 0 &&
      newTop < window.innerHeight
    ) {
      notation.style.transform = `translate(${newX}px, ${newY}px)`;
    }
  }, { passive: false });

  notation.addEventListener('touchend', () => {
    if (!dragging) return;
    dragging = false;
    localStorage.setItem('notationTransform', notation.style.transform);
  });
});
    
      
      document.addEventListener("DOMContentLoaded", () => {
        const timerElem = document.getElementById("timerContainer");
        // Beispiel: Direkt eine Info setzen
        timerElem.textContent = `${sessionCounter} Noten, vsl. 00:00 min`;
        // Oder den Timer sofort updaten, falls du eine Funktion hast:
        updateTimer();
      // Entfernt: Doppele Aufruf von startTutorialSequence() wurde entfernt,
      // da das Tutorial nun ausschließlich über die MIDI-Prüfung gestartet wird.
      });
      let elapsedTimer = 0;
      let cachedUserRank = null;
      let kidsMode = false;
      
      function updateUserPlacement(valueElem, data) {
        const sorted = data.sort((a, b) => {
          const qA = parseInt(a.quote || 0), qB = parseInt(b.quote || 0);
          const sA = parseInt(a.speed || 9999), sB = parseInt(b.speed || 9999);
          if (qB !== qA) return qB - qA;
          return sA - sB;
        });
        const rank = sorted.findIndex((e) => e.user === userID) + 1;
        const text = rank > 0 ? `Platz ${rank}` : "Nicht gefunden";
        cachedUserRank = text;
        valueElem.textContent = text;
      }
      
      function showMotivation(message) {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = message;
          overlay.style.opacity = "1";
          overlay.classList.add("animate-motivation");
          setTimeout(() => {
               overlay.style.opacity = "0";
               overlay.classList.remove("animate-motivation");
          }, 2000);
      }

      function clearMotivation() {
          const overlay = document.getElementById("motivationOverlay");
          overlay.textContent = "";
      }
      
    /************** Funktionen, die vor der Verwendung deklariert sein müssen **************/
    // Eigene Prompt-Funktion, die in Swift-Umgebungen den Message-Handler nutzt
      function customPrompt(message) {
    if (typeof prompt === 'function') {
          return prompt(message);
    } else if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.customPrompt) {
          // Sende die Nachricht an Swift; Swift muss dann eine Antwort zurückliefern,
          // z. B. indem es window.customPromptResponse setzt.
          window.webkit.messageHandlers.customPrompt.postMessage(message);
          // Hier nehmen wir an, dass Swift synchron oder zeitnah eine Antwort liefert und
          // diese in window.customPromptResponse speichert. (Alternativ muss hier asynchron vorgegangen werden.)
          return window.customPromptResponse || "";
        } else {
          console.log("Kein Prompt verfügbar.");
          return "";
        }
      }
      
    // Metronom-Variablen und Funktionen
      let metronomeOn =false;
      let metronomeBPM = 0;
      let metronomeInterval = 0;
      let metronomeTimer = null;
      let lastTickTime = 0;
      let metronomeTolerance = 100; // ms Toleranz für MIDI-Übertragung
      // Tick-Sound (bitte ggf. die URL anpassen)
      const tickSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/tick.mp3");
    
      function startMetronome() {
        lastTickTime = Date.now();
        tickSound.currentTime = 0;
        tickSound.play();
        metronomeTimer = setInterval(() => {
          tickSound.currentTime = 0;
          tickSound.play();
          lastTickTime = Date.now();
        }, metronomeInterval);
      }
    
      function stopMetronome() {
        clearInterval(metronomeTimer);
      }

      function showPauseScreen() {
        sessionPaused = true;
        document.getElementById("mainContent").style.display = "none";
        document.getElementById("timerContainer").style.display = "none";
        document.getElementById("settingsPanel").style.display = "none";
        // Animate notation scale up and back on pause
        const notationEl = document.getElementById("notation");
        if (notationEl) {
          notationEl.style.transition = "transform 0.2s ease-in-out";
          // Scale up from the default translation
          notationEl.style.transform = "translate(-50%, -50%) scale(1.2)";
          // After 200ms, revert to default position
          setTimeout(() => {
            notationEl.style.transform = "translate(-50%, -50%)";
          }, 200);
        }
        document.getElementById("pauseOverlay").style.display = "flex";
      }
      
    // Neue Funktion, die einen grünen Farbtupfer erzeugt
    function saveButtonEffect() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      
      // Hole die Position des Menüs (settingsPanel)
      const settingsPanel = document.getElementById("settingsPanel");
      const emojiContainer = document.getElementById("settingsEmojiContainer");
      let x, y;
      if (settingsPanel) {
        const rect = settingsPanel.getBoundingClientRect();
        // Tupfer soll in der Mitte des Menüs erscheinen
        x = rect.left + rect.width / 2;
        y = rect.top + rect.height / 2;
      } else {
        // Fallback: Mitte des Canvas
        x = canvas.width / 2;
        y = canvas.height / 2;
      }
      
      // Definiere Parameter für den Tupfer
      const radius = Math.random() * 200 + 200; // Größe anpassen
      const creationTime = Date.now();
      const duration = 1500; // Dauer in Millisekunden
      
      // Erzeuge den Tupfer (Farbtupfer wird zur globalen circles-Array hinzugefügt)
      circles.push({ x, y, radius, color: "green", creationTime, duration });
    }
      
    function updateStreak() {
      // Hole den bisherigen Streak (falls vorhanden)
      let streak = Number(localStorage.getItem("streak")) || 0;
      // Hole das Datum der letzten Lernsession, falls vorhanden
      let lastDateStr = localStorage.getItem("lastLearnDate");
      // Bestimme heute (ohne Uhrzeit)
      let today = new Date();
      today.setHours(0,0,0,0);
      
      if (lastDateStr) {
        let lastDate = new Date(lastDateStr);
        lastDate.setHours(0,0,0,0);
        // Berechne den Unterschied in Tagen
        let diffDays = (today - lastDate) / (1000 * 60 * 60 * 24);
        if (diffDays === 1) {
          // Konsekutiver Tag: Erhöhe den Streak
          streak++;
        } else if (diffDays > 1) {
          // Mehr als ein Tag Pause: Streak zurücksetzen
          streak = 1;
        }
        // Falls diffDays === 0: wir sind noch am gleichen Tag; der Streak bleibt unverändert
      } else {
        streak = 1;
      }
      
      // Speichere das heutige Datum und den aktuellen Streak
      localStorage.setItem("lastLearnDate", today.toISOString());
      localStorage.setItem("streak", streak);
      
      return streak;
    }
      
      document.addEventListener("DOMContentLoaded", () => {
        // Aktualisiere und zeige den Streak an:
        const currentStreak = updateStreak();
        const streakDisplay = document.getElementById("streakDisplay");
        streakDisplay.textContent = "🔥 " + currentStreak;
        streakDisplay.style.cursor = "pointer";
        streakDisplay.addEventListener("click", () => {
          sessionCounter = 0;
          updateTimer();
          startPauseCountdown();
        });

        // ... restlicher Initialisierungscode
      });
      
    function logSessionStart() {
      const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
      sessionTimes.push(new Date().toISOString());
      localStorage.setItem("sessionTimes", JSON.stringify(sessionTimes));
    }
      
    // Speichert die relevanten Statistiken im localStorage
    function saveStatistics() {
      const stats = {
        totalAttempts: totalAttempts,
        correctAnswers: correctAnswers,
        correctNoteCount: correctNoteCount,
        responseTimes: responseTimes,
        sessionCount: sessionCount,
        hearts: hearts,
        errorNotes: errorNotes,
        // Du kannst hier auch weitere Variablen eintragen, z.B. openTimes, appStartTime etc.
        appStartTime: appStartTime
      };
      localStorage.setItem("appStatistics", JSON.stringify(stats));
      // Ensure all leaderboard values (accuracy, duration, mode) are sent for proper leaderboard updates
      if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
        window.webkit.messageHandlers.gameCenter.postMessage({
          type: "highscore",
          value: {
            accuracy: Math.round((correctAnswers / totalAttempts) * 100),
            duration: Math.floor((Date.now() - appStartTime) / 1000),
            mode: randomMode ? "random" : selectedMode
          }
        });
      }
    }

    // Lädt die Statistiken aus dem localStorage und weist sie den globalen Variablen zu
    function loadStatistics() {
      const statsStr = localStorage.getItem("appStatistics");
      if (statsStr) {
        const stats = JSON.parse(statsStr);
        totalAttempts = stats.totalAttempts || 0;
        correctAnswers = stats.correctAnswers || 0;
        correctNoteCount = stats.correctNoteCount || 0;
        responseTimes = stats.responseTimes || [];
        sessionCount = stats.sessionCount || 0;
        hearts = stats.hearts || (unlimitedLives ? Infinity : 4);
        errorNotes = stats.errorNotes || [];
        appStartTime = stats.appStartTime || Date.now();
      }
    }

    // Optional: Speichern der Statistiken, wenn die Seite geschlossen wird
    window.addEventListener("beforeunload", saveStatistics);

    // Beim Laden der Seite die Statistiken laden
    document.addEventListener("DOMContentLoaded", loadStatistics);
    
    function proceedToMainScreen() {
      const audio = document.getElementById("backgroundSound");
      if (audio) { audio.pause(); }
      appStartTime = Date.now();
      const welcomeOverlay = document.getElementById("welcomeOverlay");
      welcomeOverlay.style.opacity = "0";
      setTimeout(() => {
        welcomeOverlay.classList.add("hidden");
        const mainContent = document.getElementById("mainContent");
        mainContent.style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        setTimeout(() => { mainContent.style.opacity = "1"; }, 10);
      }, 500);
    }
    function getRandomThreshold() {
      return Math.floor(Math.random() * 4) + 2;
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      const settingsPanel = document.getElementById("settingsPanel");
      const pauseButton = document.createElement("span");
      pauseButton.id = "pauseButton";
      pauseButton.textContent = "🎹";
      settingsPanel.appendChild(pauseButton);

      pauseButton.addEventListener("click", () => {
        const notationElem = document.getElementById("notation");
        const vk = document.getElementById("virtualKeyboard");
        if (vk) {
          const isHidden = vk.style.visibility === "hidden";
          vk.style.visibility = isHidden ? "visible" : "hidden";
          // Neu: Klasse setzen/removen
          if (isHidden) {
            document.body.classList.add("vk-active");
          } else {
            document.body.classList.remove("vk-active");
          }
          if (notationElem) {
            if (isHidden) {
              // Keyboard wird aktiviert: Notation etwas höher positionieren
              notationElem.style.top = "55%";
            } else {
              // Keyboard wird deaktiviert: gespeicherte Position wiederherstellen
              const saved = localStorage.getItem("notationTransform");
              if (saved) notationElem.style.transform = saved;
              // Entferne inline-top, damit CSS-Default (85%) greift
              notationElem.style.top = "";
            }
          }
        }
      });

      // ---- Virtual Keyboard below notation ----
      // Find the button container
      const bc = document.getElementById("buttonContainer");
      if (bc) {
        // Create a virtual keyboard element
        const vk = document.createElement("div");
        vk.id = "virtualKeyboard";
        vk.textContent = "Virtuelles Keyboard";
        // Keyboard initially hidden
        vk.style.visibility = "hidden";
        vk.style.position = "fixed";
        vk.style.top = "10%";
        vk.style.transform = "translateY(210%) scale(0.7, 1.5)"; // Uniform Zoom: both axes the same scale
        vk.style.zIndex = "100";
        vk.style.background = "#eee";
        vk.style.padding = "100px";
        // Initially place it just above the button container
        // We'll update its position on window resize and DOMContentLoaded
        function positionVK() {
          const bcRect = bc.getBoundingClientRect();
          const vkHeight = vk.offsetHeight || 200;
          // Place it above the button container, but not out of screen
          let top = bcRect.top - vkHeight - 5;
          if (top < 0) top = 0;
          vk.style.top = `${top}px`;
        }
        // Append first so offsetHeight is available
        document.body.appendChild(vk);
        // --- Override key dimensions after rendering ---
        setTimeout(() => {
          const whiteKeys = vk.querySelectorAll('.white-key, .white');
          whiteKeys.forEach(key => {
            key.style.width = '23px';
            key.style.height = '260px';
          });
          const blackKeys = vk.querySelectorAll('.black-key, .black');
          blackKeys.forEach(key => {
            key.style.width = '14px';
            key.style.height = '80px';
            key.style.marginLeft = '-7px';
            key.style.marginRight = '-7px';
          });
        }, 100);
        // Position after appending
        positionVK();
        // Update position on window resize and orientation change
        window.addEventListener("resize", positionVK);
        window.addEventListener("orientationchange", positionVK);
        // The virtual keyboard layout and input is now handled only by QwertyHancock or other dedicated code.
        // No manual <button> elements are created here.
      }
    });
      
    /************** Globale Variablen & Konstanten **************/
    // Handoptionen
    const handOptions = [
      { mode: "left", symbol: "✋" },
      { mode: "right", symbol: "✋", flip: true }
    ];
    let currentHandIndex = 0;
    let selectedMode = handOptions[currentHandIndex].mode;
    let randomMode = false;
    
    // Verfügbare Lagen
    const rangeArray = ["C", "D", "F", "G", "MC"];
    const alternatingRanges = ["C", "D", "MC"]; // Vordefinierte Lagen, die im Hasenmodus alternieren sollen
    let currentRangeIndex = 0;
    let currentRange = rangeArray[currentRangeIndex];
    
    // Wichtig: Definition der rangeNotes – Zuordnung von Lage zu Noten
    const rangeNotes = {
      "C": ["c", "d", "e", "f", "g"],
      "D": ["d", "e", "f#", "g", "a"],
      "F": ["f", "g", "a", "bb", "c"],
      "G": ["g", "a", "b", "c", "d"],
      "MC": ["c", "d", "e", "f", "g"]
    };
    
    let currentSeriesSingle = [];
    let seriesCounter = 1000;
    const seriesLength = 5;
    let totalAttempts = 0;
    let correctAnswers = 0;
    let correctNoteCount = 0;
    let nextMotivationThreshold = getRandomThreshold();
    let errorNotes = [];
    let responseTimes = [];
    let lastNoteTimestamp = Date.now();
    let appStartTime = Date.now();
    let sessionCounter = Number(localStorage.getItem("sessionCounter")) || 5; // 5 korrekte Noten erforderlich
    let sessionPaused = false;
    let scoreRecorded = false;
    let sessionCount = 0;
    let unlimitedLives = true;
    let hearts = unlimitedLives ? Infinity : 4;
    let inactivityTimeout = null;
    
    // Beim Laden der Seite oder zu Beginn eines Trainings:
    const saveOpenTime = () => {
      const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
      openTimes.push(new Date().toISOString());
      localStorage.setItem("openTimes", JSON.stringify(openTimes));
    };

    document.addEventListener("DOMContentLoaded", saveOpenTime);
    
    const updateHeartsDisplay = () => {
      const heartsElem = document.getElementById("heartsContainer");
      heartsElem.textContent = unlimitedLives ? "" : "❤️".repeat(hearts);
    };
      const updateTimer = () => {
        const timerElem = document.getElementById("timerContainer");
        
        // Berechne den durchschnittlichen Bearbeitungszeit (in ms), Standard: 1000 ms falls noch keine Werte vorhanden
        let avgResponse = responseTimes.length > 0
          ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
          : 1000;
        
        // Berechne die Fehlerquote: Anteil der Fehlversuche
        let errorRate = totalAttempts > 0
          ? (totalAttempts - correctAnswers) / totalAttempts
          : 0;
        
        // Voraussichtliche Zeit (in Sekunden) = Anzahl verbleibender Noten * (durchschnittliche Bearbeitungszeit in s) * (1 + Fehlerquote)
        let predictedTimeSec = sessionCounter * (avgResponse / 1000) * (1 + errorRate);
        
        // Formatiere in mm:ss
        let minutes = Math.floor(predictedTimeSec / 60);
        let seconds = Math.floor(predictedTimeSec % 60);
        let timeStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
        
        timerElem.textContent = `${sessionCounter} Noten, vsl. ${timeStr} min`;
      };
      
      function updatePauseTiles() {
        const container = document.getElementById("pauseTiles");
        if (!container) return;

        // Berechne App‑Zeit
        const totalTimeSec = Math.floor((Date.now() - appStartTime) / 1000);
        const h = Math.floor(totalTimeSec / 3600);
        const m = Math.floor((totalTimeSec % 3600) / 60);
        const s = totalTimeSec % 60;
        const appTime = (h > 0 ? (h + "h ") : "") + m + "m " + s + "s";

        // Berechne Prozent richtiger Noten
        const correctPercent = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;

        // Durchschnittliche Bearbeitungszeit (in Sekunden)
        const avgTimeSec = responseTimes.length
          ? (responseTimes.reduce((acc, t) => acc + t, 0) / responseTimes.length / 1000).toFixed(2)
          : "N/A";

        container.innerHTML = `
          <div class="tile">
            <div class="tileIcon">⏰</div>
            <div class="tileTitle">App‑Zeit</div>
            <div class="tileValue">${appTime}</div>
          </div>
          <div class="tile">
            <div class="tileIcon">✅</div>
            <div class="tileTitle">Richtige Noten</div>
            <div class="tileValue">${correctPercent}%</div>
          </div>
          <div class="tile">
            <div class="tileTitle">Wann übst du am meisten?</div>
            <div class="barChart">
               ${generateBarChartHTML()}
            </div>
          </div>
          ${ generateLearningQualityGraphTile() }
          <div class="tile">
            <div class="tileTitle">Session</div>
            <div class="tileValue">${sessionCount}</div>
          </div>
          ${generateTrophyTile()}
        `;
      }
      
      function getLastThreeSessions() {
        // Beispiel: Session-Daten als Array von Objekten mit responseTimes (ms), errorCount, totalAttempts und sessionTime (in sec)
        const sessions = JSON.parse(localStorage.getItem("sessionData") || "[]");
        return sessions.slice(-3);
      }

      function calculateQuality(session) {
        // Durchschnittliche Antwortzeit in Sekunden (niedriger ist besser)
        const avgResponse = session.responseTimes.length
          ? session.responseTimes.reduce((a, b) => a + b, 0) / session.responseTimes.length / 1000
          : 0;
        // Fehlerquote (niedriger ist besser)
        const errorRate = session.totalAttempts ? (session.errorCount / session.totalAttempts) : 0;
        // Die Session-Dauer in Sekunden – längere Sessions können auf mehr Engagement hinweisen
        const learningTime = session.sessionTime || 0;
        // Beispielhafte Gewichtung: Wir wollen, dass niedrigere Antwortzeiten und Fehlerquoten zu höheren Qualitätswerten führen.
        // Hier eine einfache Rechnung, die in den meisten Fällen einen Wert zwischen 0 und 100 liefert.
        let quality = 100 - (avgResponse * 10) - (errorRate * 100) + (learningTime / 60);
        return Math.max(0, Math.min(quality, 100));
      }
      
      function drawLearningQualityGraph(canvas, sessions) {
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // Berechne die Qualitätswerte
        const qualities = sessions.map(calculateQuality);

        // Wir erwarten Werte zwischen 0 und 100, also skalieren wir den y-Wert entsprechend.
        ctx.beginPath();
        for (let i = 0; i < qualities.length; i++) {
          const x = (i / (qualities.length - 1)) * width;
          // Höhere Qualität => niedrigere y-Koordinate (oben ist 0)
          const y = height - (qualities[i] / 100 * height);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
          // Optional: Zeichne einen kleinen Kreis als Punkt
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fillStyle = "#007aff";
          ctx.fill();
          ctx.beginPath(); // Beginne neuen Pfad für die Linie
          if(i === 0) {
            ctx.moveTo(x,y);
          }
        }
        ctx.strokeStyle = "#007aff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      

      function generateTrophyTile() {
        const tile = document.createElement("div");
        tile.className = "tile span-2";
        tile.style.display = "flex";
        tile.style.flexDirection = "row";
        tile.style.alignItems = "center";
        tile.style.justifyContent = "space-between";
        const title = document.createElement("div");
        title.className = "tileTitle";
        title.style.flex = "1";
        title.style.display = "flex";
        title.style.flexDirection = "column";
        title.style.justifyContent = "center";
        title.style.alignItems = "center";
        title.innerHTML = "🏆 Trophäen                 <span id='resetTrophiesBtn' style='cursor:pointer;' title='Reset'>🗑️</span>";
        tile.appendChild(title);

        const trophyGrid = document.createElement("div");
        const wrapper = document.createElement("div");
        wrapper.style.display = "flex";
        wrapper.style.flexDirection = "column";
        wrapper.style.alignItems = "flex-start";
        wrapper.style.flex = "2";
        trophyGrid.style.display = "grid";
        trophyGrid.style.gridTemplateColumns = "repeat(10, 1fr)";
        trophyGrid.style.gridGap = "5px";
        trophyGrid.style.fontSize = "2em";
    trophyGrid.style.marginTop = "10px";
    
    const descriptionBox = document.createElement("div");
    descriptionBox.id = "trophyDescriptionBox";
    descriptionBox.style.marginTop = "10px";
    descriptionBox.style.fontSize = "1em";
    descriptionBox.style.color = "#333";
    descriptionBox.style.minHeight = "2em";
    descriptionBox.style.marginLeft = "20px";
    descriptionBox.style.textAlign = "left";
    descriptionBox.style.maxWidth = "200px";

        const allTrophies = [
          "🐢", "🐌", "🚶‍♂️", "🏃", "⚡",     // Speed
          "🎼", "🎹", "🎺", "🪕", "🪗",     // Clef Accuracy
          "🌱", "🌿", "🌻", "🌲", "🎄", "🔥", "🚀", "🪐", "🌞", "👑", // Streak
          "🔀", "🌀", "🔁", "⏩", "⚙️",     // Mode switching
          "📏", "📐", "🧭", "🎯", "🏁"      // Metronome precision
        ];

        const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
        const justUnlocked = [];

        allTrophies.forEach((emoji, index) => {
          const span = document.createElement("span");
          span.textContent = emoji;
          span.title = getTrophyDescription(index);
          span.style.cursor = "pointer";
          span.addEventListener("click", () => {
            descriptionBox.textContent = getTrophyDescription(index);
          });
          if (unlockedTrophies.includes(index)) {
            span.style.opacity = "1";
          } else {
            const shouldUnlock = checkTrophyCondition(index);
            if (shouldUnlock) {
              unlockedTrophies.push(index);
              justUnlocked.push(span);
              span.style.opacity = "0";
              setTimeout(() => {
                span.style.transition = "opacity 1s";
                span.style.opacity = "1";
                confetti({ particleCount: 50, spread: 50, origin: { x: 0.5, y: 0.5 } });
              }, 100);
            } else {
              span.style.opacity = "0.5";
            }
          }
          trophyGrid.appendChild(span);
        });

        localStorage.setItem("unlockedTrophies", JSON.stringify(unlockedTrophies));
        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
          unlockedTrophies.forEach(id => {
            window.webkit.messageHandlers.gameCenter.postMessage({
              type: "achievement",
              value: "trophy_" + id
            });
          });
        }
        wrapper.appendChild(trophyGrid);
        wrapper.appendChild(descriptionBox);
        tile.appendChild(wrapper);
        setTimeout(() => {
          const resetBtn = document.getElementById("resetTrophiesBtn");
          if (resetBtn) {
            resetBtn.addEventListener("click", () => {
              localStorage.removeItem("unlockedTrophies");
              updatePauseTiles();
            });
          }
        }, 0);
        return tile.outerHTML;
      }

      function checkTrophyCondition(index) {
        const avg = responseTimes.length ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
        if (index === 0) return avg < 1500;
        if (index === 1) return avg < 1000;
        if (index === 2) return avg < 900;
        if (index === 3) return avg < 800;
        if (index === 4) return avg < 400;

        if (index >= 5 && index <= 9) {
          const ranges = ["C", "D", "F", "G", "MC"];
          const range = ranges[index - 5];
          return rangeNotes[range].every(note => !errorNotes.some(e => e.note === note));
        }

        const streak = Number(localStorage.getItem("streak") || 0);
        const thresholds = [2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
        if (index >= 10 && index <= 19) return streak >= thresholds[index - 10];

        if (index >= 20 && index <= 24) {
          const avgSwitch = responseTimes.length > 10 ? responseTimes.reduce((a, b) => a + b) / responseTimes.length : Infinity;
          return avgSwitch < (1500 - (index - 20) * 200);
        }

        if (index >= 25 && index <= 29) {
          if (!metronomeOn) return false;
          const maxDev = Math.max(...responseTimes.map(t => Math.abs(t - metronomeInterval)));
          const devPercent = maxDev / metronomeInterval;
          const limits = [0.3, 0.2, 0.15, 0.1, 0.05];
          return devPercent < limits[index - 25];
        }

        return false;
      }
function getTrophyDescription(index) {
  const descriptions = [
    "Durchschnittliche Reaktionszeit unter 1,5 Sekunden",
    "Durchschnittliche Reaktionszeit unter 1 Sekunde",
    "Durchschnittliche Reaktionszeit unter 0,9 Sekunden",
    "Durchschnittliche Reaktionszeit unter 0,8 Sekunden",
    "Durchschnittliche Reaktionszeit unter 0,4 Sekunden",
    "Fehlerfrei in der C-Lage",
    "Fehlerfrei in der D-Lage",
    "Fehlerfrei in der F-Lage",
    "Fehlerfrei in der G-Lage",
    "Fehlerfrei in der MC-Lage",
    "Streak von mindestens 2 Tagen",
    "Streak von mindestens 3 Tagen",
    "Streak von mindestens 5 Tagen",
    "Streak von mindestens 8 Tagen",
    "Streak von mindestens 13 Tagen",
    "Streak von mindestens 21 Tagen",
    "Streak von mindestens 34 Tagen",
    "Streak von mindestens 55 Tagen",
    "Streak von mindestens 89 Tagen",
    "Streak von mindestens 144 Tagen",
    "Schneller Lagenwechsel (Stufe 1)",
    "Schneller Lagenwechsel (Stufe 2)",
    "Schneller Lagenwechsel (Stufe 3)",
    "Schneller Lagenwechsel (Stufe 4)",
    "Schneller Lagenwechsel (Stufe 5)",
    "Taktgefühl: Abweichung <30%",
    "Taktgefühl: Abweichung <20%",
    "Taktgefühl: Abweichung <15%",
    "Taktgefühl: Abweichung <10%",
    "Taktgefühl: Abweichung <5%"
  ];
  return descriptions[index] || "";
}
                                            
function generateBarChartHTML() {
  // Standardwerte: Jeder Tag wird initial auf 0 gesetzt.
  const dayCounts = { Mo: 0, Di: 0, Mi: 0, Do: 0, Fr: 0, Sa: 0, So: 0 };
  
  // Zähle Öffnungszeiten
  const openTimes = JSON.parse(localStorage.getItem("openTimes") || "[]");
  openTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  // Zähle Session-Zeitpunkte
  const sessionTimes = JSON.parse(localStorage.getItem("sessionTimes") || "[]");
  sessionTimes.forEach(timeStr => {
    const d = new Date(timeStr);
    const day = d.toLocaleDateString('de-DE', { weekday: 'short' }).replace('.', '');
    if (dayCounts.hasOwnProperty(day)) {
      dayCounts[day]++;
    }
  });
  
  const days = ["Mo", "Di", "Mi", "Do", "Fr", "Sa", "So"];
  const maxVal = Math.max(...Object.values(dayCounts), 1);
  
  // Erstelle Container als Flex-Layout für das Balkendiagramm
  const container = document.createElement("div");
  container.className = "bar-chart-container";
  
  days.forEach(day => {
    const val = dayCounts[day] || 0;
    const barItem = document.createElement("div");
    barItem.className = "bar-item";
    
    const bar = document.createElement("div");
    bar.className = "bar";
    const height = Math.round((val / maxVal) * 100);
    bar.style.height = `${height}px`;
    
    const label = document.createElement("div");
    label.className = "bar-label";
    label.textContent = day;
    
    barItem.appendChild(bar);
    barItem.appendChild(label);
    container.appendChild(barItem);
  });
  
  return container.outerHTML;
}
      
      


function calculateAdaptiveBreakTime(responseTimes, hitRate) {
  // Berechne die durchschnittliche Antwortzeit in Millisekunden
  let avgResponse = responseTimes.length > 0
    ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
    : 1000;
  // Verwende hitRate (Erfolgsquote), um die Pausendauer anzupassen:
  // Eine niedrigere Erfolgsquote (mehr Fehler) führt zu längeren Pausen.
  return avgResponse * (1 + (1 - hitRate));
}
      
    const startPauseCountdown = () => {
  logSessionStart(); // Neuen Session-Zeitstempel speichern
  if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCenter) {
    window.webkit.messageHandlers.gameCenter.postMessage({
      type: "highscore",
      value: {
        accuracy: Math.round((correctAnswers / totalAttempts) * 100),
        duration: Math.floor((Date.now() - appStartTime) / 1000),
        mode: randomMode ? "random" : selectedMode
      }
    });
  }
  const quote = totalAttempts > 0 ? Math.round((correctAnswers / totalAttempts) * 100) : 0;
  const speed = responseTimes.length > 0
    ? Math.round(responseTimes.reduce((a, b) => a + b) / responseTimes.length)
    : 0;
  if (!userID) {
    console.error("Keine userID gesetzt! Abbruch.");
    return;
  }
  const timerElem = document.getElementById("timerContainer");
  const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  if (
    isiOS &&
    timerElem &&
    window.webkit &&
    window.webkit.messageHandlers &&
    window.webkit.messageHandlers.gameCenter
  ) {
    timerElem.textContent = "Speichere Daten in GameCenter...";
    setTimeout(() => {
      startRealPauseCountdown(); // Startet den eigentlichen Countdown
    }, 2000);
    return;
  }
  
      stopMetronome();
      sessionPaused = true;
      sessionCount++;
      const hitRate = totalAttempts > 0 ? (correctAnswers / totalAttempts) : 1;
      pauseRemaining = Math.floor(calculateAdaptiveBreakTime(responseTimes, hitRate) * 2 + 300);
      pauseDuration = pauseRemaining;

      const unlockedTrophies = JSON.parse(localStorage.getItem("unlockedTrophies") || "[]");
      const previousTrophies = JSON.parse(sessionStorage.getItem("previousUnlockedTrophies") || "[]");
      
      const justUnlocked = unlockedTrophies.filter(index => !previousTrophies.includes(index));
      const justLost = previousTrophies.filter(index => !unlockedTrophies.includes(index));
      
      sessionStorage.setItem("justUnlockedTrophies", JSON.stringify(justUnlocked));
      sessionStorage.setItem("justLostTrophies", JSON.stringify(justLost));
      sessionStorage.setItem("previousUnlockedTrophies", JSON.stringify(unlockedTrophies));
      
      const pauseOverlay = document.getElementById("pauseOverlay");
      pauseOverlay.innerHTML = `
          <div id="pauseInfo">
            <div id="pauseHeader">SESSION PAUSIERT</div>
            <div id="pauseProgressContainer">
              <div id="pauseProgress"></div>
              <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
            </div>
          </div>
          <div id="pauseTiles"></div>
        `;
      document.getElementById("mainContent").style.display = "none";
      document.getElementById("timerContainer").style.display = "none";
      document.getElementById("settingsPanel").style.display = "none";
      pauseOverlay.style.display = "flex";
      confetti({
        particleCount: 150,
        spread: 70,
        origin: { x: 0.5, y: 0.5 }
      });
      updatePauseProgress();
      updatePauseTiles();
      const msgInterval = setInterval(() => { updatePauseTiles(); }, 3000);
      pauseInterval = setInterval(() => {
        pauseRemaining--;
        updatePauseProgress();
        if (pauseRemaining <= 0) {
          clearInterval(pauseInterval);
          clearInterval(msgInterval);
          endPause();
        }
      }, 1000);
    };
      
      // Erstelle ein Audio-Objekt für den Gong
      const gongSound = new Audio("https://raw.githubusercontent.com/JP0024/piano.github.io/main/gong-2-232435.mp3");
      
      // In deiner Funktion, die das Pausenfenster beendet, rufe den Sound ab:
      const endPause = () => {
        document.getElementById("pauseOverlay").style.display = "none";
        document.getElementById("mainContent").style.display = "block";
        document.getElementById("timerContainer").style.display = "flex";
        document.getElementById("settingsPanel").style.display = "flex";
        sessionPaused = false;
        // Setze den Sound zurück und spiele ihn ab
        gongSound.currentTime = 0;
        gongSound.play();
        resetGame();
      };
    let gameOver = false;
    const endGame = () => {
      gameOver = true;
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      gameOverOverlay.textContent = "Game Over!";
      gameOverOverlay.style.display = "block";
      if (!scoreRecorded) recordScore();
      setTimeout(resetGame, 5000);
    };
    const recordScore = () => {
      if (totalAttempts <= 0) return;
      const durationMs = Date.now() - appStartTime;
      const secondsTotal = Math.floor(durationMs / 1000);
      const minutes = Math.floor(secondsTotal / 60);
      const seconds = secondsTotal % 60;
      const durationStr = (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
      const accuracy = Math.round((correctAnswers / totalAttempts) * 100);
      const now = new Date();
      let dd = now.getDate();
      let mm = now.getMonth() + 1;
      dd = dd < 10 ? "0" + dd : dd;
      mm = mm < 10 ? "0" + mm : mm;
      const dateStr = dd + "." + mm;
      const scoreObj = { date: dateStr, accuracy: accuracy, duration: durationStr, seconds: secondsTotal, mode: randomMode ? "random" : selectedMode };
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      highScores.push(scoreObj);
      highScores.sort((a, b) => (b.accuracy !== a.accuracy ? b.accuracy - a.accuracy : a.seconds - b.seconds));
      highScores = highScores.slice(0, 5);
      localStorage.setItem("highScores", JSON.stringify(highScores));
      scoreRecorded = true;
    };
    const updateScoreboard = () => {
      const allScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const filtered = allScores.filter(score => score.mode === (randomMode ? "random" : selectedMode));
      let html = "HIGHSCORES (" + (randomMode ? "random" : selectedMode) + ")\n";
      filtered.forEach((score, index) => {
        html += (index + 1) + ". " + score.date + " \t " + score.accuracy + "% " + score.duration + "\n";
      });
      document.getElementById("scoreboardOverlay").textContent = html;
    };
    const toggleScoreboard = () => {
      const overlay = document.getElementById("scoreboardOverlay");
      overlay.classList.toggle("hidden");
      if (!overlay.classList.contains("hidden")) updateScoreboard();
    };
    const autoSelectMode = () => {
      let highScores = JSON.parse(localStorage.getItem("highScores") || "[]");
      const leftScores = highScores.filter(score => score.mode === "left");
      const rightScores = highScores.filter(score => score.mode === "right");
      const bestLeft = leftScores.length ? Math.max(...leftScores.map(s => s.accuracy)) : 0;
      const bestRight = rightScores.length ? Math.max(...rightScores.map(s => s.accuracy)) : 0;
      if (bestLeft < bestRight) {
        selectedMode = "left";
        currentHandIndex = 0;
      } else {
        selectedMode = "left";
        currentHandIndex = 0;
      }
      const handToggle = document.getElementById("handToggle");
      if (handToggle) {
        handToggle.textContent = handOptions[currentHandIndex].symbol;
        handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      }
    };
    const cycleRange = () => {
      window.customModeSettings = null;
      currentRangeIndex = (currentRangeIndex + 1) % rangeArray.length;
      currentRange = rangeArray[currentRangeIndex];
      document.getElementById("clefTitle").textContent = currentRange + "-Lage";
      generateSeries();
      updateHeartsDisplay();
    };
    const toggleDarkMode = () => {
      document.body.classList.toggle("dark-mode");
    };
    // Passive Listener für Touch-Events in setupFadeOnHover
    const setupFadeOnHover = (element) => {
      element.addEventListener("mouseenter", () => element.classList.remove("faded"));
      element.addEventListener("mouseleave", () => element.classList.add("faded"));
      element.addEventListener("touchstart", () => element.classList.remove("faded"), {passive: true});
      element.addEventListener("touchend", () => element.classList.add("faded"), {passive: true});
    };
    let redrawQueued = false;
    const queueRedraw = () => {
      if (!redrawQueued) {
        redrawQueued = true;
        requestAnimationFrame(() => {
          drawSeries();
          redrawQueued = false;
        });
      }
    };
    /* Animation (Hintergrund-Kreise) */
    let blobsEnabled = true;
    let circles = [];
    const gradients = {
      "green": ["rgba(0,255,0,1)", "rgba(0,255,0,0.3)", "rgba(255,255,255,0)"],
      "blue": ["rgba(0,0,255,1)", "rgba(0,0,255,0.3)", "rgba(255,255,255,0)"],
      "pink": ["rgba(255,105,180,1)", "rgba(255,105,180,0.3)", "rgba(255,255,255,0)"],
      "yellow": ["rgba(255,255,0,1)", "rgba(255,255,0,0.3)", "rgba(255,255,255,0)"],
      "red": ["rgba(255,0,0,1)", "rgba(255,0,0,0.3)", "rgba(255,255,255,0)"],
      "violet": ["rgba(238,130,238,1)", "rgba(238,130,238,0.3)", "rgba(255,255,255,0)"],
      "gray": ["rgba(128,128,128,1)", "rgba(128,128,128,0.3)", "rgba(255,255,255,0)"],
      "black": ["rgba(0,0,0,1)", "rgba(0,0,0,0.3)", "rgba(255,255,255,0)"]
    };
    const positiveColors = ["green", "blue", "pink", "yellow"];
    const negativeColors = ["orange", "violet", "crimson"];
    function addCircle(type) {
      if (!blobsEnabled) return;
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = type === "positive" ? positiveColors : negativeColors;
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
    }
    /* Intro-Animation */
    function spawnIntroBlobs() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const positions = [
        { x: cw - 500, y: 100 },
        { x: cw - 30, y: ch - 30 },
        { x: 50, y: ch / 2 }
      ];
      const colors = ["yellow", "pink", "blue"];
      positions.forEach((pos, index) => {
        const targetRadius = Math.random() * 1000 + 1000;
        const duration = 5000;
        circles.push({
          x: pos.x,
          y: pos.y,
          initialRadius: targetRadius,
          radius: targetRadius,
          color: colors[index % colors.length],
          creationTime: Date.now(),
          duration: duration
        });
      });
    }
    function animateCircles() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const now = Date.now();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      circles = circles.filter(circle => {
        const t = now - circle.creationTime;
        if (t >= circle.duration) return false;
        let opacity = 0;
        if (t < 500) { opacity = t / 500; }
        else if (t < 1500) { opacity = 1; }
        else { opacity = (circle.duration - t) / 500; }
        let currentRadius = circle.radius;
        const gradColors = gradients[circle.color] || [circle.color, circle.color, "rgba(255,255,255,0)"];
        const grad = ctx.createRadialGradient(circle.x, circle.y, 0, circle.x, circle.y, currentRadius);
        grad.addColorStop(0, gradColors[0]);
        grad.addColorStop(0.7, gradColors[1]);
        grad.addColorStop(1, gradColors[2]);
        ctx.globalAlpha = opacity;
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, currentRadius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.globalAlpha = 1;
        return true;
      });
      requestAnimationFrame(animateCircles);
    }
    function resetInactivityTimer() {
      if (inactivityTimeout) clearTimeout(inactivityTimeout);
      inactivityTimeout = setTimeout(spawnInactivityBlob, 180000);
    }
    function spawnInactivityBlob() {
      const canvas = document.getElementById("animationCanvas");
      if (!canvas) return;
      const cw = canvas.width, ch = canvas.height;
      const margin = 10;
      const x = Math.random() * (cw - 2 * margin) + margin;
      const y = Math.random() * (ch - 2 * margin) + margin;
      const radius = Math.random() * 1000 + 800;
      const colors = ["green", "blue", "pink", "yellow"];
      const colorName = colors[Math.floor(Math.random() * colors.length)];
      const creationTime = Date.now();
      const duration = 2000;
      circles.push({ x, y, radius, color: colorName, creationTime, duration });
      resetInactivityTimer();
    }
    document.addEventListener("DOMContentLoaded", () => {
      let canvas = document.getElementById("animationCanvas");
      // --- Apply saved notation position from localStorage ---
      const savedTransform = localStorage.getItem("notationTransform");
      if (savedTransform) {
        const notation = document.getElementById("notation");
        if (notation) {
          notation.style.position = "fixed";
          notation.style.top = "50%";
          notation.style.left = "50%";
          notation.style.transform = savedTransform;
        }
      }
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = "animationCanvas";
        document.body.appendChild(canvas);
      }
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      animateCircles();
      resetInactivityTimer();
      const storedName = localStorage.getItem("userName");
      const welcomeMessage = document.getElementById("welcomeMessage");
      const hour = new Date().getHours();
      let greeting;
      if (hour >= 6 && hour < 12) {
        greeting = "Guten Morgen";
      } else if (hour >= 12 && hour < 17) {
        greeting = "Guten Tag";
      } else {
        greeting = "Guten Abend";
      }

      if (storedName !== null) {
        welcomeMessage.innerHTML = `${greeting}, ${storedName || ""}<br> Willkommen zurück.<br>`;
        welcomeMessage.style.cursor = "pointer";
        welcomeMessage.addEventListener("click", () => {
          const storedName = localStorage.getItem("userName");
          if (storedName !== null) {
            const nameOverlay = document.createElement("div");
            nameOverlay.id = "nameOverlay";
            nameOverlay.style.position = "fixed";
            nameOverlay.style.top = "0";
            nameOverlay.style.left = "0";
            nameOverlay.style.width = "100%";
            nameOverlay.style.height = "100%";
            nameOverlay.style.backgroundColor = "rgba(255,255,255,0.95)";
            nameOverlay.style.display = "flex";
            nameOverlay.style.justifyContent = "center";
            nameOverlay.style.alignItems = "center";
            nameOverlay.style.zIndex = "9999";
            nameOverlay.style.pointerEvents = "auto";

            const modal = document.createElement("div");
            modal.style.background = "#fff";
            modal.style.padding = "20px";
            modal.style.border = "2px solid #000";
            modal.style.borderRadius = "10px";
            modal.style.textAlign = "center";

            const label = document.createElement("label");
            label.textContent = "Wie heißt du?";
            label.style.fontSize = "1.5em";

            const input = document.createElement("input");
            input.type = "text";
            input.value = storedName;
            input.style.display = "block";
            input.style.margin = "15px auto";
            input.style.fontSize = "1.2em";
            input.style.padding = "5px";
            input.style.pointerEvents = "auto";
            input.tabIndex = 0;
            // Prevent typing in name input from affecting the game
            input.addEventListener('keydown', e => e.stopPropagation());
            input.addEventListener('keyup',   e => e.stopPropagation());
            input.addEventListener('keypress',e => e.stopPropagation());
            input.addEventListener('input',   e => e.stopPropagation());

            const button = document.createElement("button");
            button.textContent = "Speichern";
            button.style.padding = "10px 20px";
            button.style.border = "2px solid #000";
            button.style.borderRadius = "5px";
            button.style.backgroundColor = "#fff";
            button.style.color = "#000";
            button.style.cursor = "pointer";

            const skip = document.createElement("button");
            skip.textContent = "Keinen Namen anzeigen";
            skip.style.padding = "10px 20px";
            skip.style.border = "2px solid #000";
            skip.style.borderRadius = "5px";
            skip.style.backgroundColor = "#fff";
            skip.style.color = "#000";
            skip.style.cursor = "pointer";

            button.addEventListener("click", () => {
              localStorage.setItem("userName", input.value.trim());
              document.body.removeChild(nameOverlay);
              location.reload();
            });

            skip.addEventListener("click", () => {
              localStorage.setItem("userName", "");
              document.body.removeChild(nameOverlay);
              location.reload();
            });

            modal.appendChild(label);
            modal.appendChild(input);
            modal.appendChild(button);
            modal.appendChild(skip);
            nameOverlay.appendChild(modal);
            document.body.appendChild(nameOverlay);
          }
        });
        welcomeMessage.style.fontSize = "2em";
        setTimeout(proceedToMainScreen, 5000);
      } else {
        document.getElementById("mainContent").style.opacity = "0";
        document.getElementById("timerContainer").style.opacity = "0";
        document.getElementById("settingsPanel").style.opacity = "0";

        const nameOverlay = document.createElement("div");
        nameOverlay.id = "nameOverlay";
        nameOverlay.style.position = "fixed";
        nameOverlay.style.top = "0";
        nameOverlay.style.left = "0";
        nameOverlay.style.width = "100%";
        nameOverlay.style.height = "100%";
        nameOverlay.style.backgroundColor = "rgba(255,255,255,0.95)";
        nameOverlay.style.display = "flex";
        nameOverlay.style.justifyContent = "center";
        nameOverlay.style.alignItems = "center";
        nameOverlay.style.zIndex = "9999";
        nameOverlay.style.pointerEvents = "auto";

        const modal = document.createElement("div");
        modal.style.background = "#fff";
        modal.style.padding = "20px";
        modal.style.border = "2px solid #000";
        modal.style.borderRadius = "10px";
        modal.style.textAlign = "center";

        const label = document.createElement("label");
        label.textContent = "Wie heißt du?";
        label.style.fontSize = "1.5em";

        const input = document.createElement("input");
        input.type = "text";
        input.style.display = "block";
        input.style.margin = "15px auto";
        input.style.fontSize = "1.2em";
        input.style.padding = "5px";
        input.style.pointerEvents = "auto";
        input.tabIndex = 0;
        // Prevent typing in name input from affecting the game
        input.addEventListener('keydown', e => e.stopPropagation());
        input.addEventListener('keyup',   e => e.stopPropagation());
        input.addEventListener('keypress',e => e.stopPropagation());
        input.addEventListener('input',   e => e.stopPropagation());

        const button = document.createElement("button");
        button.textContent = "Weiter";
        button.style.fontSize = "1em";
        button.style.marginRight = "10px";
        button.style.padding = "10px 20px";
        button.style.border = "none";
        button.style.borderRadius = "5px";
        button.style.backgroundColor = "#fff";
        button.style.color = "#000";
        button.style.border = "2px solid #000";
        button.disabled = true;
        button.style.opacity = "0.8";
        
        input.addEventListener("input", () => {
          const hasText = input.value.trim().length > 0;
          button.disabled = !hasText;
          button.style.opacity = hasText ? "1" : "0.8";
        });

        const skip = document.createElement("button");
        skip.textContent = "Keinen Namen angeben";
        skip.style.fontSize = "1em";
        skip.style.padding = "10px 20px";
        skip.style.border = "none";
        skip.style.borderRadius = "5px";
        skip.style.backgroundColor = "#fff";
        skip.style.color = "#000";
        skip.style.border = "2px solid #000";

        button.addEventListener("click", () => {
          localStorage.setItem("userName", input.value.trim());
          document.body.removeChild(nameOverlay);
          proceedToMainScreen();
          document.getElementById("mainContent").style.opacity = "1";
          document.getElementById("timerContainer").style.opacity = "1";
          document.getElementById("settingsPanel").style.opacity = "1";
        });

        skip.addEventListener("click", () => {
          localStorage.setItem("userName", "");
          document.body.removeChild(nameOverlay);
          proceedToMainScreen();
          document.getElementById("mainContent").style.opacity = "1";
          document.getElementById("timerContainer").style.opacity = "1";
          document.getElementById("settingsPanel").style.opacity = "1";
        });

        modal.appendChild(label);
        modal.appendChild(input);
        modal.appendChild(button);
        modal.appendChild(skip);
        nameOverlay.appendChild(modal);
        document.body.appendChild(nameOverlay);
      }
      
      const settingsPanel = document.getElementById("settingsPanel");
      // Handtoggle
      const handToggle = document.createElement("span");
      handToggle.id = "handToggle";
      handToggle.textContent = handOptions[currentHandIndex].symbol;
      handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
      settingsPanel.appendChild(handToggle);
      handToggle.addEventListener("click", () => {
        if (!randomMode) {
          currentHandIndex = (currentHandIndex + 1) % handOptions.length;
          selectedMode = handOptions[currentHandIndex].mode;
          handToggle.textContent = handOptions[currentHandIndex].symbol;
          handToggle.style.transform = handOptions[currentHandIndex].flip ? "scaleX(-1)" : "none";
          window.customModeSettings = null;
          generateSeries();
        }
      });
      // Randomtoggle
      const randomToggle = document.createElement("span");
      randomToggle.id = "randomToggle";
      randomToggle.textContent = "🐇";
      settingsPanel.appendChild(randomToggle);
      randomToggle.addEventListener("click", () => {
        randomMode = !randomMode;
        randomToggle.style.opacity = randomMode ? "1" : "0.5";
        generateSeries();
      });
      

      
      function showHomework() {
        let modal = document.getElementById("homeworkModal");
        if (!modal) {
          modal = document.createElement("div");
          modal.id = "homeworkModal";
          Object.assign(modal.style, {
            position: "fixed", top:"35%", right:"90px", width:"300px",
            background:"white", border:"2px solid black", borderRadius:"10px",
            padding:"20px", zIndex:"150"
          });
          document.body.appendChild(modal);
        }
        // Dynamisch Titel/Beschreibung wählen
        // Automatischer Scan bei leerer Hausaufgabe
        if (!homeworkData) {
          openCameraScan().then(code => {
            if (code && code.data) {
              try {
                homeworkData = JSON.parse(code.data);
                localStorage.setItem("homeworkData", JSON.stringify(homeworkData));
              } catch {
                alert("Ungültiger QR-Code");
              }
            }
            showHomework();
          }).catch(() => {
            // Scan abgebrochen oder Fehler – trotzdem das Modal anzeigen
            showHomework();
          });
          return;
        }
        const title = homeworkData?.HA || "Keine HA";
        const desc  = homeworkData?.Beschreibung || "";
        modal.innerHTML = `
          <h2>Hausaufgabe</h2>
          <p><strong>Titel:</strong> ${title}</p>
          <p><strong>Beschreibung:</strong> ${desc}</p>
          <button id="hwReceive">HA erhalten</button>
          <button id="hwSend">HA senden</button>
        `;
        // Button-Listener
        document.getElementById("hwReceive").addEventListener("click", () => {
          openCameraScan().then(code => {
            if (code && code.data) {
              try {
                homeworkData = JSON.parse(code.data);
                localStorage.setItem("homeworkData", JSON.stringify(homeworkData));
              } catch {
                alert("Ungültiger QR-Code");
              }
            }
            showHomework();
          });
        });
      // Overlay Camera Scan: openCameraScan implementation
      function openCameraScan() {
        return new Promise((resolve, reject) => {
          // Create overlay
          let scanOverlay = document.createElement("div");
          Object.assign(scanOverlay.style, {
            position: "fixed", top:"20%", left:"10%", width:"80%", height:"60%",
            background:"rgba(0,0,0,0.8)", display:"flex", alignItems:"center", justifyContent:"center", zIndex:"2000"
          });
          scanOverlay.id = "scanOverlay";
          // Create video element
          let video = document.createElement("video");
          video.setAttribute("autoplay", true);
          video.setAttribute("playsinline", true);
          video.style.width = "100%";
          video.style.height = "100%";
          video.style.objectFit = "cover";
          // Add close button
          let closeBtn = document.createElement("button");
          closeBtn.textContent = "Abbrechen";
          closeBtn.style.position = "absolute";
          closeBtn.style.top = "10px";
          closeBtn.style.right = "10px";
          closeBtn.style.zIndex = "2100";
          closeBtn.style.padding = "8px 16px";
          closeBtn.style.background = "white";
          closeBtn.style.border = "1px solid #000";
          closeBtn.style.borderRadius = "6px";
          closeBtn.style.cursor = "pointer";
          closeBtn.addEventListener("click", () => {
            if (video.srcObject) {
              video.srcObject.getTracks().forEach(track => track.stop());
            }
            document.body.removeChild(scanOverlay);
            reject(new Error("Scan cancelled"));
          });
          scanOverlay.appendChild(video);
          scanOverlay.appendChild(closeBtn);
          document.body.appendChild(scanOverlay);
          // Access camera
          navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then(stream => {
            video.srcObject = stream;
            // Use a QR scanner library or implement simple scanning
            // For now, simulate scan after 3 seconds
            // In real code, integrate a QR code library such as jsQR or html5-qrcode
            setTimeout(() => {
              // Stop camera
              stream.getTracks().forEach(track => track.stop());
              document.body.removeChild(scanOverlay);
              // Simulate a QR result object
              resolve({ data: '{"HA":"Beispiel","Beschreibung":"Test"}' });
            }, 3000);
          }).catch(err => {
            document.body.removeChild(scanOverlay);
            alert("Kamera konnte nicht geöffnet werden: " + err);
            reject(err);
          });
        });
      }
        document.getElementById("hwSend").addEventListener("click", () => {
          modal.innerHTML = `
            <h2>Hausaufgabe erstellen</h2>
            <label>Titel:<br><input id="newHA" value="${homeworkData?.HA||""}"></label><br>
            <label>Beschreibung:<br><textarea id="newDesc">${homeworkData?.Beschreibung||""}</textarea></label><br>
            <button id="generateQR">QR-Code erstellen</button>
          `;
          // Prevent HA input from affecting the notation/game
          const haInput = document.getElementById("newHA");
          const descInput = document.getElementById("newDesc");
          [haInput, descInput].forEach(el => {
            el.addEventListener('keydown', e => e.stopPropagation());
            el.addEventListener('keyup',   e => e.stopPropagation());
            el.addEventListener('keypress',e => e.stopPropagation());
            el.addEventListener('input',   e => e.stopPropagation());
          });
          document.getElementById("generateQR").addEventListener("click", () => {
            const obj = { HA: document.getElementById("newHA").value, Beschreibung: document.getElementById("newDesc").value };
            modal.innerHTML = `<div id="qrContainer"></div>`;
            new QRCode(document.getElementById("qrContainer"), { text: JSON.stringify(obj), width:200, height:200 });
            localStorage.setItem("homeworkData", JSON.stringify(obj));
          });
        });
      }

      // Called by Swift after scanning QR code
      function handleIncomingHomework() {
        console.log("🏠 Received homeworkData from Swift:", window.homeworkData);
        // Speichere es noch einmal ab – so verhält sich auch der Fallback-Mechanismus
        localStorage.setItem("homeworkData", JSON.stringify(window.homeworkData));
        // Öffne oder aktualisiere das Modal
        showHomework();
      }

      // 🧙🏼 Wizard-Modus Toggle im Karussell
      const wizardToggle = document.createElement("span");
      wizardToggle.id = "wizardToggle";
      wizardToggle.textContent = "🧙🏼";
      wizardToggle.style.cursor = "pointer";
      wizardToggle.style.opacity = "1";
      settingsPanel.appendChild(wizardToggle);
      let wizardMode = true;
      wizardToggle.addEventListener("click", () => {
        wizardMode = !wizardMode;
        wizardToggle.style.opacity = wizardMode ? "1" : "0.5";
      });
      
      const blobToggle = document.createElement("span");
      blobToggle.id = "blobToggle";
      blobToggle.textContent = "🔆";
      blobToggle.style.cursor = "pointer";
      settingsPanel.appendChild(blobToggle);

      blobToggle.addEventListener("click", () => {
        blobsEnabled = !blobsEnabled;
        blobToggle.textContent = blobsEnabled ? "🔆" : "🔅";
      });
      
      // Pausen-Button
      function blinkGreenBackground() {
        // Ursprüngliche Hintergrundfarbe speichern (falls gesetzt, sonst Standardwert)
        const originalBg = document.body.style.backgroundColor || "";
        // Setze den Hintergrund auf den bekannten Grünton
        document.body.style.backgroundColor = "LightBlue"; // hier den gewünschten Grünton anpassen
        // Nach 300 Millisekunden wieder zurücksetzen
        setTimeout(function() {
          document.body.style.backgroundColor = originalBg;
        }, 300);
      }
      
      pauseButton.addEventListener("click", () => {
        if (!sessionPaused) {
          saveStatistics();
          saveButtonEffect();
          console.log("Statistiken gespeichert und grüner Farbtupfer ausgelöst.");
        }
      });
      
      
      
      // Metronom-Ton (tick.mp3)
      const metronomeSound = new Audio('tick.mp3');
      // Metronom-Toggle
      // Metronom-Setup: Zustandsvariablen und Steuerfunktionen
      let metronomeOn = false;
      let metronomeInterval = 60000;         // Millisekunden pro Schlag, wird bei BPM-Änderung angepasst
      let lastTickTime = Date.now();         // Zeitstempel des letzten Metronom-Schlags
      let metronomeTimer;                    // Intervall-Timer für Metronom
      let metronomeTolerance = 0;            // Fehlertoleranz (wird noch gesetzt)

      // Startet das Metronom: aktualisiert lastTickTime bei jedem Schlag und spielt Ton ab
      function startMetronome() {
        if (metronomeTimer) clearInterval(metronomeTimer);
        metronomeOn = true;
        lastTickTime = Date.now();
        metronomeTimer = setInterval(() => {
          // Metronom-Ton abspielen
          metronomeSound.currentTime = 0;
          metronomeSound.play();
          lastTickTime = Date.now();
        }, metronomeInterval);
      }

      // Stoppt das Metronom
      function stopMetronome() {
        metronomeOn = false;
        if (metronomeTimer) {
          clearInterval(metronomeTimer);
          metronomeTimer = null;
        }
      }

      // Metronom-Container mit Emoji und BPM-Anzeige
      const metronomeContainer = document.createElement("div");
      metronomeContainer.style.display = "inline-block";
      metronomeContainer.style.textAlign = "center";
      settingsPanel.appendChild(metronomeContainer);

      const metronomeToggle = document.createElement("span");
      metronomeToggle.id = "metronomeToggle";
      metronomeToggle.textContent = "⏲️";
      metronomeToggle.style.opacity = "0.5";
      metronomeContainer.appendChild(metronomeToggle);

      const bpmDisplay = document.createElement("span");
      bpmDisplay.id = "bpmDisplay";
      bpmDisplay.style.display = "block";
      // const emojiWidth = metronomeToggle.getBoundingClientRect().width;
      bpmDisplay.style.fontSize = "14px"; // feste Schriftgröße, frei anpassbar
      bpmDisplay.style.fontWeight = "bold";
      bpmDisplay.textContent = metronomeBPM > 0 ? metronomeBPM + " BPM" : "";
      metronomeContainer.appendChild(bpmDisplay);
      bpmDisplay.addEventListener("click", () => {
        let existingInput = document.getElementById("bpmInput");
        if (!existingInput) {
          const input = document.createElement("input");
          input.id = "bpmInput";
          input.type = "number";
          input.min = "1";
          input.placeholder = metronomeBPM > 0 ? metronomeBPM : "";
          Object.assign(input.style, {
            backgroundColor: "white",
            border: "1px solid #000",
            width: "60px",
            fontSize: "1em",
            borderRadius: "5px",
            outline: "none",
            marginLeft: "5px"
          });
          metronomeContainer.appendChild(input);
          input.focus();
          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              const bpm = Number(input.value);
              if (bpm > 0) {
                metronomeBPM = bpm;
                metronomeInterval = 60000 / bpm;
                document.getElementById("bpmDisplay").textContent = metronomeBPM + " BPM";
                metronomeTolerance = metronomeInterval * 0.3;
                if (metronomeOn) startMetronome();
                startMetronome();
                metronomeToggle.style.opacity = "1";
                metronomeOn = true;
              }
              input.remove();
            }
          });
          input.addEventListener("blur", () => {
            input.remove();
          });
        }
      });
metronomeToggle.addEventListener("click", () => {
  if (metronomeOn) {
    stopMetronome();
    metronomeOn = false;
    metronomeToggle.style.opacity = "0.5";
    document.getElementById("bpmDisplay").textContent = "";
  } else {
    let existingInput = document.getElementById("bpmInput");
    if (!existingInput) {
      let input = document.createElement("input");
      input.id = "bpmInput";
      input.type = "number";
      input.min = "1";
      input.placeholder = metronomeBPM > 0 ? metronomeBPM : "";
      input.style.backgroundColor = "white";
      input.style.border = "1px solid #000";
      input.style.width = "60px";
      input.style.fontSize = "1em";
      input.style.borderRadius = "5px";
      input.style.outline = "none";
      input.style.marginLeft = "5px";

      metronomeToggle.parentElement.appendChild(input);
      input.focus();

      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const bpm = Number(input.value);
          if (bpm > 0) {
            metronomeBPM = bpm;
            metronomeInterval = 60000 / bpm;
            document.getElementById("bpmDisplay").textContent = metronomeBPM + " BPM";
            metronomeTolerance = metronomeInterval * 0.3;
            if (metronomeOn) startMetronome();
            startMetronome();
            metronomeToggle.style.opacity = "1";
            metronomeOn = true;
          }
          input.remove();
        }
      });

      input.addEventListener("blur", () => {
        input.remove();
      });
    }
  }
});

      const kidsModeToggle = document.createElement("span");
      kidsModeToggle.id = "kidsModeToggle";
      kidsModeToggle.textContent = "🐝";
      kidsModeToggle.style.cursor = "pointer";
      kidsModeToggle.style.opacity = "0.5";
      settingsPanel.appendChild(kidsModeToggle);

      kidsModeToggle.addEventListener("click", () => {
        kidsMode = !kidsMode;
        kidsModeToggle.style.opacity = kidsMode ? "1" : "0.5";
        drawSeries();
      });
      
      
      // Zeichne den Crayon-Button für Scale-Modus
      const customModeToggle = document.createElement("span");
      customModeToggle.id = "customModeToggle";
      customModeToggle.textContent = "🖍️";
      customModeToggle.style.cursor = "pointer";
      customModeToggle.style.marginTop = "10px";
      settingsPanel.appendChild(customModeToggle);
      // Buttons für Reset und Speichern im Scale-Modus
      const resetScaleBtn = document.createElement("span");
      resetScaleBtn.id = "resetScaleBtn";
      resetScaleBtn.textContent = "🔁";
      resetScaleBtn.style.cursor = "pointer";
      resetScaleBtn.style.display = "none";
      settingsPanel.appendChild(resetScaleBtn);
      resetScaleBtn.addEventListener("click", () => {
        // Reset selection mode and clear stored notes for this octave
        scaleSelectionMode = true;
        if (window.selectedNotesByOctave) {
          window.selectedNotesByOctave[selectedOctave] = [];
        }
        selectedNotes = [];
        // Entferne visuelle Selektion in der SVG
        document.querySelectorAll("svg g.vf-stavenote.selected").forEach(svgNote => {
          svgNote.classList.remove("selected");
          // Reset color to black
          svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
            shape.setAttribute('fill', 'black');
            shape.setAttribute('stroke', 'black');
          });
        });
        // Skala neu anzeigen
        generateScaleSeries(false);
      });
      
      
      const saveScaleBtn = document.createElement("span");
      saveScaleBtn.id = "saveScaleBtn";
      saveScaleBtn.textContent = "✅";
      saveScaleBtn.style.cursor = "pointer";
      saveScaleBtn.style.display = "none";
      settingsPanel.appendChild(saveScaleBtn);
      saveScaleBtn.addEventListener("click", () => {
        // Wechsle in Final-Phase und starte unendliche Serie
        scaleSelectionMode = false;
        resetScaleBtn.style.display = "none";
        saveScaleBtn.style.display = "none";
        // Merge all per-octave selections into global selectedNotes
        if (window.selectedNotesByOctave) {
          selectedNotes = [].concat(...Object.values(window.selectedNotesByOctave));
        }
        // Hide octave selector on save
        const sel = document.getElementById("scaleSelector");
        if (sel) sel.style.display = "none";
        generateScaleSeries(true);
      });

      // Oktavenauswahl-Container
      const scaleSelector = document.createElement("div");
      scaleSelector.id = "scaleSelector";
      scaleSelector.style.display = "none";
      scaleSelector.style.gap = "8px";
      settingsPanel.appendChild(scaleSelector);

      // Buttons für jede Oktave
      Object.keys(octaveOptions).forEach(label => {
        const btn = document.createElement("button");
        btn.textContent = label;
        btn.style.cursor = "pointer";
        btn.addEventListener("click", () => {
          // Setze Octave und passenden Clef: tiefe Oktaven links (Bass), hohe Oktaven rechts (Treble)
          selectedOctave = label;
          if (label === 'große Oktave' || label === 'kleine Oktave') {
            selectedClef = 'bass';
          } else {
            selectedClef = 'treble';
          }
          // Anzeige und Rendern aktualisieren
          const sel = document.getElementById("scaleSelector");
          if (sel) sel.style.display = "flex";
          generateScaleSeries(false);
        });
        scaleSelector.appendChild(btn);
      });

      customModeToggle.addEventListener("click", () => {
        // Toggle zwischen Auswahl- und Final-Phase im Scale-Modus
        if (!scaleSelectionMode) {
          // Auswahlphase starten
          selectedMode = "scale";
          scaleSelectionMode = true;
          sessionPaused = false;
          seriesCounter = 0;
          correctNoteCount = 0;
          // Timer anzeigen und aktualisieren
          document.getElementById("timerContainer").style.display = "flex";
          updateTimer();
          // Module ausblenden, Settings sichtbar
          const modeCarousel = document.getElementById("modeCarousel");
          if (modeCarousel) modeCarousel.style.display = "none";
          document.getElementById("settingsPanel").style.display = "flex";
          // Tonleiter zur Auswahl anzeigen
          generateScaleSeries(false);
          resetScaleBtn.style.display = "inline";
          saveScaleBtn.style.display = "inline";
          scaleSelector.style.display = "flex";
        } else {
          // Finalphase: fortlaufende Serie generieren
          scaleSelector.style.display = "none";
          scaleSelectionMode = false;
          generateScaleSeries(true);
          resetScaleBtn.style.display = "none";
          saveScaleBtn.style.display = "none";
        }
      });
      
      

      // Move Notation Toggle
      const moveNotationToggle = document.createElement("span");
      moveNotationToggle.id = "moveNotationToggle";
      moveNotationToggle.textContent = "📐";
      settingsPanel.appendChild(moveNotationToggle);

      let moveModeActive = false;
      let currentX = 0, currentY = 0; // Persist position for storage
      let startX = 0, startY = 0;
      let isDragging = false;
      let xGuide, yGuide, xLabel, yLabel;
      let duringDrag, endDrag; // For removal of listeners

      moveNotationToggle.addEventListener("click", () => {
        const notation = document.getElementById("notation");
        // Drag-Cursor für Notation
        notation.style.cursor = "grab";
        // Ensure startX, startY are declared only once at top-level
        if (!moveModeActive) {
          moveModeActive = true;
          // Show notation zoom controls in move mode
          zoomInBtn.style.display = 'inline';
          zoomOutBtn.style.display = 'inline';

          // --- Add dynamic guide lines with percentage labels ---
          xGuide = document.createElement("div");
          xGuide.style.position = "fixed";
          xGuide.style.top = "0";
          xGuide.style.height = "100%";
          xGuide.style.width = "1px";
          xGuide.style.background = "blue";
          xGuide.style.zIndex = "1999";
          xGuide.style.left = "50%";
          xGuide.style.transform = `translateX(${currentX}px)`;

          yGuide = document.createElement("div");
          yGuide.style.position = "fixed";
          yGuide.style.left = "0";
          yGuide.style.width = "100%";
          yGuide.style.height = "1px";
          yGuide.style.background = "blue";
          yGuide.style.zIndex = "1999";
          yGuide.style.top = "50%";
          yGuide.style.transform = `translateY(${currentY}px)`;

          xLabel = document.createElement("div");
          xLabel.style.position = "fixed";
          xLabel.style.top = "0";
          xLabel.style.left = `calc(50% + ${currentX}px + 5px)`;
          xLabel.style.color = "blue";
          xLabel.style.fontSize = "12px";
          xLabel.style.zIndex = "1999";
          xLabel.textContent = `${Math.round((currentX / window.innerWidth) * 100)}%`;

          yLabel = document.createElement("div");
          yLabel.style.position = "fixed";
          yLabel.style.left = "0";
          yLabel.style.top = `calc(50% + ${currentY}px + 5px)`;
          yLabel.style.color = "blue";
          yLabel.style.fontSize = "12px";
          yLabel.style.zIndex = "1999";
          yLabel.textContent = `${Math.round((currentY / window.innerHeight) * 100)}%`;

          document.body.appendChild(xGuide);
          document.body.appendChild(yGuide);
          document.body.appendChild(xLabel);
          document.body.appendChild(yLabel);

          // Save references for later removal
          window._notationGuides = [xGuide, yGuide, xLabel, yLabel];

          // --- Pointer-based drag functionality ---
          startX = 0;
          startY = 0;
          // Try to restore from localStorage if exists
          let saved = localStorage.getItem("notationTransform");
          if (saved && saved.includes("translate(-50%, -50%) translate(")) {
            // Try to extract px values
            let match = saved.match(/translate\(-50%, -50%\)\s*translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
            if (match) {
              currentX = parseFloat(match[1]);
              currentY = parseFloat(match[2]);
            }
          }
          xGuide.style.transform = `translateX(${currentX}px)`;
          yGuide.style.transform = `translateY(${currentY}px)`;
          xLabel.style.left = `calc(50% + ${currentX}px + 5px)`;
          xLabel.textContent = `${Math.round((currentX / window.innerWidth) * 100)}%`;
          yLabel.style.top = `calc(50% + ${currentY}px + 5px)`;
          yLabel.textContent = `${Math.round((currentY / window.innerHeight) * 100)}%`;
          notation.style.position = "fixed";
          notation.style.top = "50%";
          notation.style.left = "50%";
          notation.style.transform = `translate(-50%, -50%) translate(${currentX}px, ${currentY}px)`;

          // Drag logic
          const startDrag = (e) => {
            isDragging = true;
            notation.style.cursor = "grabbing";
            const evt = e.touches ? e.touches[0] : e;
            startX = evt.clientX;
            startY = evt.clientY;
            e.preventDefault();
          };
          duringDrag = (e) => {
            if (!isDragging) return;
            const evt = e.touches ? e.touches[0] : e;
            const dx = evt.clientX - startX;
            const dy = evt.clientY - startY;
            currentX += dx;
            currentY += dy;
            startX = evt.clientX;
            startY = evt.clientY;

            xGuide.style.transform = `translateX(${currentX}px)`;
            yGuide.style.transform = `translateY(${currentY}px)`;
            xLabel.style.left = `calc(50% + ${currentX}px + 5px)`;
            xLabel.textContent = `${Math.round((currentX / window.innerWidth) * 100)}%`;
            yLabel.style.top = `calc(50% + ${currentY}px + 5px)`;
            yLabel.textContent = `${Math.round((currentY / window.innerHeight) * 100)}%`;

            notation.style.position = "fixed";
            notation.style.top = "50%";
            notation.style.left = "50%";
            notation.style.transform = `translate(-50%, -50%) translate(${currentX}px, ${currentY}px)`;
          };
          endDrag = () => {
            isDragging = false;
            notation.style.cursor = "grab";
          };

          [xGuide, yGuide, xLabel, yLabel].forEach(el => {
            el.style.touchAction = "none";
            el.addEventListener("mousedown", startDrag);
            el.addEventListener("touchstart", startDrag);
          });
          // Erlaube Ziehen direkt am Notations-DIV
          notation.addEventListener("mousedown", startDrag);
          notation.addEventListener("touchstart", startDrag, { passive: false });
          window.addEventListener("mousemove", duringDrag);
          window.addEventListener("touchmove", duringDrag);
          window.addEventListener("mouseup", endDrag);
          window.addEventListener("touchend", endDrag);

        } else {
          moveModeActive = false;
          // Hide notation zoom controls when exiting move mode
          zoomInBtn.style.display = 'none';
          zoomOutBtn.style.display = 'none';
          // Persist the final position when move mode is disabled
          localStorage.setItem("notationTransform", `translate(-50%, -50%) translate(${currentX}px, ${currentY}px)`);
          // Store the final position and clean up listeners and guides
          if (window._notationGuides) {
            [xGuide, yGuide, xLabel, yLabel] = window._notationGuides;
            [xGuide, yGuide, xLabel, yLabel].forEach(el => {
              if (el && el.parentElement) el.parentElement.removeChild(el);
            });
            window._notationGuides = null;
          }
          window.removeEventListener("mousemove", duringDrag);
          window.removeEventListener("touchmove", duringDrag);
          window.removeEventListener("mouseup", endDrag);
          window.removeEventListener("touchend", endDrag);
        }
      });
      
document.getElementById("timerContainer").addEventListener("click", () => {
  let existingInput = document.getElementById("counterInput");
  if (!existingInput) {
    let timerContainer = document.getElementById("timerContainer");
    let input = document.createElement("input");
    input.id = "counterInput";
    input.type = "number";
    input.min = "1";
    input.placeholder = sessionCounter;
    input.value = sessionCounter;
    input.style.backgroundColor = "white";
    input.style.border = "1px solid #000";
      input.style.width = "150px";
      input.style.fontSize = "2em";
    input.style.textAlign = "center";
    input.style.borderRadius = "5px";
    input.style.outline = "none";

    timerContainer.innerHTML = "";
    timerContainer.appendChild(input);
    input.focus();

    let confirmed = false;

    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        confirmed = true;
        const num = parseInt(input.value, 10);
        if (!isNaN(num) && num > 0) {
          sessionCounter = num;
          localStorage.setItem("sessionCounter", sessionCounter);
          updateTimer();
          if (sessionCounter === 0 && !sessionPaused) {
            startPauseCountdown();
          }
        }
        timerContainer.innerHTML = sessionCounter;
      }
    });

    input.addEventListener("blur", () => {
      if (!confirmed) {
        input.focus(); // Bleibe im Feld, bis bestätigt
      }
    });
  }
});
      
      // DarkMode-Toggle
      const darkModeToggle = document.createElement("span");
      darkModeToggle.id = "darkModeToggle";
      darkModeToggle.textContent = "🌙";
      settingsPanel.appendChild(darkModeToggle);
      darkModeToggle.addEventListener("click", toggleDarkMode);

      // Animated carousel using a sliding track
      const carouselContainer = document.createElement('div');
      carouselContainer.id = 'carouselContainer';
      const carouselTrack = document.createElement('div');
      carouselTrack.id = 'carouselTrack';
      carouselContainer.appendChild(carouselTrack);
      settingsPanel.appendChild(carouselContainer);
      // Notation zoom controls
      let notationZoom = parseFloat(localStorage.getItem('notationZoom')) || 1;
      const zoomInBtn = document.createElement('span');
      zoomInBtn.id = 'notationZoomIn';
      zoomInBtn.textContent = '➕';
      zoomInBtn.style.cursor = 'pointer';
      settingsPanel.appendChild(zoomInBtn);
      const zoomOutBtn = document.createElement('span');
      zoomOutBtn.id = 'notationZoomOut';
      zoomOutBtn.textContent = '➖';
      zoomOutBtn.style.cursor = 'pointer';
      settingsPanel.appendChild(zoomOutBtn);
      // Hide zoom buttons by default
      zoomInBtn.style.display = 'none';
      zoomOutBtn.style.display = 'none';

      // Zoom factor handlers
      zoomInBtn.addEventListener('click', () => {
        notationZoom *= 1.1;
        localStorage.setItem('notationZoom', notationZoom);
        drawSeries();
      });
      zoomOutBtn.addEventListener('click', () => {
        notationZoom /= 1.1;
        localStorage.setItem('notationZoom', notationZoom);
        drawSeries();
      });
      // Füge den Tonleiter-Modus-Button direkt nach dem Karussell ein


      const carouselButtons = [pauseButton, blobToggle, kidsModeToggle, darkModeToggle, moveNotationToggle, wizardToggle];
      carouselButtons.forEach(btn => {
        const item = document.createElement('div');
        item.className = 'carouselItem';
        item.appendChild(btn);
        carouselTrack.appendChild(item);
      });
      let currentIndex = 0;
      function updateCarousel() {
        carouselTrack.style.transform = `translateX(-${currentIndex * 100}%)`;
      }
      updateCarousel();
      carouselContainer.addEventListener('touchstart', e => {
        startX = e.touches[0].clientX;
      });
      carouselContainer.addEventListener('touchend', e => {
        const endX = e.changedTouches[0].clientX;
        if (startX !== null) {
          const deltaX = endX - startX;
          if (deltaX < -30) {
            currentIndex = (currentIndex + 1) % carouselButtons.length;
          } else if (deltaX > 30) {
            currentIndex = (currentIndex - 1 + carouselButtons.length) % carouselButtons.length;
          }
          updateCarousel();
        }
        startX = null;
      });

      // Speech bubble hint for carousel, only once
      if (!localStorage.getItem('carouselHintShown')) {
        const bubble = document.createElement('div');
        bubble.className = 'speech-bubble';
        bubble.innerHTML = '<span class="close-btn">×</span>Wische hier, um weitere Funktionen zu sehen!';
        document.body.appendChild(bubble);
        const pauseBtn = document.getElementById('pauseButton');
        if (pauseBtn) {
          // Wait one frame so bubble has its dimensions
          requestAnimationFrame(() => {
            const rect = pauseBtn.getBoundingClientRect();
            const bubbleRect = bubble.getBoundingClientRect();
            bubble.style.top = `${rect.top - bubbleRect.height - 10}px`;
            bubble.style.left = `${rect.left + (rect.width - bubbleRect.width) / 2}px`;
          });
        }
        bubble.querySelector('.close-btn').addEventListener('click', () => {
          localStorage.setItem('carouselHintShown', 'true');
          bubble.remove();
        });
      }
      // Scoreboard-Toggle

      // --- BEGIN: Pencil Mode / Custom Scale Mode Toggle Opacity Logic ---
      // Suche nach dem Toggle für Pencil Mode (benutzerdefinierte Skala)
 

      autoSelectMode();
      generateSeries();

      updateHeartsDisplay();
      document.addEventListener("keydown", (event) => {
        if (event.code === "Space") { handleMIDIMessage(144, 60, 127); }
      });


    });
                  
let melodyContext = {
  lastNote: null,
  direction: 1, // 1 = aufwärts, -1 = abwärts
  scale: ["c", "d", "e", "f", "g", "a", "b"], // C-Dur
};
// Stelle sicher, dass selectedClef global initialisiert ist
selectedClef = "treble";
let notesInCurrentPhase = 0;

// Extrahierte Funktion für den Tonleiter-Modus
function generateScaleSeries(isFinal = false) {
  // Reset counters
  seriesCounter = 0;
  correctNoteCount = 0;
  // Always show full octave in selection phase
  const defaultScaleNotes = octaveOptions[selectedOctave] || [];
  if (!isFinal) {
    // Selection-mode: render all notes of the current octave
    currentSeriesSingle = defaultScaleNotes.map(s => {
      const [, n, o] = s.match(/^([A-G])(\d)$/);
      return { note: n.toLowerCase(), octave: parseInt(o, 10), clef: selectedClef, color: 'black' };
    });
    drawSeries();
    return;
  }
  // Final-mode: build infinite series from the explicit clicks, per-octave.
  let notesToUse;
  // Use per-octave clicked notes if any, otherwise default octave notes
  const stored = (window.selectedNotesByOctave && window.selectedNotesByOctave[selectedOctave]) || [];
  if (stored.length > 0) {
    notesToUse = stored.map(pitch => {
      const [n, o] = pitch.split("/");
      return { note: n.toLowerCase(), octave: parseInt(o, 10) };
    });
  } else {
    notesToUse = defaultScaleNotes.map(s => {
      const [, n, o] = s.match(/^([A-G])(\d)$/);
      return { note: n.toLowerCase(), octave: parseInt(o, 10) };
    });
  }
  currentSeriesSingle = [];
  for (let i = 0; i < seriesLength; i++) {
    const { note, octave } = notesToUse[i % notesToUse.length];
    currentSeriesSingle.push({ note, octave, clef: selectedClef, color: 'black' });
  }
  drawSeries();
}

const generateSeries = () => {
  if (selectedMode === "scale") {
    generateScaleSeries();
    return;
  }
  seriesCounter = 0;
  correctNoteCount = 0;
  // --- Manuelle Notenauswahl aus UI berücksichtigen ---
  const noteSelectorElements = document.querySelectorAll("#noteSelector .selectable-note.selected");
  const manuallySelectedNotes = Array.from(noteSelectorElements).map(el => el.textContent.toLowerCase());
  nextMotivationThreshold = getRandomThreshold();
  document.getElementById("noteNameDisplay").textContent = "";

  // Einhandmodus: customNoteSeries bevorzugen, sonst fallback
  if (selectedMode === "left" || selectedMode === "right") {
    if (typeof customNoteSeries !== "undefined" && customNoteSeries.length > 0) {
      currentSeriesSingle = customNoteSeries.slice();
    } else {
      // Fallback: Standardgenerierung für Einhandmodus
      function generateRandomSeries() {
        let handClef = selectedMode === "left" ? "bass" : "treble";
        let defaultNotes;
        if (currentRange === "MC") {
          defaultNotes = handClef === "bass"
            ? ["f", "g", "a", "b", "c"]
            : ["c", "d", "e", "f", "g"];
        } else if (currentRange === "D") {
          defaultNotes = ["d", "e", "f#", "g", "a"];
        } else if (currentRange === "F") {
          defaultNotes = ["f", "g", "a", "bb", "c"];
        } else {
          defaultNotes = rangeNotes[currentRange];
        }
        let arr = [];
        for (let i = 0; i < seriesLength; i++) {
          const randomIndex = Math.floor(Math.random() * defaultNotes.length);
          const chosenNote = defaultNotes[randomIndex];
          let noteOctave = handClef === "bass" ? 3 : 4;
          if (currentRange === "F" && handClef === "treble" && chosenNote.toLowerCase() === "c") {
            noteOctave = 5;
          }
          let accidental = undefined;
          if (["F", "G"].includes(currentRange)) {
            if (currentRange === "F" && chosenNote.toLowerCase() === "bb") {
              accidental = "b";
            } else if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
              accidental = chosenNote;
            } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
              accidental = chosenNote;
            }
          }
          arr.push({ note: chosenNote, octave: noteOctave, clef: handClef, color: "black", accidental: accidental });
        }
        return arr;
      }
      currentSeriesSingle = generateRandomSeries();
    }
    seriesCounter = 0;
    correctNoteCount = 0;
    drawSeries();
    return;
  }

  let seriesClef, chooseNote;
  // Prüfe, ob benutzerdefinierte Einstellungen aktiv sind
  if (window.customModeSettings && window.customModeSettings.clef && window.customModeSettings.range) {
    // Verwende die benutzerdefinierten Einstellungen
    seriesClef = window.customModeSettings.clef; // z.B. 'treble' oder 'bass'
    currentRange = window.customModeSettings.range; // Aktualisiere die globale Lage
    // Wähle die Noten basierend auf der ausgewählten Hand (left/right)
    let customNotes = (selectedMode === "left") ? window.customModeSettings.leftNotes : window.customModeSettings.rightNotes;
    // Fallback, falls keine Noten ausgewählt wurden
    if (!customNotes || customNotes.length === 0) {
      if (currentRange === "MC") {
        customNotes = seriesClef === "bass"
          ? ["f", "g", "a", "b", "c"]
          : ["c", "d", "e", "f", "g"];
      } else if (currentRange === "D") {
        customNotes = ["d", "e", "f#", "g", "a"];
      } else if (currentRange === "F") {
        customNotes = ["f", "g", "a", "bb", "c"];
      } else {
        customNotes = rangeNotes[currentRange];
      }
    }
    // --- Effektive Noten bestimmen: manuelle Auswahl hat Vorrang ---
    let effectiveNotes;
    if (manuallySelectedNotes.length > 0) {
      effectiveNotes = manuallySelectedNotes;
    } else {
      effectiveNotes = customNotes;
    }
    chooseNote = () => {
      if (errorNotes.length > 0 && Math.random() < 0.6) {
        const idx = errorNotes.findIndex(note => note.clef === seriesClef);
        if (idx !== -1) {
          return errorNotes.splice(idx, 1)[0];
        }
      }
      const randomIndex = Math.floor(Math.random() * effectiveNotes.length);
      const chosenNote = effectiveNotes[randomIndex];
      let noteOctave = seriesClef === "bass" ? 3 : 4;
      // F-Lage: ensure C is one octave higher in treble clef
      if (currentRange === "F" && seriesClef === "treble" && chosenNote.toLowerCase() === "c") {
        noteOctave = 5;
      }
      let accidental = undefined;
      if (["F", "G"].includes(currentRange)) {
        if (currentRange === "F" && chosenNote.toLowerCase() === "bb") {
          accidental = "b";
        } else if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
          accidental = chosenNote;
        } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
          accidental = chosenNote;
        }
      }
      return { note: chosenNote, octave: noteOctave, clef: seriesClef, color: "black", accidental: accidental };
    };

  } else {
    // Bestehendes Verhalten, wenn kein Custom Mode aktiv ist
    if (randomMode) {
      seriesClef = Math.random() < 0.5 ? "bass" : "treble";
      notesInCurrentPhase += seriesLength;
      if (notesInCurrentPhase >= 20) {
        let oldRange = currentRange;
        if (typeof alternatingRanges !== 'undefined' && alternatingRanges.length > 0) {
          currentRange = alternatingRanges[Math.floor(Math.random() * alternatingRanges.length)];
        }
        if (oldRange !== currentRange) {
          gongSound.currentTime = 0;
          gongSound.play();
          var clefTitle = document.getElementById("clefTitle");
          clefTitle.textContent = currentRange + "-Lage";
          clefTitle.style.border = "3px solid red";
          setTimeout(() => {
            if (document.body.classList.contains("dark-mode")) {
              clefTitle.style.border = "3px solid #fff";
            } else {
              clefTitle.style.border = "3px solid #000";
            }
          }, 300);
        }
        notesInCurrentPhase = 0;
      }
    } else {
      seriesClef = (selectedMode === "left") ? "bass" : "treble";
    }
    chooseNote = () => {
      if (errorNotes.length > 0 && Math.random() < 0.6) {
        const idx = errorNotes.findIndex(note => note.clef === seriesClef);
        if (idx !== -1) {
          return errorNotes.splice(idx, 1)[0];
        }
      }
      let defaultNotes;
      if (currentRange === "MC") {
        defaultNotes = seriesClef === "bass"
          ? ["f", "g", "a", "b", "c"]
          : ["c", "d", "e", "f", "g"];
      } else if (currentRange === "D") {
        defaultNotes = ["d", "e", "f#", "g", "a"];
      } else if (currentRange === "F") {
        defaultNotes = ["f", "g", "a", "bb", "c"];
      } else {
        defaultNotes = rangeNotes[currentRange];
      }
      // --- Effektive Noten bestimmen: manuelle Auswahl hat Vorrang ---
      let effectiveNotes;
      if (manuallySelectedNotes.length > 0) {
        effectiveNotes = manuallySelectedNotes;
      } else {
        effectiveNotes = defaultNotes;
      }
      const randomIndex = Math.floor(Math.random() * effectiveNotes.length);
      const chosenNote = effectiveNotes[randomIndex];
      let noteOctave = seriesClef === "bass" ? 3 : 4;
      // F-Lage: ensure C is one octave higher in treble clef
      if (currentRange === "F" && seriesClef === "treble" && chosenNote.toLowerCase() === "c") {
        noteOctave = 5;
      }
      let accidental = undefined;
      if (["F", "G"].includes(currentRange)) {
        if (currentRange === "F" && chosenNote.toLowerCase() === "bb") {
          accidental = "b";
        } else if (currentRange === "F" && chosenNote.includes("b") && chosenNote !== "b") {
          accidental = chosenNote;
        } else if (currentRange === "G" && (chosenNote.includes("#") || (chosenNote.includes("b") && chosenNote !== "b"))) {
          accidental = chosenNote;
        }
      }
      return { note: chosenNote, octave: noteOctave, clef: seriesClef, color: "black", accidental: accidental };
    };
  }

  currentSeriesSingle = [];
  for (let i = 0; i < seriesLength; i++) {
    currentSeriesSingle.push(chooseNote());
  }
  drawSeries();
};
                                            
selectedNotes = [];
let scaleSelectionMode = false; // Flag für Scale-Auswahl-Phase
// Oktaven-Definitionen
const octaveOptions = {
  'große Oktave':       ['C2','D2','E2','F2','G2','A2','B2','C3'],
  'kleine Oktave':      ['C3','D3','E3','F3','G3','A3','B3','C4'],
  'eingestrichene Oktave': ['C4','D4','E4','F4','G4','A4','B4','C5'],
  'zweigestrichene Oktave': ['C5','D5','E5','F5','G5','A5','B5','C6']
};
let selectedOctave = 'große Oktave';
const drawSeries = () => {
  // Debug: Log clef context to diagnose undefined issues
  console.log("drawSeries() context:", { selectedMode, selectedClef, firstClef: currentSeriesSingle?.[0]?.clef });
  const noteAnimals = {
    "c": "🐱", "d": "🐳", "e": "🐷", "f": "🐟",
    "g": "🐤", "a": "🦊", "b": "🐝", "bb": "🦁",
    "f#": "🐙", "g#": "🐵", "d#": "🐭"
  };

  const notationDiv = document.getElementById("notation");
  const baseWidth = 600;
  const ratio = window.devicePixelRatio || 1;
  const height = 300 * ratio;
  notationDiv.style.display = "block";
  notationDiv.innerHTML = "";

  const renderer = new Vex.Flow.Renderer(notationDiv, Vex.Flow.Renderer.Backends.SVG);
  const baseZoom = 1.4;
  const userZoom = parseFloat(localStorage.getItem('notationZoom')) || 1;
  const zoomFactor = baseZoom * userZoom;
  renderer.resize(baseWidth * ratio * zoomFactor, height * zoomFactor);

  const svg = notationDiv.querySelector("svg");
  if (svg) {
    svg.setAttribute("width", baseWidth * zoomFactor);
    svg.setAttribute("height", 100 * zoomFactor);
    svg.style.transform = `scale(${zoomFactor})`;
    svg.style.transformOrigin = "top left";
  }

  const context = renderer.getContext();
  // Bestimme Clef, mit Fallback auf 'treble' bei ungültigem Wert
  const stave = new Vex.Flow.Stave(10, 40, baseWidth - 20);
  let clefToUse = (selectedMode === "scale")
    ? selectedClef
    : (currentSeriesSingle && currentSeriesSingle.length > 0)
      ? currentSeriesSingle[0].clef
      : selectedClef;
  // Validiere Clef ohne Absturz, benutze statische Liste als Fallback
  let availableClefs = ['treble', 'bass', 'alto', 'tenor'];
  if (Vex.Flow.Tables && typeof Vex.Flow.Tables.currentGlyphs === 'function') {
    const glyphs = Vex.Flow.Tables.currentGlyphs();
    if (glyphs && glyphs.clef) {
      availableClefs = Object.keys(glyphs.clef);
    }
  }
  if (!clefToUse || !availableClefs.includes(clefToUse)) {
    console.warn(`Ungültiger Clef '${clefToUse}', setze Fallback auf 'treble'`);
    clefToUse = 'treble';
  }
  stave.addClef(clefToUse);

  if (currentRange === "D") stave.addKeySignature("G");
  else if (currentRange === "F") stave.addKeySignature("F");
  else if (currentRange === "G") stave.addKeySignature("G");

  stave.setContext(context).draw();

  const noteDuration = (window.customModeSettings && window.customModeSettings.noteValue === "8") ? "8" : "q";
  const noteOrder = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"];

  const staveNotes = currentSeriesSingle.map(item => {
    let noteName = item.note.toLowerCase().replace(/♯/g, "#").replace(/♭/g, "b");
    const key = noteName + "/" + item.octave;
    const staveNote = new Vex.Flow.StaveNote({
      clef: item.clef,
      keys: [key],
      duration: noteDuration
      
    });

    staveNote.setStyle({ fillStyle: item.color, strokeStyle: item.color });

    const noteIndex = noteOrder.indexOf(noteName);
    const midiNumber = (item.octave + 1) * 12 + noteIndex;
    const threshold = item.clef === "bass" ? 50 : 71;
    staveNote.setStemDirection(midiNumber >= threshold ? -1 : 1);

    return staveNote;
  });

  const voice = new Vex.Flow.Voice({ num_beats: seriesLength, beat_value: 4 });
  voice.setStrict(false);
  staveNotes.forEach(note => voice.addTickable(note));
  new Vex.Flow.Formatter().joinVoices([voice]).format([voice], stave.getWidth() - 20);
  voice.draw(context, stave);

  // Interaktive Noten im Scale-Modus mit per-Oktave Speicherung
  if (selectedMode === "scale" && scaleSelectionMode) {
    const noteElements = document.querySelectorAll("svg g.vf-stavenote");
    // Ensure storage exists
    if (!window.selectedNotesByOctave) window.selectedNotesByOctave = {};
    if (!window.selectedNotesByOctave[selectedOctave]) {
      window.selectedNotesByOctave[selectedOctave] = [];
    }
    let selectedNotesByOctave = window.selectedNotesByOctave;
    noteElements.forEach((svgNote, idx) => {
      svgNote.style.cursor = "pointer";
      const pitch = `${currentSeriesSingle[idx].note}/${currentSeriesSingle[idx].octave}`;
      svgNote.dataset.pitch = pitch;
      const selArr = selectedNotesByOctave[selectedOctave];
      // Restore visual state
      if (selArr.includes(pitch)) {
        svgNote.classList.add("selected");
        svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
          shape.setAttribute('fill', 'green');
          shape.setAttribute('stroke', 'green');
        });
      } else {
        svgNote.classList.remove("selected");
        svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
          shape.setAttribute('fill', 'black');
          shape.setAttribute('stroke', 'black');
        });
      }
      // Toggle on click
      svgNote.onclick = () => {
        const arr = selectedNotesByOctave[selectedOctave];
        if (arr.includes(pitch)) {
          selectedNotesByOctave[selectedOctave] = arr.filter(n => n !== pitch);
          svgNote.classList.remove("selected");
          svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
            shape.setAttribute('fill', 'black');
            shape.setAttribute('stroke', 'black');
          });
        } else {
          arr.push(pitch);
          svgNote.classList.add("selected");
          svgNote.querySelectorAll('path, circle, ellipse').forEach(shape => {
            shape.setAttribute('fill', 'green');
            shape.setAttribute('stroke', 'green');
          });
        }
      };
    });
  }

  // 🐝 Kinder-Modus: Emojis auf die Notenköpfe setzen
  if (kidsMode) {
    const svg = notationDiv.querySelector("svg");
    if (!svg) return;

    svg.querySelectorAll(".note-emoji").forEach(el => el.remove());

    staveNotes.forEach((note, index) => {
      const coords = note.getModifierStartXY(Vex.Flow.Modifier.Position.LEFT, 0);
      const emoji = noteAnimals[currentSeriesSingle[index].note.toLowerCase()] || "❓";
      const centerX = coords.x + 8;
      const centerY = coords.y - 2;

      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", centerX);
      text.setAttribute("y", centerY); // kleiner Feintuning-Wert
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("font-size", "30"); // etwas größer als Notenkopf
      text.setAttribute("class", "note-emoji");
      text.textContent = emoji;
      svg.appendChild(text);
    });
  }

  // Dreieck-Markierung für aktive Note
  if (seriesCounter < staveNotes.length) {
    const activeNote = staveNotes[seriesCounter];
    if (activeNote && typeof activeNote.getBoundingBox === 'function') {
      const bbox = activeNote.getBoundingBox();
      if (bbox) {
        const noteX = bbox.getX() + bbox.getW() / 2;
        const triangleHeight = 5;
        const noteY = stave.getY() - 1 - triangleHeight;
        const triangleWidth = 10;
        const p1 = `${noteX - triangleWidth / 2},${noteY}`;
        const p2 = `${noteX + triangleWidth / 2},${noteY}`;
        const p3 = `${noteX},${noteY + triangleHeight}`;
        const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        triangle.setAttribute('points', `${p1} ${p2} ${p3}`);
        triangle.setAttribute('fill', 'black');
        svg.appendChild(triangle);
      }
    }
  }

  if (["8", "16", "32"].includes(noteDuration)) {
    // Erzwinge Balken ohne Fähnchen für alle schnellen Notenwerte
    staveNotes.forEach(note => {
      note.setStemDirection(1);
      // Entferne Flag-Modifikatoren (Fähnchen) aus allen schnellen Noten
      note.modifiers = note.modifiers.filter(mod => mod.getCategory() !== 'flag');
    });
    const beams = Vex.Flow.Beam.generateBeams(staveNotes);
    beams.forEach(beam => beam.setContext(context).draw());
  }
};
    
    const isNoteCorrect = (midiInfo) => {
      const expected = currentSeriesSingle[seriesCounter];
      if (!expected) return false;
    const normalizeNote = n => n.replace("♭", "b").replace("♯", "#").toLowerCase();
    const playedNote = normalizeNote(midiInfo.note);
    const expectedNote = normalizeNote(expected.note);
      return playedNote === expectedNote && midiInfo.octave === expected.octave;
    };
    const removeFromErrorNotes = (noteObj) => {
      errorNotes = errorNotes.filter(n => !(n.note === noteObj.note && n.octave === noteObj.octave && n.clef === noteObj.clef));
    };
      
      const startLocalTimer = () => {
        sessionPaused = true;
        // Setze die Opacity des Notensystems auf 50%
        const notationDiv = document.getElementById("notation");
        if (notationDiv) {
          notationDiv.style.opacity = "0.5";
        }
        pauseRemaining = 300; // 5 Minuten = 300 Sekunden
        updateLocalTimer();
        pauseInterval = setInterval(() => {
          pauseRemaining--;
          updateLocalTimer();
          if (pauseRemaining <= 0) {
            clearInterval(pauseInterval);
            endLocalTimer();
          }
        }, 1000);
      };
      
      

      const updateLocalTimer = () => {
        const timerElem = document.getElementById("timerContainer");
        if (timerElem) {
          const minutes = Math.floor(pauseRemaining / 60);
          const seconds = pauseRemaining % 60;
          timerElem.textContent = `${minutes < 10 ? "0" + minutes : minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
        }
      };

      const endLocalTimer = () => {
        sessionPaused = false;
        // Setze die Opacity des Notensystems wieder auf 100%
        const notationDiv = document.getElementById("notation");
        if (notationDiv) {
          notationDiv.style.opacity = "1";
        }
        if (gongSound) {
          gongSound.currentTime = 0;
          gongSound.play();
        }
        resetGame();
      };
      
let reverseAnimationTimeout;
let menusHidden = false;
function scheduleReverseAnimation() {
  clearTimeout(reverseAnimationTimeout);
  reverseAnimationTimeout = setTimeout(() => {
        const settingsPanel = document.getElementById("settingsPanel");
        const streakDisplay = document.getElementById("streakDisplay");
        if (settingsPanel) {
          settingsPanel.classList.remove("fly-out-right");
          settingsPanel.classList.add("fly-in-right");
        }
        if (streakDisplay) {
          streakDisplay.classList.remove("fly-out-left");
          streakDisplay.classList.add("fly-in-left");
        }
        menusHidden = false;
      }, 2000);
}
    const handleMIDIMessage = (status, data1, data2) => {
      if (sessionPaused) return;
      // Animation beim Anschlagen einer Taste:
      const settingsPanel = document.getElementById("settingsPanel");
      const streakDisplay = document.getElementById("streakDisplay");
      if (!menusHidden) {
        if (settingsPanel) {
          settingsPanel.classList.remove("fly-in-right", "fly-out-right");
          void settingsPanel.offsetWidth;
          settingsPanel.classList.add("fly-out-right");
        }
        if (streakDisplay) {
          streakDisplay.classList.remove("fly-in-left", "fly-out-left");
          void streakDisplay.offsetWidth;
          streakDisplay.classList.add("fly-out-left");
        }
        menusHidden = true;
      }
      scheduleReverseAnimation();
      if (metronomeOn) {
        const now = Date.now();
        const diff = now - lastTickTime;
        if (Math.abs(diff) > metronomeTolerance) {
          console.log(`MIDI außerhalb der Metronom-Toleranz: ${diff}ms`);
          return;
        }
      }
      resetInactivityTimer();
      if ((status & 0xf0) === 0x90 && data2 > 0) {
        if (seriesCounter >= currentSeriesSingle.length) return;
        let currentTime = Date.now();
        let responseTime = currentTime - lastNoteTimestamp;
        responseTimes.push(responseTime);
        lastNoteTimestamp = currentTime;
        const midiInfo = (() => {
          const noteNames = ['c','c#','d','d#','e','f','f#','g','g#','a','a#','b'];
          const octave = Math.floor(data1 / 12) - 1;
          const rawNote = noteNames[data1 % 12];
          const convertedNote = (rawNote === "a#") ? "bb" : rawNote;
          return { note: convertedNote, octave: octave };
        })();
    let playedNoteDisplay;
    if (kidsMode) {
      const emojiMap = {
        "c": "🐱", "d": "🐳", "e": "🐷", "f": "🐟",
        "g": "🐤", "a": "🦊", "b": "🐝", "bb": "🦁",
        "f#": "🐙", "g#": "🐵", "d#": "🐭"
      };
      playedNoteDisplay = emojiMap[midiInfo.note.toLowerCase()] || "❓";
    } else {
      playedNoteDisplay = (midiInfo.note === "b" ? "h" : midiInfo.note);
    }
        const noteDisplay = document.getElementById("noteNameDisplay");
        totalAttempts++;
        
        if (isNoteCorrect(midiInfo)) {
          // Standardfarbe für korrekte Noten: grün
          let displayColor = "green";
          if (metronomeOn) {
            const currentTime = Date.now();
            const actualInterval = currentTime - lastTickTime;
            const tolerance = metronomeInterval * 0.3;
            // Wenn zu schnell oder zu langsam gespielt wird, setze die Farbe auf gelb und zeige entsprechende Motivation
            if (actualInterval < metronomeInterval - tolerance) {
              displayColor = "orange";
              showMotivation("Zu schnell! Langsamer spielen.");
            } else if (actualInterval > metronomeInterval + tolerance) {
              displayColor = "orange";
              showMotivation("Zu langsam! Schneller spielen.");
            } else {
              clearMotivation();
              showMotivation("Super! Weiter so!");
            }
          } else {
            // Ohne Metronom: explizit grün
            clearMotivation();
            showMotivation("Super! Weiter so!");
            displayColor = "green";
          }
          // Setze die Farbe im Noten-Objekt, damit sie auch beim Zeichnen verwendet wird
          currentSeriesSingle[seriesCounter].color = displayColor;
          
          correctAnswers++;
          correctNoteCount++;
          removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
          addCircle("positive");
        if (noteDisplay) {
          noteDisplay.innerHTML = '<span style="color:' + displayColor + ';">' + playedNoteDisplay + '</span>';
        }
        sessionCounter--;
          
        } else {
          // Falsche Note: rot markieren
          currentSeriesSingle[seriesCounter].color = "red";
          errorNotes.push(currentSeriesSingle[seriesCounter]);
          addCircle("negative");
        if (noteDisplay) {
          const correctRaw = currentSeriesSingle[seriesCounter].note;
          const correctDisplay = (correctRaw === "b" ? "h" : correctRaw);
          if (kidsMode) {
            const emojiMap = {
              "c": "🐱", "d": "🐳", "e": "🐷", "f": "🐟",
              "g": "🐤", "a": "🦊", "b": "🐝", "bb": "🦁",
              "f#": "🐙", "g#": "🐵", "d#": "🐭"
            };
            const playedEmoji = emojiMap[midiInfo.note.toLowerCase()] || "❓";
            const correctEmoji = emojiMap[correctRaw.toLowerCase()] || "❓";
            noteDisplay.innerHTML = '<span style="color:red;">' + playedEmoji + ' hätte ' + correctEmoji + ' sein müssen</span>';
          } else {
            noteDisplay.innerHTML = '<span style="color:red;">' + playedNoteDisplay + '</span> <span style="color:black; font-size:1em; margin:0 5px;">&#8594;</span> <span style="color:green;">' + correctDisplay + '</span>';
            // Wizard-Modus: Inline-Auswahl der Buchstaben anzeigen
            if (wizardMode) {
              // Dynamische Auswahl basierend auf Custom Mode Settings für die aktuelle Hand
              const correctRaw = currentSeriesSingle[seriesCounter].note;
              const correctLetter = (correctRaw.toUpperCase() === "B" ? "H" : correctRaw.toUpperCase());
              // Determine available notes for current hand
              const handNotes = (selectedMode === "left"
                ? window.customModeSettings?.leftNotes
                : window.customModeSettings?.rightNotes) || [];
              const defaultNotes = ["C","D","E","F","G","A","H","C"];
              const choices = handNotes.length > 0
                ? handNotes.map(n => n.toUpperCase().replace("B", "H"))
                : defaultNotes;
              let html = `<span style="color:red;">${playedNoteDisplay}</span> <span style="color:black;">→</span> <span style="color:black; margin:0 5px;">?</span> <span style="color:black; margin:0 5px;"></span> `;
              choices.forEach(letter => {
                html += `<span class="correction-letter" style="opacity:0.5; margin:0 5px; cursor:pointer;">${letter}</span>`;
              });
              html += ` <span style="color:black; margin:0 5px;"></span>`;
              noteDisplay.innerHTML = html;
              // Klick-Handler für jeden Buchstaben
              Array.from(noteDisplay.querySelectorAll('.correction-letter')).forEach(el => {
                el.addEventListener('click', () => {
                  el.style.opacity = '1';
                  const selected = el.textContent;
                  if (selected === correctLetter) {
                    el.style.color = 'green';
                    // Markiere die Note im Notensystem
                    currentSeriesSingle[seriesCounter].color = 'green';
                    drawSeries();
                    // Als korrekte Note zählen
                    correctAnswers++;
                    correctNoteCount++;
                    removeFromErrorNotes(currentSeriesSingle[seriesCounter]);
                    addCircle("positive");
                    // Counter reduzieren und Timer aktualisieren
                    sessionCounter--;
                    updateTimer();
                    // UI schließen und Fortschritt
                    noteDisplay.innerHTML = '';
                    correctionActive = false;
                    seriesCounter++;
                    if (seriesCounter < seriesLength) {
                      queueRedraw();
                    } else {
                      generateSeries();
                    }
                  } else {
                    el.style.color = 'red';
                    const correctEl = Array.from(noteDisplay.querySelectorAll('.correction-letter'))
                      .find(e => e.textContent === correctLetter);
                    if (correctEl) {
                      correctEl.style.color = 'orange';
                      correctEl.style.opacity = '1';
                    }
                  }
                });
              });
              return;
            }
          }
        }
          if (!unlimitedLives) {
            hearts--;
            updateHeartsDisplay();
            if (hearts <= 0) { endGame(); return; }
          }
        }
        
      // Sofortiges Redraw im Scale-Modus
      if (selectedMode === "scale") {
        drawSeries();
      }

      // Scale-Mode beendet: Serie neu auswerten
      if (sessionCounter <= 0 && !sessionPaused && selectedMode !== "scale") {
        sessionCounter = 0;
        updateTimer();
        startLocalTimer();
        return;
      }
      seriesCounter++;
      if (selectedMode === "scale") {
        if (seriesCounter >= currentSeriesSingle.length) {
          generateScaleSeries(true);
        }
        return;
      }
      if (seriesCounter >= currentSeriesSingle.length) {
        generateSeries();
      } else {
        queueRedraw();
      }
      updateTimer();
      }
    };
      const resetGame = () => {
        sessionCounter = 5;      // Counter auf 1000
        totalAttempts = 0;          // Zähler für gespielte Noten auf 0
        elapsedTimer = 0;           // Timer auf 0
        gameOver = false;
        seriesCounter = 0;
        correctAnswers = 0;
        correctNoteCount = 0;
        nextMotivationThreshold = getRandomThreshold();
        sessionPaused = false;
        confettiShown = false;
        errorNotes = [];
        document.getElementById("pauseOverlay").style.display = "none";
        scoreRecorded = false;
        // Setze den Timer-Container (falls genutzt) auf 0
        document.getElementById("timerContainer").textContent = "0";
        // Nur neues Spiel starten, wenn nicht scale-Modus
        if (selectedMode !== "scale") {
          generateSeries();
        }
        updateHeartsDisplay();
      };
                                            

  // Funktion, die den Hintergrund für kurze Zeit grün färbt und danach wieder zurücksetzt
  
  function checkOrientation() {
    const settingsPanel = document.getElementById("settingsPanel");
    if (!settingsPanel) return; // Falls das Element nicht existiert, beende die Funktion
    if (window.innerWidth > window.innerHeight) {
         // Querformat (Landscape): Menü rechts, horizontal ausgerichtet
         settingsPanel.style.top = "29%";
         settingsPanel.style.right = "20px";
         settingsPanel.style.left = "";
         settingsPanel.style.transform = "";
         settingsPanel.style.flexDirection = "row";
    } else {
         // Hochformat (Portrait): Menü oben mittig, vertikal ausgerichtet
         settingsPanel.style.top = "10px";
         settingsPanel.style.left = "50%";
         settingsPanel.style.right = "";
         settingsPanel.style.transform = "translateX(-50%)";
         settingsPanel.style.flexDirection = "column";
    }
}
  window.addEventListener("resize", checkOrientation);
  checkOrientation();
  
  </script>
<script>
  // Initialisiere MIDI-Zugriff (Web MIDI API)
  function initMIDIAccess() {
    if (!navigator.requestMIDIAccess) {
      console.warn("Web MIDI API wird nicht unterstützt.");
      return;
    }

    navigator.requestMIDIAccess({ sysex: false }).then((midiAccess) => {
      console.log("✅ MIDI Access erfolgreich.");
      midiAccess.inputs.forEach((input) => {
        console.log("🎹 Eingabegerät erkannt:", input.name);
        input.onmidimessage = ({ data }) => {
          const vk = document.getElementById("virtualKeyboard");
          const isVisible = vk && vk.style.display !== "none";
          if (isVisible) return; // Ignore MIDI cable input when virtual keyboard is active

          const [status, data1, data2] = data;
          if ((status & 0xf0) === 0x90 && data2 > 0) {
            handleMIDIMessage(status, data1, data2);
          }
        };
      });

      midiAccess.onstatechange = (event) => {
        const port = event.port;
        if (port.type === "input" && port.state === "connected") {
          console.log("🔌 Neues Gerät verbunden:", port.name);
          port.onmidimessage = ({ data }) => {
            const vk = document.getElementById("virtualKeyboard");
            const isVisible = vk && vk.style.display !== "none";
            if (isVisible) return;
            const [status, data1, data2] = data;
            if ((status & 0xf0) === 0x90 && data2 > 0) {
              handleMIDIMessage(status, data1, data2);
            }
          };
        }
      };
    }).catch((err) => {
      console.error("❌ MIDI Zugriff fehlgeschlagen:", err);
    });
  }

  
  function onMIDISuccess(midiAccess) {
    // Alle vorhandenen MIDI-Eingänge initialisieren
    midiAccess.inputs.forEach((input) => {
      input.onmidimessage = (msg) => {
        const vk = document.getElementById("virtualKeyboard");
        const isVisible = vk && vk.style.display !== "none";
        if (isVisible) return;

        const [status, data1, data2] = msg.data;
        if ((status & 0xf0) === 0x90 && data2 > 0) {
          handleMIDIMessage(status, data1, data2);
        }
      };
    });
    // Auf Änderungen (z. B. Geräte an- oder abstecken) reagieren
    midiAccess.onstatechange = (event) => {
      const port = event.port;
      console.log("MIDI-Gerätestatus hat sich geändert:", port.name, port.state);
      if (port.state === "connected" && port.type === "input") {
        port.onmidimessage = (msg) => {
          const vk = document.getElementById("virtualKeyboard");
          const isVisible = vk && vk.style.display !== "none";
          if (isVisible) return;
          const [status, data1, data2] = msg.data;
          if ((status & 0xf0) === 0x90 && data2 > 0) {
            handleMIDIMessage(status, data1, data2);
          }
        };
      }
    };
  }
  
  function onMIDIFailure(error) {
    console.error("Zugriff auf MIDI-Geräte fehlgeschlagen:", error);
  }
  
</script>

<script>
  // Initialisiere MIDI-Zugriff (Web MIDI API)
  function initMIDIAccess() {
    if (!navigator.requestMIDIAccess) {
      console.warn("Web MIDI API wird nicht unterstützt.");
      return;
    }

    navigator.requestMIDIAccess({ sysex: false }).then((midiAccess) => {
      console.log("✅ MIDI Access erfolgreich.");
      midiAccess.inputs.forEach((input) => {
        console.log("🎹 Eingabegerät erkannt:", input.name);
        input.onmidimessage = ({ data }) => {
          const vk = document.getElementById("virtualKeyboard");
          const isVisible = vk && vk.style.display !== "none";
          if (isVisible) return;

          const [status, data1, data2] = data;
          handleMIDIMessage(status, data1, data2);
        };
      });

      midiAccess.onstatechange = (event) => {
        const port = event.port;
        if (port.type === "input" && port.state === "connected") {
          console.log("🔌 Neues Gerät verbunden:", port.name);
          port.onmidimessage = ({ data }) => {
            const vk = document.getElementById("virtualKeyboard");
            const isVisible = vk && vk.style.display !== "none";
            if (isVisible) return;
            const [status, data1, data2] = data;
            handleMIDIMessage(status, data1, data2);
          };
        }
      };
    }).catch((err) => {
      console.error("❌ MIDI Zugriff fehlgeschlagen:", err);
    });
  }

  function onMIDISuccess(midiAccess) {
    // Alle vorhandenen MIDI-Eingänge initialisieren
    midiAccess.inputs.forEach((input) => {
      input.onmidimessage = (msg) => {
        const [status, data1, data2] = msg.data;
        handleMIDIMessage(status, data1, data2);
      };
    });
    // Auf Änderungen (z. B. Geräte an- oder abstecken) reagieren
    midiAccess.onstatechange = (event) => {
      const port = event.port;
      console.log("MIDI-Gerätestatus hat sich geändert:", port.name, port.state);
      if (port.state === "connected" && port.type === "input") {
        port.onmidimessage = (msg) => {
          const [status, data1, data2] = msg.data;
          handleMIDIMessage(status, data1, data2);
        };
      }
    };
  }
  
  function onMIDIFailure(error) {
    console.error("Zugriff auf MIDI-Geräte fehlgeschlagen:", error);
  }

  // Direkt beim Parsen starten
  initMIDIAccess();
  </script>
<script>
    
    
    function startTutorialSequence() {
      const savedName = localStorage.getItem("userName") || "";
      const greeting = savedName ? `Hallo, ${savedName}!` : "Hallo!";
      const steps = [
        [greeting, "Du scheinst das erste Mal hier zu sein ...", "...lass uns dir zeigen, wie die App funktioniert!"],
        ["⚙️ Test: Spiele C4", "Bitte spiele C4 (MIDI-Note 60)", "✅ Super, weiter geht's!"],
        ["Du kannst nun angezeigte Noten im Notensystem spielen.", "Hierzu gibt es folgende Einstellungsmöglichkeiten...", "✋ Auswahl der Hand", "🐇 Zufallsmodus oder 🖍️ Benutzerdefiniert", "🌙 Dark Mode", "⏲️ Metronom"],
        ["Soweit startklar?", "Viel Spaß beim Spielen!"]
      ];

      const tutorialOverlay = document.createElement("div");
      tutorialOverlay.id = "tutorialOverlay";
      tutorialOverlay.style.position = "fixed";
      tutorialOverlay.style.top = "0";
      tutorialOverlay.style.left = "0";
      tutorialOverlay.style.width = "100%";
      tutorialOverlay.style.height = "100%";
      tutorialOverlay.style.backgroundColor = "#000";
      tutorialOverlay.style.zIndex = "3000";
      tutorialOverlay.style.display = "flex";
      tutorialOverlay.style.justifyContent = "center";
      tutorialOverlay.style.alignItems = "center";
      tutorialOverlay.style.color = "#FFF";
      // Stack vertically
      tutorialOverlay.style.flexDirection = "column";

      const tutorialTextContainer = document.createElement("div");
      tutorialTextContainer.id = "tutorialTextContainer";
      tutorialTextContainer.style.fontSize = "2em";
      tutorialTextContainer.style.textAlign = "center";
      tutorialTextContainer.style.opacity = "0";
      tutorialTextContainer.style.transition = "opacity 1s ease";

      tutorialOverlay.appendChild(tutorialTextContainer);
      document.body.appendChild(tutorialOverlay);

      document.getElementById("mainContent").style.display = "none";
      document.getElementById("timerContainer").style.display = "none";
      document.getElementById("settingsPanel").style.display = "none";

      let phase = 0;
      let index = 0;
      let skipRequested = false;

      // Wartet, bis das mittlere C (MIDI-Note 60) gespielt wird
      function waitForMiddleC() {
        return navigator.requestMIDIAccess({ sysex: false }).then(midiAccess => {
          return new Promise(resolve => {
            const handler = (e) => {
              const [status, data1, data2] = e.data;
              if ((status & 0xf0) === 0x90 && data2 > 0 && data1 === 60) {
                resolve();
                midiAccess.inputs.forEach(input => {
                  input.removeEventListener('midimessage', handler);
                });
              }
            };
            midiAccess.inputs.forEach(input => {
              input.addEventListener('midimessage', handler);
            });
          });
        });
      }

      function showNext() {
        if (phase >= steps.length) {
          // Fade-Übergang zum Hauptscreen
          tutorialOverlay.style.transition = "opacity 1s";
          tutorialOverlay.style.opacity = "0";
          const mainContent = document.getElementById("mainContent");
          const timerContainer = document.getElementById("timerContainer");
          const settingsPanel = document.getElementById("settingsPanel");
          mainContent.style.display = "block";
          timerContainer.style.display = "flex";
          settingsPanel.style.display = "flex";
          mainContent.style.opacity = "0";
          timerContainer.style.opacity = "0";
          settingsPanel.style.opacity = "0";
          setTimeout(() => {
            mainContent.style.transition = "opacity 1s";
            timerContainer.style.transition = "opacity 1s";
            settingsPanel.style.transition = "opacity 1s";
            mainContent.style.opacity = "1";
            timerContainer.style.opacity = "1";
            settingsPanel.style.opacity = "1";
          }, 50);
          setTimeout(() => {
            tutorialOverlay.remove();
            localStorage.setItem("tutorialCompleted", "true");
          }, 1050);
          return;
        }
        const step = steps[phase];
        // Wenn alle Nachrichten dieser Phase durchlaufen sind, zur nächsten Phase wechseln
        if (index >= step.length) {
          phase++;
          index = 0;
          setTimeout(showNext, 500);
          return;
        }
        const message = step[index];
        // Nachricht ausblenden
        tutorialTextContainer.style.opacity = "0";
        setTimeout(() => {
          // Nachricht setzen und einblenden
          tutorialTextContainer.textContent = message;
          tutorialTextContainer.style.opacity = "1";
          // Spezielle Phase 1, Nachricht 2: auf das mittlere C warten
          if (phase === 1 && index === 1) {
            // Reset skip flag and show skip button
            skipRequested = false;
            const skipBtn = document.createElement("button");
            skipBtn.id = "tutorialSkipBtn";
            skipBtn.textContent = "Überspringen";
            skipBtn.style.marginTop = "20px";
            // Style the skip button
            skipBtn.style.backgroundColor = "#000";
            skipBtn.style.color = "#FFF";
            skipBtn.style.border = "1px solid #FFF";
            skipBtn.style.padding = "0.5em 1em";
            skipBtn.style.cursor = "pointer";
            skipBtn.style.fontSize = "1em";
            skipBtn.style.borderRadius = "4px";
            skipBtn.style.boxShadow = "none";
            skipBtn.style.backgroundImage = "none";
            tutorialOverlay.appendChild(skipBtn);
            skipBtn.addEventListener("click", () => {
              skipRequested = true;
              skipBtn.remove();
              tutorialTextContainer.style.opacity = "0";
              setTimeout(() => {
                index++;
                showNext();
              }, 1000);
            });
            // Wait for middle C or skip
            waitForMiddleC().then(() => {
              skipBtn.remove();
              if (!skipRequested) {
                tutorialTextContainer.style.opacity = "0";
                setTimeout(() => {
                  index++;
                  showNext();
                }, 1000);
              }
            });
          } else {
            // Normales Weiterschalten nach 3 Sekunden
            index++;
            setTimeout(() => {
              tutorialTextContainer.style.opacity = "0";
              setTimeout(showNext, 1000);
            }, 3000);
          }
        }, 1000);
      }

      showNext();
    }
// Starte das Hilfe-/Tutorial-Fenster beim Laden, falls noch nicht abgeschlossen
document.addEventListener("DOMContentLoaded", () => {
  if (!localStorage.getItem('tutorialCompleted')) {
    startTutorialSequence();
  }
});
</script>
<style>
  .vf-stavenote.selected path {
    stroke: green !important;
    fill: green !important;
  }
@keyframes flyOutRight {
  from { opacity: 1; transform: translateX(0); }
  to   { opacity: 0; transform: translateX(100%); }
}
@keyframes flyOutLeft {
  from { opacity: 1; transform: translateX(0); }
  to   { opacity: 0; transform: translateX(-100%); }
}
.fly-out-right {
  animation: flyOutRight 0.5s forwards;
}
.fly-out-left {
  animation: flyOutLeft 0.5s forwards;
}
@keyframes flyInRight {
  from { opacity: 0; transform: translateX(100%); }
  to   { opacity: 1; transform: translateX(0); }
}
@keyframes flyInLeft {
  from { opacity: 0; transform: translateX(-100%); }
  to   { opacity: 1; transform: translateX(0); }
}
.fly-in-right {
  animation: flyInRight 0.5s forwards;
}
.fly-in-left {
  animation: flyInLeft 0.5s forwards;
}
</style>
<style>
  /* Weniger Abstand des Notensystems nach oben */
  #notation {
    margin-top: 10px;
  }
  /* Scale-Clef-Buttons standardmäßig verbergen */
  #scaleSelector {
    display: none;
  }
  /* Styling für Oktaven-Buttons: weißer Hintergrund, schwarzer Rand */
  #scaleSelector button {
    background-color: white;
    border: 2px solid black;
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qwerty-hancock/0.7.2/qwerty-hancock.min.js"></script>
</head>
<body>
    <!-- Direkt nach <body> einfügen -->
    
    
    <div id="streakDisplay"></div>
    <!-- Canvas für Animation (Hintergrund) -->
    <canvas id="animationCanvas"></canvas>
    <!-- Audio-Element (deaktiviert) -->
    <!--
    <audio id="backgroundSound" autoplay>
        <source src="https://raw.githubusercontent.com/JP0024/piano.github.io/3d35e0a8d4eb3e018151018e36e225dc7a856ecd/mixkit-relaxing-harp-sweep-2628.wav" type="audio/wav">
            Dein Browser unterstützt das Audio-Element nicht.
    </audio>
    -->
    <!-- Pause-Overlay -->
    <div id="pauseOverlay">
        <div id="pauseInfo">
            <div id="pauseHeader">SESSION PAUSIERT</div>
            <div id="pauseProgressContainer">
                <div id="pauseProgress"></div>
                <div id="pauseTime" style="position:absolute; left:0; top:0; font-size:14px; color:#000; padding:0 5px;"></div>
            </div>
        </div>
        <!-- Kachelwand -->
        <div id="pauseTiles"></div>
    </div>
    <!-- Welcome Overlay -->
    <div id="welcomeOverlay">
        <div id="welcomeMessage"><br>Schön, dass du da bist!<br></div>
    </div>
    <!-- Game Over Overlay -->
    <div id="gameOverOverlay"></div>
    <!-- Scoreboard Overlay -->
    <div id="scoreboardOverlay" class="hidden"></div>
    <!-- Motivationsfenster -->
    <div id="motivationOverlay"></div>
    <!-- Timer Container -->
    <div id="timerContainer"></div>
    <!-- Hauptinhalt -->
    <div id="settingsPanel" style="position: fixed; top: 20%; right: 10px; background: rgba(255,255,255,0.8); padding: 10px; border: 1px solid #000; border-radius: 8px; z-index: 200;"></div>
    <div id="mainContent">
       
        <div id="notation"></div>
        <div id="noteNameDisplay" style="position: fixed; left:50%; bottom:110px; transform: translateX(-50%); font-size:5em; text-transform: uppercase; z-index: 1000; pointer-events: auto;"></div>
        <div id="correctionBox" class="hidden">
          <div id="correctionChoices">
            <button id="prevNoteBtn">&lt;</button>
            <span id="correctionNoteDisplay">&lt; ? &gt;</span>
            <button id="nextNoteBtn">&gt;</button>
          </div>
          <button id="confirmNoteBtn">OK</button>
        </div>
        <div id="buttonContainer">
            <div id="clefTitle" onclick="cycleRange()">C-Lage</div>
            <div id="heartsContainer" style="margin-left:10px;"></div>
        </div>
    </div>
    <!-- Einstellungen-Menü -->
    
    <script>
        /* Falls im Pause-Modus: Aktualisiere Fortschrittsbalken und verbleibende Zeit (mm:ss) */
        function updatePauseProgress() {
            const progressBar = document.getElementById("pauseProgress");
            const timeDisplay = document.getElementById("pauseTime");
            if (progressBar && pauseDuration > 0) {
                const percent = ((pauseDuration - pauseRemaining) / pauseDuration) * 100;
                progressBar.style.width = percent + "%";
                if (timeDisplay) {
                    const m = Math.floor(pauseRemaining / 60);
                    const s = pauseRemaining % 60;
                    timeDisplay.textContent = (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
                }
            }
        }
        
    </script>
    
    <script>
        let deferredPrompt;
        // Abfangen des beforeinstallprompt-Events und automatisches Auslösen des Prompts
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('beforeinstallprompt Event empfangen');
            // Automatisch das Installations-Prompt auslösen
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the PWA install prompt');
                } else {
                    console.log('User dismissed the PWA install prompt');
                }
                deferredPrompt = null;
            });
        });
        
        // Falls die App installiert wurde, kann hier optional eine Logik implementiert werden
        window.addEventListener('appinstalled', () => {
            console.log('App wurde als PWA installiert');
        });
    </script>
    
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const settingsPanel = document.getElementById("settingsPanel");
            if (!settingsPanel) return;
            let fadeTimeout;
            const resetFadeTimer = () => {
                clearTimeout(fadeTimeout);
                // Setze sofort auf volle Opacity
                settingsPanel.style.opacity = "1";
                // Starte Timer: nach 10 Sekunden wird die Opacity auf 0.5 reduziert
                fadeTimeout = setTimeout(() => {
                    settingsPanel.style.opacity = "0.5";
                }, 10000);
            };
            // Initialer Timer-Start
            resetFadeTimer();
            // Bei Maus- oder Touch-Interaktion den Timer zurücksetzen
            settingsPanel.addEventListener("mouseenter", resetFadeTimer);
            settingsPanel.addEventListener("touchstart", resetFadeTimer);
        });
        
        function getAllTrophies() {
            return [
                    "🐢","🐌","🚶‍♂️","🏃","⚡",
                    "🎼","🎹","🎺","🪕","🪗",
                    "🌱","🌿","🌻","🌲","🎄","🔥","🚀","🪐","🌞","👑",
                    "🔀","🌀","🔁","⏩","⚙️",
                    "📏","📐","🧭","🎯","🏁"
                    ];
        }
        
        function showTrophyTransitionScreen(callback) {
            const overlay = document.getElementById("pauseOverlay");
            overlay.innerHTML = "";
            overlay.style.display = "flex";
            
            const trophyContainer = document.createElement("div");
            trophyContainer.style.display = "flex";
            trophyContainer.style.flexDirection = "column";
            trophyContainer.style.alignItems = "center";
            trophyContainer.style.justifyContent = "center";
            trophyContainer.style.opacity = "0";
            trophyContainer.style.transition = "opacity 1s";
            
            const newUnlocked = JSON.parse(sessionStorage.getItem("justUnlockedTrophies") || "[]");
            const justLost = JSON.parse(sessionStorage.getItem("justLostTrophies") || "[]");
            
            if (newUnlocked.length > 0) {
                const gainedTitle = document.createElement("h2");
                gainedTitle.textContent = isGerman ? "Neu freigeschaltet" : "Newly Unlocked";
                trophyContainer.appendChild(gainedTitle);
                
                newUnlocked.forEach(index => {
                    const emoji = getAllTrophies()[index];
                    const description = getTrophyDescription(index);
                    const block = document.createElement("div");
                    block.style.margin = "10px";
                    block.style.fontSize = "1.5em";
                    block.innerHTML = `<div>${emoji}</div><div style="font-size:0.8em">${description}</div>`;
                    trophyContainer.appendChild(block);
                });
            }
            
            if (justLost.length > 0) {
                const lostTitle = document.createElement("h2");
                lostTitle.textContent = isGerman ? "Verloren" : "Lost";
                trophyContainer.appendChild(lostTitle);
                
                justLost.forEach(index => {
                    const emoji = getAllTrophies()[index];
                    const description = getTrophyDescription(index);
                    const block = document.createElement("div");
                    block.style.margin = "10px";
                    block.style.opacity = "0.5";
                    block.style.fontSize = "1.5em";
                    block.innerHTML = `<div>${emoji}</div><div style="font-size:0.8em">${description}</div>`;
                    trophyContainer.appendChild(block);
                });
            }
            
            overlay.appendChild(trophyContainer);
            
            // Fade-in
            setTimeout(() => {
                trophyContainer.style.opacity = "1";
            }, 100);
            
            // Nach 3 Sekunden weiter zur Session-Pause
            setTimeout(() => {
                overlay.style.opacity = "0";
                setTimeout(() => {
                    overlay.style.display = "none";
                    overlay.style.opacity = "1";
                    callback();
                }, 1000);
            }, 3000);
        }
        
    </script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
      // 1) Create hidden keyboard container
      const vk = document.createElement("div");
      vk.id = "virtualKeyboard";
      vk.style.position = "fixed";
      const bc = document.getElementById("buttonContainer");
      const bottomOffset = bc.offsetHeight + 15;
      vk.style.bottom = bottomOffset + "px";
      vk.style.left = "20px";
      vk.style.width = "calc(100% - 40px)";
      vk.style.height = "200px";
      vk.style.display = "none";
      document.body.appendChild(vk);

      // 2) Helper to convert note name to MIDI number
      function noteToMidi(note) {
        const semitones = { c:0, "c#":1, d:2, "d#":3, e:4, f:5, "f#":6, g:7, "g#":8, a:9, "a#":10, b:11 };
        const m = note.match(/^([a-g]#?)(\d)$/i);
        if (!m) return 60;
        const pitch = m[1].toLowerCase();
        const octave = parseInt(m[2], 10);
        return (octave + 1) * 12 + semitones[pitch];
      }

      // 3) Initialize Qwerty Hancock keyboard
      const keyboard = new QwertyHancock({
        id: "virtualKeyboard",
        width: window.innerWidth,
        height: 200,
        octaves: 1,
        startNote: "C4",
        whiteNotesColour: "#fff",
        blackNotesColour: "#000",
        hoverColour: "#f00"
      });
      keyboard.keyDown = (note, freq) => {
        const vk = document.getElementById("virtualKeyboard");
        const isVisible = vk && vk.style.display !== "none";
        if (!isVisible) return; // Prevent double trigger when not actively visible
        handleMIDIMessage(144, noteToMidi(note), 127);
      };
      keyboard.keyUp = () => {};

      // 4) Add toggle button to settings panel
      const btn = document.createElement("span");
      btn.id = "keyboardToggle";
      btn.textContent = "";
      btn.style.cursor = "pointer";
      const settingsPanel = document.getElementById("settingsPanel");
      if (settingsPanel) settingsPanel.appendChild(btn);


      btn.addEventListener("click", () => {
        if (vk.style.display === "none") {
          vk.style.display = "block";
          const kbHeight = vk.offsetHeight;
          document.getElementById("mainContent").style.marginBottom = kbHeight + "px";
          const noteDisplay = document.getElementById("noteNameDisplay");
          if (noteDisplay) noteDisplay.style.bottom = (kbHeight + 110) + "px";
        } else {
          vk.style.display = "none";
          document.getElementById("mainContent").style.marginBottom = "0";
          const noteDisplay = document.getElementById("noteNameDisplay");
          if (noteDisplay) noteDisplay.style.bottom = "110px";
        }
      });
    });
    </script>
    <script>
      
        
        // Neuer Custom Mode JS (vereinfachte Version)
        document.addEventListener('DOMContentLoaded', function() {
          const modal = document.getElementById('customModeModal');
          if (!modal) return;

          // 1. Neue Mapping-Struktur für Kombination von Schlüssel + Lage
          const clefRangeMapping = {
            bass: {
              C: ["C", "D", "E", "F", "G", "A", "H"],
              D: ["d", "e", "f#", "g", "a"],
              F: ["f", "g", "a", "bb", "c"],
              G: ["g", "a", "h", "c", "d"],
              MC: ["c", "d", "e", "f", "g"]
            },
            treble: {
              C: ["c'", "d'", "e'", "f'", "g'", "a'", "h'"],
              D: ["d'", "e'", "f#'", "g'", "a'"],
              F: ["f'", "g'", "a'", "bb'", "c''"],
              G: ["g'", "a'", "h'", "c''", "d''"],
              MC: ["c'", "d'", "e'", "f'", "g'"]
            }
          };

          // 2. Neue globale Variablen
          let selectedClef = null;
          let selectedRange = null;

          // 3. Statische Oktaven und Noten-Checkboxen beim Laden/erstmaligem Öffnen
          const content = document.getElementById('customModeContent');
          if (content) {
            content.innerHTML = '';
            const octaves = {
              "große Oktave": ["C", "D", "E", "F", "G", "A", "H"],
              "kleine Oktave": ["c", "d", "e", "f", "g", "a", "h"],
              "eingestrichene Oktave": ["c'", "d'", "e'", "f'", "g'", "a'", "h'"],
              "zweigestrichene Oktave": ["c''", "d''", "e''", "f''", "g''", "a''", "h''"],
            };
            Object.entries(octaves).forEach(([octaveName, notes]) => {
              const headline = document.createElement('div');
              headline.textContent = octaveName;
              headline.style.fontWeight = "bold";
              headline.style.marginTop = "10px";
              content.appendChild(headline);
              notes.forEach(note => {
                const label = document.createElement('label');
                label.style.marginRight = "8px";
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = note;
                checkbox.checked = false;
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(note));
                content.appendChild(label);
              });
            });
          }

          // 4. Zentrale Aktualisierungsfunktion für Checkboxen
          function updateCustomModeCheckboxes() {
            if (!selectedClef || !selectedRange) return;
            const notesToActivate = clefRangeMapping[selectedClef][selectedRange] || [];
            const checkboxes = document.querySelectorAll('#customModeContent input[type=checkbox]');
            checkboxes.forEach(cb => {
              cb.checked = notesToActivate.includes(cb.value);
            });
          }

          // 5. Eventlistener für Lagen-Auswahl (Range)
          document.querySelectorAll('.custom-mode-range-option').forEach(el => {
            el.addEventListener('click', () => {
              document.querySelectorAll('.custom-mode-range-option').forEach(opt => opt.classList.remove('active'));
              el.classList.add('active');
              selectedRange = el.getAttribute('data-range');
              updateCustomModeCheckboxes();
            });
          });

          // 6. Eventlistener für Schlüsselauswahl (Clef)
          document.querySelectorAll('.custom-mode-clef-option').forEach(el => {
            el.addEventListener('click', () => {
              document.querySelectorAll('.custom-mode-clef-option').forEach(opt => opt.classList.remove('active'));
              el.classList.add('active');
              selectedClef = el.getAttribute('data-clef');
              updateCustomModeCheckboxes();
            });
          });

          // 7. Speichern-Button
          const saveBtn = document.getElementById('custom-mode-save-button');
          if (saveBtn) {
            saveBtn.addEventListener('click', () => {
              const content = document.getElementById('customModeContent');
              if (!selectedClef || !selectedRange || !content) return;
              const selected = Array.from(content.querySelectorAll('input[type=checkbox]'))
                .filter(cb => cb.checked)
                .map(cb => cb.value);
              // Notenwert-Checkbox
              const noteValueCheckbox = document.getElementById('noteValueCheckbox');
              const noteValue = noteValueCheckbox && noteValueCheckbox.checked ? "8" : "q";
              window.customModeSettings = {
                clef: selectedClef,
                range: selectedRange,
                selectedNotes: selected.map(n => n.replace(/'/g, "").toLowerCase()),
                noteValue: noteValue
              };
              // clefTitle aktualisieren
              const clefTitle = document.getElementById("clefTitle");
              if (clefTitle && selectedRange) {
                clefTitle.textContent = selectedRange + "-Lage";
              }
              generateSeries();
              modal.classList.add('hidden');
            });
          }
        });
        
        window.addEventListener("DOMContentLoaded", () => {
          const confirmBtn = document.getElementById("confirmScaleSelection");
          if (confirmBtn) {
            confirmBtn.addEventListener("click", () => {
              if (selectedMode === "scale" && selectedNotes.length > 0) {
                localStorage.setItem("customOneHandNotes", JSON.stringify(selectedNotes));
                selectedMode = "left";
                seriesCounter = 0;
                correctNoteCount = 0;

                currentSeriesSingle = Array.from({ length: 1000 }, () => {
                  const i = Math.floor(Math.random() * selectedNotes.length);
                  return selectedNotes[i];
                });

                drawSeries();
              } else {
                alert("Bitte mindestens eine Note auswählen, bevor du speicherst!");
              }
            });
          }
        });
    </script>
   
    <div id="customModeModal" class="hidden">
        <h2>Benutzerdefiniert</h2>
        <div class="custom-mode-row">
            <!-- Notenschlüssel & Lagen-Auswahl -->
            <div class="custom-mode-clef-container">
                <div class="custom-mode-clef-option" data-clef="treble">🎼</div>
                <div class="custom-mode-clef-option" data-clef="bass">𝄢</div>
            </div>
            <div class="custom-mode-range-container">
                <div class="custom-mode-range-option" data-range="C">C</div>
                <div class="custom-mode-range-option" data-range="D">D</div>
                <div class="custom-mode-range-option" data-range="F">F</div>
                <div class="custom-mode-range-option" data-range="G">G</div>
                <div class="custom-mode-range-option" data-range="MC">MC</div>
            </div>
        </div>
        <div id="customModeContent" style="margin-top: 10px;">
          <!-- Hier werden dynamisch Oktavennamen und Checkboxen eingefügt -->
        </div>
        <div class="custom-mode-row">
            <label for="noteValueCheckbox" style="font-weight: bold;">Wertvariation</label>
            <input type="checkbox" id="noteValueCheckbox" />
          </div>
        <div class="custom-mode-save">
            <button id="custom-mode-save-button">Speichern</button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('customModeModal');
            if (!modal) {
                console.error('Modal nicht gefunden.');
                return;
            }

            let selectedCustomClef = null;
            let selectedCustomRange = null;

            // Eventlistener für Schlüsselauswahl
            document.querySelectorAll('.custom-mode-clef-option').forEach(el => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.custom-mode-clef-option').forEach(opt => opt.classList.remove('active'));
                    el.classList.add('active');
                    selectedCustomClef = el.getAttribute('data-clef');
                    populateCustomNotes();
                });
            });

            // Eventlistener für Lagen-Auswahl
            document.querySelectorAll('.custom-mode-range-option').forEach(el => {
                el.addEventListener('click', () => {
                    document.querySelectorAll('.custom-mode-range-option').forEach(opt => opt.classList.remove('active'));
                    el.classList.add('active');
                    selectedCustomRange = el.getAttribute('data-range');
                    populateCustomNotes();
                });
            });

            // Notenzuordnungen für linke und rechte Hand
            const customLeftNotesMapping = {
                "C": ["C", "D", "E", "F", "G", "A"],
                "D": ["D", "E", "F#", "G", "A", "B"],
                "F": ["F", "G", "A", "Bb", "C"],
                "G": ["G", "A", "B", "C", "D", "E"],
                "MC": ["F", "G", "A", "B", "C"]
            };
            const customRightNotesMapping = {
                "C": ["C", "D", "E", "F", "G", "A"],
                "D": ["D", "E", "F#", "G", "A", "B"],
                "F": ["F", "G", "A", "Bb", "C"],
                "G": ["G", "A", "B", "C", "D", "E"],
                "MC": ["F", "G", "A", "B", "C"]
            };

            // Funktion, um basierend auf der ausgewählten Lage die Noten für linke und rechte Hand zu befüllen
            function populateCustomNotes() {
                if (!selectedCustomRange) return;
                const leftContainer = document.getElementById('left-hand-notes');
                const rightContainer = document.getElementById('right-hand-notes');
                if (!leftContainer || !rightContainer) {
                    console.error('Noten-Container nicht gefunden.');
                    return;
                }
                leftContainer.innerHTML = '';
                rightContainer.innerHTML = '';

                customLeftNotesMapping[selectedCustomRange].forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'custom-mode-note-option';
                    noteEl.textContent = note;
                    noteEl.setAttribute('data-note', note);
                    noteEl.addEventListener('click', () => {
                        noteEl.classList.toggle('active');
                    });
                    leftContainer.appendChild(noteEl);
                });

                customRightNotesMapping[selectedCustomRange].forEach(note => {
                    const noteEl = document.createElement('div');
                    noteEl.className = 'custom-mode-note-option';
                    noteEl.textContent = note;
                    noteEl.setAttribute('data-note', note);
                    noteEl.addEventListener('click', () => {
                        noteEl.classList.toggle('active');
                    });
                    rightContainer.appendChild(noteEl);
                });
            }

            // Eventlistener für den Speichern-Button im Custom Mode Modal
            const saveButton = document.getElementById('custom-mode-save-button');
            if (saveButton) {
                saveButton.addEventListener('click', () => {
                    const activeClef = document.querySelector('.custom-mode-clef-option.active');
                    const activeRange = document.querySelector('.custom-mode-range-option.active');
                    const activeLeftNotes = document.querySelectorAll('#left-hand-notes .custom-mode-note-option.active');
                    const activeRightNotes = document.querySelectorAll('#right-hand-notes .custom-mode-note-option.active');
                    const noteValueCheckbox = document.getElementById('noteValueCheckbox');
                    const noteValue = noteValueCheckbox.checked ? "8" : "q";  // "8" für Achtelnoten, "q" als Standard (Viertelnoten)
                    
                    const settings = {
                        clef: activeClef ? activeClef.getAttribute('data-clef') : null,
                        range: activeRange ? activeRange.getAttribute('data-range') : null,
                        leftNotes: Array.from(activeLeftNotes).map(el => el.getAttribute('data-note')),
                        rightNotes: Array.from(activeRightNotes).map(el => el.getAttribute('data-note')),
                        noteValue: noteValue
                    };
                    
                    console.log("Benutzerdefinierte Einstellungen:", settings);
                    window.customModeSettings = settings;
                    modal.classList.add('hidden');
                    
                    // Aktualisiere den Lagen-Button (clefTitle)
                    const clefTitle = document.getElementById("clefTitle");
                    if (clefTitle && settings.range) {
                        clefTitle.textContent = settings.range + "-Lage";
                    }
                    
                    generateSeries();
                });
            } else {
                console.warn('Speichern-Button nicht gefunden.');
            }
        });
        
        function showCorrection(note, choices) {
          correctionActive = true;
          expectedNote = note;
          availableNotes = choices;
          selectedNoteIndex = 0;
          updateCorrectionDisplay();
          document.getElementById("correctionBox").classList.remove("hidden");
        }

        function updateCorrectionDisplay(result) {
          const display = document.getElementById("correctionNoteDisplay");
          const confirm = document.getElementById("confirmNoteBtn");
          if (result === "correct") {
            confirm.textContent = "🥳";
          } else if (result === "wrong") {
            confirm.textContent = "❌";
          } else {
            confirm.textContent = "OK";
          }
          display.textContent = `< ${availableNotes[selectedNoteIndex] || "?"} >`;
        }

        const prevNoteBtn = document.getElementById("prevNoteBtn");
        if (prevNoteBtn) {
          prevNoteBtn.addEventListener("click", () => {
            selectedNoteIndex = (selectedNoteIndex - 1 + availableNotes.length) % availableNotes.length;
            updateCorrectionDisplay();
          });
        }

        const nextNoteBtn = document.getElementById("nextNoteBtn");
        if (nextNoteBtn) {
          nextNoteBtn.addEventListener("click", () => {
            selectedNoteIndex = (selectedNoteIndex + 1) % availableNotes.length;
            updateCorrectionDisplay();
          });
        }

        const confirmNoteBtn = document.getElementById("confirmNoteBtn");
        if (confirmNoteBtn) {
          confirmNoteBtn.addEventListener("click", () => {
            const selected = availableNotes[selectedNoteIndex];
            if (selected === expectedNote) {
              updateCorrectionDisplay("correct");
              setTimeout(() => {
                document.getElementById("correctionBox").classList.add("hidden");
                correctionActive = false;
                resetGame(); // oder nächster Schritt
              }, 1000);
            } else {
              updateCorrectionDisplay("wrong");
            }
          });
        }

        function handleCorrectionInput(notePlayed) {
          if (!correctionActive) return;
          if (notePlayed === expectedNote) {
            updateCorrectionDisplay("correct");
            setTimeout(() => {
              document.getElementById("correctionBox").classList.add("hidden");
              correctionActive = false;
              resetGame();
            }, 1000);
          } else {
            updateCorrectionDisplay("wrong");
          }
        }
        
          function showCorrection(note, choices) {
            correctionActive = true;
            expectedNote = note;
            availableNotes = choices;

            let container = document.getElementById('correctionContainer');
            if (!container) {
              container = document.createElement('div');
              container.id = 'correctionContainer';
              Object.assign(container.style, {
                position: 'fixed',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                background: '#fff',
                padding: '20px',
                border: '2px solid #000',
                zIndex: '1000'
              });
              document.body.appendChild(container);
            }
            container.innerHTML = '';

            choices.forEach(choice => {
              const btn = document.createElement('div');
              btn.textContent = choice.toUpperCase();
              btn.className = 'correction-choice';
              btn.addEventListener('click', () => {
                if (btn.textContent === expectedNote.toUpperCase()) {
                  btn.style.opacity = '1';
                  btn.style.backgroundColor = 'green';
                } else {
                  btn.style.opacity = '1';
                  btn.style.backgroundColor = 'red';
                  const correctBtn = Array.from(container.children)
                    .find(child => child.textContent === expectedNote.toUpperCase());
                  if (correctBtn) correctBtn.style.backgroundColor = 'yellow';
                }
                setTimeout(() => {
                  container.remove();
                  correctionActive = false;
                  resetGame();
                }, 1000);
              });
              container.appendChild(btn);
            });
          }
        </script>
    <script>
        // Referenzen
        const settingsPanel       = document.getElementById('settingsPanel');
        const emojiContainer      = document.getElementById('settingsEmojiContainer');
        const emojiItems = emojiContainer ? emojiContainer.querySelectorAll('.settings-emoji') : [];

        // --- A) Long-Press (3 Sekunden) zum Auf-/Zuklappen ---
        let longPressTimer;
        settingsPanel.addEventListener('pointerdown', () => {
          longPressTimer = setTimeout(() => {
            settingsPanel.classList.toggle('expanded');
          }, 3000); // 3000 ms = 3 s
        });
        ['pointerup','pointerleave','pointercancel'].forEach(evt =>
          settingsPanel.addEventListener(evt, () => clearTimeout(longPressTimer))
        );
        // --- B) Drag-n-Drop zum Umordnen und Speichern ---
        let dragged = null;
        emojiItems.forEach(item => {
          item.addEventListener('dragstart',  e => { dragged = item; });
          item.addEventListener('dragover',   e => { e.preventDefault(); item.classList.add('drag-over'); });
          item.addEventListener('dragleave',  () => { item.classList.remove('drag-over'); });
          item.addEventListener('drop',       e => {
            e.preventDefault();
            item.classList.remove('drag-over');
            if (dragged && dragged !== item) {
              // Reihenfolge in DOM anpassen
              const nodes = Array.from(emojiContainer.children);
              const from = nodes.indexOf(dragged);
              const to   = nodes.indexOf(item);
              if (from < to) emojiContainer.insertBefore(dragged, item.nextSibling);
              else           emojiContainer.insertBefore(dragged, item);
              // Neue Reihenfolge speichern
              const order = Array.from(emojiContainer.children).map(el => el.textContent);
              localStorage.setItem('settingsEmojiOrder', JSON.stringify(order));
            }
          });
        });

        // --- C) Reihenfolge beim Laden wiederherstellen ---
        const savedOrder = JSON.parse(localStorage.getItem('settingsEmojiOrder')||'[]');
        if (savedOrder.length) {
          savedOrder.forEach(sym => {
            const el = Array.from(emojiContainer.children)
                            .find(span => span.textContent === sym);
            if (el) emojiContainer.appendChild(el);
          });
        }
    </script>
    </script>
    
</body>
</script>
</head>
<body>
</html>

        
        

